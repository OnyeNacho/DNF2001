; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.9044.0 

	TITLE	D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_1HO@DOMN@?$AAG?$AAe?$AAt?$AAA?$AAl?$AAl?$AAo?$AAc?$AAs?$AAS?$AAt?$AAa?$AAt?$AAs?$AA?$CI?$AA?$CJ?$AA?5?$AAn?$AAo?$AAt@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_11A@?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_13HMCP@?$AA?2?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DIHH@Pos?$DO?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@JEDA@Pos?$CLNum?$DM?$DNBytes?4Num?$CI?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NOIE@InPos?$DO?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@PKIF@InPos?$DM?$DNBytes?4Num?$CI?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BM@LKB@?$AAU?$AAn?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAe?$AAd?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CC@CPAJ@?$AA?$CF?$AA0?$AA8?$AAX?$AA?$CF?$AA0?$AA8?$AAX?$AA?$CF?$AA0?$AA8?$AAX?$AA?$CF?$AA0?$AA8?$AAX?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@IPGH@?4?4?2?4?4?2Core?2Inc?2UnObjBas?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LCAF@Class?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_17HGCB@?$AAF?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@NOGP@?$AAA?$AAc?$AAt?$AAo?$AAr?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_13NHLM@?$AAA?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_13LOIM@?$AAU?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_19FLGB@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@DMLA@?4?4?2?4?4?2Core?2Inc?2UnClass?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DA@NIKO@Defaults?$FLCPD_Normal?$FN?4Num?$CI?$CJ?$DN?$DNGetP@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@BEPO@Defaults?$FLCPD_Normal?$FN?4Num?$CI?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_19NGFL@?$AAN?$AAo?$AAn?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BM@ECHK@?$AAU?$AAn?$AAh?$AAa?$AAs?$AAh?$AAe?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAm?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@IEJK@?4?4?2?4?4?2Core?2Inc?2UnMem?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@DFNF@TopChunk?$DN?$DNNULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@BION@?4?4?2?4?4?2Core?2Inc?2UnMath?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JDHJ@i?$DO?91?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03FBPA@i?$DM3?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PLGH@i?$DM2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CA@BFE@?$AAR?$AAe?$AAs?$AAo?$AAl?$AAv?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?4?$AA?4?$AA?4?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@EDDF@?4?4?2?4?4?2Engine?2Inc?2UnNetStuff?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GDHO@hThread?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_15DEDE@?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@JICC@?4?4?2?4?4?2Engine?2Inc?2ABrush?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NJDM@Brush?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DJGJ@Other?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@ELOE@Other?9?$DOBrush?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@NPJG@?$AAT?$AAi?$AAt?$AAl?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BG@COBA@?$AAL?$AAe?$AAv?$AAe?$AAl?$AAI?$AAn?$AAf?$AAo?$AA0?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CC@JMMP@?$AAI?$AAd?$AAe?$AAa?$AAl?$AAP?$AAl?$AAa?$AAy?$AAe?$AAr?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@IIGF@?4?4?2?4?4?2Engine?2Inc?2UnLevel?4h?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DADJ@Actors?4Num?$CI?$CJ?$DO?$DN2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@OIOI@Actors?$CI1?$CJ?$CB?$DNNULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@EHGL@Actors?$CI1?$CJ?9?$DOBrush?$CB?$DNNULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CI@PENI@?$AAA?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAf?$AAo?$AAu?$AAn?$AAd?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HBFO@Actors?$CI0?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@OLMN@Actors?$CI0?$CJ?9?$DOIsA?$CIALevelInfo?3?3Stati@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_19PPKP@?$AAU?$AAs?$AAe?$AAr?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@KAEM@?$AAR?$AAe?$AAs?$AAe?$AAt?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BE@ECAA@?$AAH?$AAH?$AAi?$AAt?$AAP?$AAr?$AAo?$AAx?$AAy?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BNHE@?$AAH?$AAA?$AAc?$AAt?$AAo?$AAr?$AAV?$AAe?$AAr?$AAt?$AAe?$AAx?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GCAE@Index?$DO?$DN0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_1BI@IADD@?$AAH?$AAa?$AAs?$AAh?$AAM?$AAa?$AAp?$AAH?$AAa?$AAs?$AAh?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??8@YAHABU_GUID@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appRound@@YAHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Serialize@FOutputDevice@@UAEXPBDW4EName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Flush@FOutputDevice@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FConfigCache@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFConfigCache@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appToUpper@@YAGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appToLower@@YAGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appStrihash@@YAKPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appSin@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appCos@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appAcos@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appRand@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appFrand@@YAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appSqrt@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appFloor@@YAHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appMemcpy@@YAXPAXPBXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appMemzero@@YAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_U@YAPAXIPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_U@YAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_V@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FArchive@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SerializeBits@FArchive@@UAEXPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SerializeInt@FArchive@@UAEXAAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Preload@FArchive@@UAEXPAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CountBytes@FArchive@@UAEXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??6FArchive@@UAEAAV0@AAVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??6FArchive@@UAEAAV0@AAPAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MapName@FArchive@@UAEHPAVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MapObject@FArchive@@UAEHPAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?TotalSize@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?AtEnd@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?AttachLazyLoader@FArchive@@UAEXPAVFLazyLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?DetachLazyLoader@FArchive@@UAEXPAVFLazyLoader@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Precache@FArchive@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Flush@FArchive@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Close@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetError@FArchive@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ByteOrderSerialize@FArchive@@QAEAAV1@PAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArchive@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Ver@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsLoading@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsSaving@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsTrans@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsPersistent@FArchive@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AA_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@E@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@H@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@G@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfo@VFName@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Num@FArray@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Insert@FArray@@QAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Add@FArray@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Shrink@FArray@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Empty@FArray@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArray@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArray@@QAE@W4ENoInit@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FArray@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CountBytes@FArray@@QAEXAAVFArchive@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FArray@@IAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FLazyLoader@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@QAE@W4ENoInit@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FString@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFString@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFString@@QAEAAV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFString@@QAE?AV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFString@@QAEAAV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFString@@QBE?AV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Len@FString@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Left@FString@@QBE?AV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Mid@FString@@QBE?AV1@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?InStr@FString@@QBEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?InStr@FString@@QBEHABV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FString@@AAE@HPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FStringNoInit@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FStringNoInit@@QAEAAU0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeHash@@YAKABVFString@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@FStringOutputDevice@@UAEXPBGW4EName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FOutputDevice@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FBufferWriter@@QAE@AAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@FBufferWriter@@UAEXPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Tell@FBufferWriter@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Seek@FBufferWriter@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TotalSize@FBufferWriter@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFBufferWriter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FBufferWriter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFBufferArchive@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FBufferArchive@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FBufferReader@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFName@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetIndex@FName@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FName@@QAE@W4EName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FName@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeHash@@YAKVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorList@@QAE@PAU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FGuid@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FGuid@@QAE@KKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFGuid@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UObject@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UObject@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticConfigName@UObject@@SAPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??3UObject@@SAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsPendingKill@UObject@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetClass@UObject@@QBEPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetFlags@UObject@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetName@UObject@@UBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetFName@UObject@@QBE?BVFName@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetOuter@UObject@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetIndex@UObject@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeHash@@YAKPBVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??EFObjectIterator@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPackageMap@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPackageMap@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPackageMap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMaxObjectIndex@UPackageMap@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPackageMap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UPackageMap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPackage@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPackage@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPackage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPackage@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@USubsystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1USubsystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0USubsystem@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Tick@USubsystem@@UAIXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FExec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UCommandlet@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UCommandlet@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UCommandlet@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUCommandlet@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FStringNoInit@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UCommandlet_eventMain_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UCommandlet_eventMain_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULanguage@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULanguage@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UTextBuffer@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UTextBuffer@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UTextBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUTextBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@USystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2USystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1USystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UField@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UField@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UField@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UStruct@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UStruct@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UStruct@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UStruct@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UStruct@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetPropertiesSize@UStruct@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetNameCPP@UStruct@@UAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSuperStruct@UStruct@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUStruct@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFunction@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFunction@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFunction@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UFunction@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MergeBools@UFunction@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UFunction@@UAEPAVUStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFunction@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UState@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UState@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UState@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UState@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MergeBools@UState@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UState@@UAEPAVUStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSuperState@UState@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUState@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UEnum@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UEnum@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UEnum@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UEnum@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUEnum@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UClass@@SAPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UClass@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UClass@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MergeBools@UClass@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInheritanceSuper@UClass@@UAEPAVUStruct@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetNameCPP@UClass@@UAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSuperClass@UClass@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetDefaultActor@UClass@@QAEPAVAActor@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUClass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UConst@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UConst@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UConst@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UConst@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUConst@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Matches@UProperty@@QBEHPBX0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UByteProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UByteProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UByteProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UByteProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUByteProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UIntProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UIntProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UIntProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UIntProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUIntProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UBoolProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UBoolProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UBoolProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UBoolProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUBoolProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFloatProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFloatProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFloatProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UFloatProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFloatProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UObjectProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UObjectProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UObjectProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UObjectProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UObjectProperty@@QAE@W4ECppProperty@@HPBGKPAVUClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUObjectProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UClassProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UClassProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UClassProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UClassProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetID@UClassProperty@@UBEEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUClassProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UNameProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UNameProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UNameProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UNameProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUNameProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UStrProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UStrProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UStrProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UStrProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUStrProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFixedArrayProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFixedArrayProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFixedArrayProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UFixedArrayProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFixedArrayProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UArrayProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UArrayProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UArrayProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UArrayProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUArrayProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMapProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMapProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMapProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UMapProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMapProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UStructProperty@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UStructProperty@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UStructProperty@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UStructProperty@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUStructProperty@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsA@UObject@@QBIHPAVUClass@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsProbing@UObject@@QAEHVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FFrame@@QAE@PAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FStateFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFStateFrame@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FGenerationInfo@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFGenerationInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FPackageFileSummary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULinker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ULinker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULinker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULinker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULinker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FPackageFileSummary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@ULinkerLoad@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2ULinkerLoad@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ULinkerLoad@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ULinkerLoad@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULinkerLoad@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@ULinkerSave@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2ULinkerSave@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ULinkerSave@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ULinkerSave@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULinkerSave@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFactory@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFactory@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UExporter@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UExporter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GHash@FMemCache@@QAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PushBytes@FMemStack@@QAEPAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Tick@FMemStack@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSnap@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FSheerSnap@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FAddAngleConfined@@YIGHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FVector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FVector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??TFVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??UFVector@@QBEMABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVFVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??GFVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??8FVector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??9FVector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??GFVector@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??ZFVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFVector@@QAE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FVector@@QAE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FVector@@QAE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SizeSquared@FVector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Normalize@FVector@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?UnsafeNormal@FVector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BoundToCube@FVector@@QAE?AV1@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToStd@FVector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToUnr@FVector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FVectorDouble@@QAE@NNN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFVectorDouble@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BoundToCube@FVectorDouble@@QAE?AV1@N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FQuat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FQuat@@QAE@ABVFVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FQuat@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SizeSquared@FQuat@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Size@FQuat@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Normalize@FQuat@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??GFQuat@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFQuat@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??UFQuat@@QBEMABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??8FQuat@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPlane@@QAE@VFVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PlaneDot@FPlane@@QBEMABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFPlane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSphere@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FScale@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Orientation@FScale@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FCoords@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FCoords@@QAE@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FCoords@@QAE@ABVFVector@@000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FModelCoords@@QAE@ABVFCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FRotator@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FRotator@@QAE@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??HFRotator@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFRotator@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVFRotator@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FRange@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FBox@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FBox@@QAE@ABVFVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetExtrema@FBox@@QBEABVFVector@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Init@FBox@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFBox@@QAEAAV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??YFBox@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SinTab@FGlobalMath@@QAEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CosTab@FGlobalMath@@QAEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReduceAngle@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ASMTransformPoint@@YAXABVFCoords@@ABVFVector@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ASMTransformVector@@YAXABVFCoords@@ABVFVector@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?TransformPointBy@FVector@@QBE?AV1@ABVFCoords@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?TransformVectorBy@FVector@@QBE?AV1@ABVFCoords@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MirrorByVector@FVector@@QBE?AV1@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MirrorByPlane@FVector@@QBE?AV1@ABVFPlane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FPointPlaneDist@@YAMABVFVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FParallel@@YAHABVFVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Transpose@FCoords@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FCoords@@QAEAAV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFCoords@@QBE?AV0@ABVFRotator@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FCoords@@QAEAAV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFCoords@@QBE?AV0@ABVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??XFCoords@@QAEAAV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??DFCoords@@QBE?AV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_0FCoords@@QAEAAV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??KFCoords@@QBE?AV0@ABVFScale@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMatrix@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMatrix@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??6FCoords@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??SFCoords@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Splerp@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPointRegion@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCsg@FBspNode@@QBEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPolys@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPolys@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPolys@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UPolys@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Serialize@UPolys@@UAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPolys@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFPoly@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorActorList@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FIteratorActorList@@QAE@PAU0@PAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPrimitive@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPrimitive@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPrimitive@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UPrimitive@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPrimitive@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UModel@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UModel@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UModel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UModel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUModel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFBspNode@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFVector@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@VFBspSurf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FColor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FColor@@QAE@EEE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FColor@@QAE@ABVFPlane@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Plane@FColor@@QBE?AVFVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPalette@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPalette@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UPalette@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPalette@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUPalette@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMipmapBase@@QAE@EE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMipmapBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UBitmap@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAPAVUTexture@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?InternalConstructor@UTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?MousePosition@UTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Click@UTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFFontCharacter@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFont@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFont@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UFontTrueType@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UFontTrueType@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UFontTrueType@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFontTrueType@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@GH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UProceduralTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UProceduralTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetInstanceClass@UMesh@@UAEPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMeshInstance@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMeshInstance@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMeshInstance@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PointCheck@UMeshInstance@@UAEHAAUFCheckResult@@PAVAActor@@VFVector@@2K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?LineCheck@UMeshInstance@@UAEHAAUFCheckResult@@PAVAActor@@VFVector@@22KH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetRenderBoundingBox@UMeshInstance@@UAE?AVFBox@@PBVAActor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetCollisionBoundingBox@UMeshInstance@@UBE?AVFBox@@PBVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMesh@UMeshInstance@@UAEPAVUMesh@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetMesh@UMeshInstance@@UAEXPAVUMesh@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetActor@UMeshInstance@@UAEPAVAActor@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetActor@UMeshInstance@@UAEXPAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetNumSequences@UMeshInstance@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSequence@UMeshInstance@@UAEPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?FindSequence@UMeshInstance@@UAEPAXVFName@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqName@UMeshInstance@@UAE?AVFName@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetSeqGroupName@UMeshInstance@@UAEXVFName@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqGroupName@UMeshInstance@@UAE?AVFName@@V2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqNumFrames@UMeshInstance@@UAEHPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqRate@UMeshInstance@@UAEMPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqNumEvents@UMeshInstance@@UAEHPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqEventType@UMeshInstance@@UAE?AW4EMeshSeqEvent@@PAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqEventTime@UMeshInstance@@UAEMPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetSeqEventString@UMeshInstance@@UAEPBGPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PlaySequence@UMeshInstance@@UAEHPAXEHMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?DriveSequences@UMeshInstance@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetTexture@UMeshInstance@@UAEPAVUTexture@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetStringValue@UMeshInstance@@UAEXAAVFOutputDevice@@PBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SendStringCommand@UMeshInstance@@UAEXPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetBasisCoords@UMeshInstance@@UAE?AVFCoords@@V2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetFrame@UMeshInstance@@UAEHPAVFVector@@PAEHVFCoords@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMountCoords@UMeshInstance@@UAEHVFName@@HAAVFCoords@@PAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Draw@UMeshInstance@@UAEXPAX0VFCoords@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMeshInstance@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UMeshInstance@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMeshChannel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAPAVAActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AActor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ShouldDoScriptReplication@AActor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetLevel@AActor@@QBEPAVULevel@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?WorldLightRadius@AActor@@UBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostEditMove@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PreRaytrace@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostRaytrace@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Spawned@AActor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToLocal@AActor@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToWorld@AActor@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsPendingKill@AActor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetMeshInstance@AActor@@QAEPAVUMeshInstance@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventCalcView_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventGlobalTrigger_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventEnumSurfsInRadiusCB_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventBroadcastMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AActor_eventBroadcastMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventTakeDamage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventPushedByMover_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventLanded_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AActor_eventHitWall_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInfoActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInfoActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInfoActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInfoActor@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInfoActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInternetInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInternetInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInternetInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInternetInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInternetInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInternetLink@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInternetLink@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInternetLink@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInternetLink@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AUdpLink@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AUdpLink@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AUdpLink@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AUdpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AUdpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AUdpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AUdpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAUdpLink@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATcpLink@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATcpLink@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATcpLink@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ATcpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ATcpLink_eventReceivedLine_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ATcpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ATcpLink_eventReceivedText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATcpLink@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMapLocations@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMapLocations@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMapLocations@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMapLocations@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMapLocations@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FMapInfoData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMapInfoData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADOTAffector@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADOTAffector@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADOTAffector@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADOTAffector@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADOTAffector@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AActorDamageEffect@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AActorDamageEffect@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AActorDamageEffect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AActorDamageEffect@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAActorDamageEffect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMutator@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMutator@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMutator@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMutator@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMutator@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AReplicationInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AReplicationInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AReplicationInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AReplicationInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAReplicationInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AGameReplicationInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AGameReplicationInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AGameReplicationInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AGameReplicationInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAGameReplicationInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APlayerReplicationInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APlayerReplicationInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APlayerReplicationInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APlayerReplicationInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerReplicationInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASavedMove@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASavedMove@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASavedMove@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASavedMove@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASavedMove@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AZoneInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AZoneInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AZoneInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AZoneInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AWarpZoneInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AWarpZoneInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AWarpZoneInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AWarpZoneInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWarpZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASkyZoneInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASkyZoneInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASkyZoneInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASkyZoneInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASkyZoneInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALevelInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALevelInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALevelInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALevelInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ALevelInfo_eventServerTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ALevelInfo_eventServerTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALevelInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FObjectiveInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FObjectiveInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AGameInfo@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AGameInfo@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AGameInfo@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AGameInfo@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventLoginNewClass_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventLoginNewClass_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventPreLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventPreLogin_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventGetBeaconText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventGetBeaconText_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AGameInfo_eventInitGame_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1AGameInfo_eventInitGame_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAGameInfo@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMaterial@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMaterial@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMaterial@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMaterial@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMaterial@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FDamageCategoryEffectStruct@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AFocalPoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AFocalPoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AFocalPoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAFocalPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AFocalPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALight@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALight@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALight@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AFlareLight@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AFlareLight@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AFlareLight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AFlareLight@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAFlareLight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATriggerLight@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATriggerLight@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATriggerLight@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATriggerLight@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggerLight@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADamageType@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADamageType@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADamageType@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADamageType@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADamageType@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AKeypoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AKeypoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AKeypoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AKeypoint@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAKeypoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInterpolationStation@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInterpolationStation@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInterpolationStation@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInterpolationStation@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInterpolationStation@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@Alocationid@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2Alocationid@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1Alocationid@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0Alocationid@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAlocationid@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInterpolationPoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInterpolationPoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInterpolationPoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInterpolationPoint@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInterpolationPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APolyMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APolyMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APolyMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APolyMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPolyMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AClipMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AClipMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AClipMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AClipMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAClipMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMeshEffect@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMeshEffect@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMeshEffect@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMeshEffect@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0AMeshEffect_eventEvalVert_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMeshEffect@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASpawnNotify@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASpawnNotify@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASpawnNotify@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASpawnNotify@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASpawnNotify@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ANavigationPoint@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ANavigationPoint@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ANavigationPoint@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ANavigationPoint@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GANavigationPoint@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALiftExit@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALiftExit@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALiftExit@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALiftExit@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALiftExit@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ALiftCenter@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ALiftCenter@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ALiftCenter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ALiftCenter@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GALiftCenter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AWarpZoneMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AWarpZoneMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AWarpZoneMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AWarpZoneMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWarpZoneMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AButtonMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AButtonMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AButtonMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AButtonMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAButtonMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATriggerMarker@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATriggerMarker@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATriggerMarker@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATriggerMarker@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggerMarker@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInventorySpot@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInventorySpot@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInventorySpot@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInventorySpot@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInventorySpot@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APlayerStart@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APlayerStart@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APlayerStart@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APlayerStart@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerStart@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATeleporter@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATeleporter@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATeleporter@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATeleporter@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATeleporter@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APathNode@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APathNode@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APathNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APathNode@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPathNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AHUD@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AHUD@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AHUD@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AHUD@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAHUD@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATriggers@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATriggers@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATriggers@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATriggers@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATriggers@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ATrigger@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ATrigger@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ATrigger@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ATrigger@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GATrigger@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADukeNet@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADukeNet@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADukeNet@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADukeNet@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ADukeNet_eventdncServerCommand_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ADukeNet_eventdncServerCommand_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADukeNet@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ARenderActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ARenderActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ARenderActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GARenderActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ARenderActor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APawn@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APawn@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APawn@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APawn@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventClientHearSound_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventWalkTexture_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventTeamMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1APawn_eventTeamMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APawn_eventClientMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1APawn_eventClientMessage_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPawn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSFacialExpression@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FFacialNoiseInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSFacialExpressionFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@APlayerPawn@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2APlayerPawn@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1APlayerPawn@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APlayerPawn_eventPlayerCalcView_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0APlayerPawn_eventClientTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1APlayerPawn_eventClientTravel_Parms@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAPlayerPawn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0APlayerPawn@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ACamera@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ACamera@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ACamera@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ACamera@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GACamera@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AScout@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AScout@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AScout@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AScout@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAScout@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABrush@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABrush@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABrush@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ABrush@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?OldBuildCoords@ABrush@@UAEMPAVFModelCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToLocal@ABrush@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToWorld@ABrush@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BuildCoords@ABrush@@UAEMPAVFModelCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CopyPosRotScaleFrom@ABrush@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMover@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMover@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMover@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToLocal@AMover@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ToWorld@AMover@@UBE?AVFCoords@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?BuildCoords@AMover@@UAEMPAVFModelCoords@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMover@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADoorMover@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADoorMover@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADoorMover@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADoorMover@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADoorMover@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AMeshDecal@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AMeshDecal@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AMeshDecal@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AMeshDecal@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAMeshDecal@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AItem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AItem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AItem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AItem@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAItem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADecoration@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADecoration@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADecoration@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADecoration@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADecoration@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSThirdPersonInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ACarcass@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ACarcass@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ACarcass@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GACarcass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ACarcass@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABoneRope@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABoneRope@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABoneRope@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABoneRope@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AParticleCollisionActor@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AParticleCollisionActor@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AParticleCollisionActor@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AParticleCollisionActor@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAParticleCollisionActor@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ADecal@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ADecal@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ADecal@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ADecal@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GADecal@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AInventory@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AInventory@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AInventory@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AInventory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAInventory@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AWeapon@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AWeapon@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AWeapon@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AWeapon@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAWeapon@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FWAMEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FWAMEntry@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AProjectile@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AProjectile@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AProjectile@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AProjectile@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAProjectile@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@AParticleSystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2AParticleSystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1AParticleSystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0AParticleSystem@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAParticleSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASoftParticleAffector@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASoftParticleAffector@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASoftParticleAffector@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASoftParticleAffector@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASoftParticleAffector@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ASoftParticleSystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ASoftParticleSystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ASoftParticleSystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ASoftParticleSystem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GASoftParticleSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FAdditionalSpawnStruct@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABeamSystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABeamSystem@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABeamSystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ABeamSystem@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABeamSystem@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSControlPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ABreakableGlass@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ABreakableGlass@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ABreakableGlass@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GABreakableGlass@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULevelSummary@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ULevelSummary@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULevelSummary@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULevelSummary@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostLoad@ULevelSummary@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULevelSummary@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FCollisionHashBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFCollisionHashBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULevelBase@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULevelBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULevelBase@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FURL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TTransArray@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FNetworkNotify@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@ULevel@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2ULevel@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ULevel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ULevel@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetLevelInfo@ULevel@@QAEPAVALevelInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GULevel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??EFStaticBrushIterator@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UInput@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UInput@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UInput@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUInput@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FAlias@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UPlayer@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UPlayer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UEngine@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UEngine@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad1@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad2@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad3@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?edSetClickLocation@UEngine@@UAEXAAVFVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?edcamMode@UEngine@@UAEHPAVUViewport@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad4@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad5@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?vtPad6@UEngine@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UGameEngine@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UGameEngine@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UGameEngine@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUGameEngine@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UCanvas@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UCanvas@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UCanvas@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UCanvas@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUCanvas@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMap@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UViewport@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UViewport@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsA@HHitProxy@@UBEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Click@HHitProxy@@UAEXABUFHitCause@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UClient@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UClient@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFMeshAnimNotify@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FMeshAnimNotify@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshVertConnect@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FMeshVert@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshVert@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshUV@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAUFMeshTri@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UUnrealMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UUnrealMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UUnrealMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUUnrealMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UUnrealLodMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UUnrealLodMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UUnrealLodMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UUnrealLodMesh@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUUnrealLodMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UDukeMesh@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UDukeMesh@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UDukeMesh@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUDukeMesh@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMap@VFName@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsBrush@AActor@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?IsStaticBrush@AActor@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetPlayerPawn@AActor@@QBEPAVAPlayerPawn@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetPrimitive@AActor@@UBEPAVUPrimitive@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UAudioSubsystem@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UAudioSubsystem@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FSoundData@@QAE@PAVUSound@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@USound@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2USound@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1USound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0USound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FSoundData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UVoiceSound@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UVoiceSound@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UVoiceSound@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUVoiceSound@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UVoiceSound@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UMusic@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UMusic@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UMusic@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UMusic@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUMusic@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FMovingBrushTrackerBase@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMovingBrushTrackerBase@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@UScriptedTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2UScriptedTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1UScriptedTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PostEditChange@UScriptedTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUScriptedTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StaticClass@URenderIterator@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??2URenderIterator@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1URenderIterator@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GURenderIterator@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FActorNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFActorNode@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsA@HActorVertex@@UBEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0HHitProxy@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CycleCount@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UFractalTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UFractalTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostEditChange@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFractalTexture@@UAEXHHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFractalTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UFractalTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UProceduralTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4UProceduralTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4UTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UBitmap@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4UBitmap@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FSpark@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UFireTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UFireTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UFireTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UFireTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFireTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UFireTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FDrop@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UWaterTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UWaterTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaterTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UWaterTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UWaveTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UWaveTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UWaveTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaveTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UWaveTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UWetTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UWetTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UWetTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UWetTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWetTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UWetTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FTextureInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4KeyPoint@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StaticClass@UIceTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2UIceTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1UIceTexture@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UIceTexture@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UIceTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4UIceTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EULinkerLoad@@WKE@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_EULinkerSave@@WKE@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DllMain@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpeedRand@@YAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FakeAtan@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitTables@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloseSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteSparks@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FirePaint@UFireTexture@@AAEXHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RedrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostDrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalculateWater@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyWetTexture@UWetTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveIcePosition@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BlitTexIce@UIceTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BlitIceTex@UIceTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WaterRedrawDrops@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDrop@UWaterTexture@@AAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteDrops@UWaterTexture@@AAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TempDrawSpark@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BlueLagunaPalette@@YAXPAVUPalette@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFractalTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0UProceduralTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UFractalTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E184
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E185
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E187
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E188
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E190
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E191
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UFireTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UFireTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UFireTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UFireTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFireTexture@@UAEXHHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UFireTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MousePosition@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Click@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E193
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E194
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E196
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E197
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E199
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E200
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaterTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UWaterTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchTexture@UWaterTexture@@UAEXHHM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UWaterTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WaterPaint@UWaterTexture@@AAEXHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MousePosition@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Click@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E202
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E203
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E205
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E206
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E208
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E209
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWaveTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UWaveTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UWaveTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWaveLight@UWaveTexture@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E211
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E212
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E214
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E215
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E217
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E218
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UWetTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UWetTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UWetTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UWetTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWetTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetRefractionTable@UWetTexture@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@UWetTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E220
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E221
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E223
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E224
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E226
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E227
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0UIceTexture@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostLoad@UIceTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@UIceTexture@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@UIceTexture@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UIceTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Tick@UIceTexture@@UAIXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenderIce@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MousePosition@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Click@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@UIceTexture@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E229
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E230
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E232
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E233
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E235
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E236
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@G@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@G@@QAE@W4ENoInit@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@G@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@G@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@G@@QBEABGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shrink@?$TArray@G@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@G@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@G@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@E@@QAEAAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@E@@QBEABEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@E@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAUFNameEntry@@@@QAEAAPAUFNameEntry@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFString@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFString@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAVUObject@@@@QAEAAPAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFFieldNetCache@@@@QAEAAVFFieldNetCache@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindRef@?$TMapBase@PAVUObject@@PAVFFieldNetCache@@@@QAEPAVFFieldNetCache@@ABQAVUObject@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFPackageInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFPackageInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@PAVUObject@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFName@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFName@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFRepRecord@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUField@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFClassDependency@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFClassDependency@@@@QAEAAVFClassDependency@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TFieldIterator@VUProperty@@@@QAE@PAVUStruct@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$TFieldIterator@VUProperty@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$TFieldIterator@VUProperty@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$TFieldIterator@VUProperty@@@@QAEPAVUProperty@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFGenerationInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFGenerationInfo@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFGenerationInfo@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFGenerationInfo@@@@QAEAAUFGenerationInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFGenerationInfo@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@UFGenerationInfo@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFObjectImport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFObjectImport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFObjectExport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFObjectExport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVFLazyLoader@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVFLazyLoader@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFPoly@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TTransArray@VFPoly@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddZeroed@?$TTransArray@VFPoly@@@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TTransArray@VFPoly@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFPoly@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFPoly@@@@QAEAAVFPoly@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@VFPoly@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFBspNode@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFBspNode@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFVert@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFVector@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFVector@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@VFBspSurf@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFBspSurf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFBspSurf@@@@QAEAAVFBspSurf@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFLightMapIndex@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFLightMapIndex@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFLightMapIndex@@@@QAEAAVFLightMapIndex@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFBox@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFBox@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFLeaf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFLeaf@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@PAVAActor@@@@QAEAAPAVAActor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFColor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFColor@@@@QAEAAVFColor@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TLazyArray@E@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@E@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TLazyArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMipmap@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMipmap@@@@QAEAAUFMipmap@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFFontCharacter@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFFontPage@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@GH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@M@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@M@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshDecalTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshDecalTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVAParticleCollisionActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVAParticleCollisionActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TTransArray@PAVAActor@@@@QAE@PAVUObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFReachSpec@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFReachSpec@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFName@@PAVAActor@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TMapBase@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUViewport@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFMeshAnimNotify@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFMeshAnimNotify@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@VFMeshAnimNotify@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@UFMeshVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@UFMeshVert@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@UFMeshVert@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@UFMeshTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@UFMeshTri@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@UFMeshTri@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFMeshAnimSeq@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@UFMeshVertConnect@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@UFMeshVertConnect@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@UFMeshVertConnect@@@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TLazyArray@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Load@?$TLazyArray@H@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@H@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@PAVUTexture@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshFace@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshFace@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshWedge@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshWedge@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@UFMeshMaterial@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshMaterial@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TMapBase@VFName@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFSpark@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFSpark@@@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFSpark@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFSpark@@@@QAEAAVFSpark@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@VFSpark@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@VFSpark@@@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFSpark@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@VFSpark@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FMipmap@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4FMipmap@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TLazyArray@E@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TLazyArray@E@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FLazyLoader@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4FLazyLoader@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@G@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@E@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@E@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@E@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@E@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@E@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$TArray@E@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@H@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@H@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFString@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFFieldNetCache@@@@@@QAEAAVTPair@?$TMapBase@PAVUObject@@PAVFFieldNetCache@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFPackageInfo@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@PAVUObject@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFName@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFRepRecord@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUField@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFClassDependency@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IterateToNext@?$TFieldIterator@VUProperty@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFGenerationInfo@@@@QBEABUFGenerationInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFGenerationInfo@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFObjectImport@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFObjectExport@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVFLazyLoader@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TTransArray@VFPoly@@@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SerializeItem@?$TTransArray@VFPoly@@@@KAXAAVFArchive@@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestructItem@?$TTransArray@VFPoly@@@@KAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFPoly@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@VFPoly@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFPoly@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@VFPoly@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFBspNode@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFBspNode@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFVert@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFVert@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFVector@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFVector@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VFBspSurf@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFBspSurf@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFLightMapIndex@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFBox@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFLeaf@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@PAVAActor@@@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVAActor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFColor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMipmap@@@@QBEABUFMipmap@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFFontCharacter@@@@QAEAAUFFontCharacter@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFFontCharacter@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFFontCharacter@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFFontPage@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@GH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@M@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshDecalTri@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVAParticleCollisionActor@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFReachSpec@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@VFString@@V1@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@VFName@@PAVAActor@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Rehash@?$TMapBase@VFString@@PAVUFont@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUViewport@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFMeshAnimNotify@@@@QAEAAVFMeshAnimNotify@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@VFMeshAnimNotify@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFMeshAnimNotify@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@VFMeshAnimNotify@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshVert@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFMeshVert@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMeshVert@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshTri@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFMeshTri@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMeshTri@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFMeshAnimSeq@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFMeshVertConnect@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAV?$TArray@UFMeshVertConnect@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMeshVertConnect@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@PAVUTexture@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshFace@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshWedge@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshMaterial@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VTPair@?$TMapBase@VFName@@V1@@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFSpark@@@@QBEABVFSpark@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@VFSpark@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@VFSpark@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFGenerationInfo@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMipmap@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFSpark@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFString@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFPackageInfo@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0FPoly@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFBspSurf@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMipmap@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFFontPage@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFMeshAnimSeq@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FPackageInfo@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FBspSurf@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FMipmap@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1FFontPage@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FMeshAnimSeq@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFString@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@H@@QAEAAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@H@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFString@@@@QAEAAVFString@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFPackageInfo@@@@QAEAAVFPackageInfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAEAAVTPair@?$TMapBase@PAVUObject@@H@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@PAVUObject@@H@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAEAAVTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@VFDecal@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$TArray@VFPoly@@@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$TArray@UFFontCharacter@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFFontPage@@@@QAEAAUFFontPage@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@GH@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAEAAVTPair@?$TMapBase@VFString@@V1@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFString@@V1@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVAActor@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAEAAVTPair@?$TMapBase@VFName@@PAVAActor@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAEAAVTPair@?$TMapBase@VFString@@PAVUFont@@@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshVert@@@@QAEAAUFMeshVert@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFMeshVert@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshVert@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshTri@@@@QAEAAUFMeshTri@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFMeshTri@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshTri@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFMeshAnimSeq@@@@QAEAAVFMeshAnimSeq@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@UFMeshVertConnect@@@@QAEAAUFMeshVertConnect@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountBytes@?$TArray@UFMeshVertConnect@@@@QAEXAAVFArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFMeshVertConnect@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VTPair@?$TMapBase@VFName@@V1@@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFPackageInfo@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFRepRecord@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVUField@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFClassDependency@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFObjectImport@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFObjectExport@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVFLazyLoader@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFPoly@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFBspNode@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFVert@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFVector@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFBspSurf@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFLightMapIndex@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFBox@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFLeaf@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFColor@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFFontCharacter@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFFontPage@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@M@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshDecalTri@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVAParticleCollisionActor@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFReachSpec@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVUViewport@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFMeshAnimNotify@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshVert@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshTri@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFMeshAnimSeq@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshVertConnect@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@PAVUTexture@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshFace@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshWedge@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@UFMeshMaterial@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTPair@?$TMapBase@VFString@@V1@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GTPair@?$TMapBase@VFString@@PAVUFont@@@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TPair@?$TMapBase@VFString@@V1@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TPair@?$TMapBase@VFString@@PAVUFont@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@VFDecal@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@UFFontCharacter@@@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@PAVUObject@@H@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@PAVUObject@@PAVFClassNetCache@@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@GH@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFString@@V1@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFName@@PAVAActor@@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFString@@PAVUFont@@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VTPair@?$TMapBase@VFName@@V1@@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GFDecal@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1FDecal@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$TArray@VFDecal@@@@QAEAAVFDecal@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NeedsDestructor@?$TTypeInfoBase@VFDecal@@@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAKKKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFClassDependency@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFGenerationInfo@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Align@@YAPAEQAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YAMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clamp@@YANNNN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Sgn@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Max@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Min@@YAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Square@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Square@@YANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Abs@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Min@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindObjectChecked@@YAPAVUClass@@PAVUObject@@PBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFColor@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@E@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFFontCharacter@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFMeshAnimNotify@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFSpark@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@H@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@VFPoly@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMeshVert@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMeshTri@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMeshVertConnect@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_SULevel@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInternetLink@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUCanvas@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerLoad@@6BULinker@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInventory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerSave@@6BULinker@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPolyMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAlocationid@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SARenderActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0PAX@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_SAInfoActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@E@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUObjectProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUState@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Half@?1??appFloor@@YAHM@Z@4MA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SASpawnNotify@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMeshInstance@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAActorDamageEffect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FMovingBrushTrackerBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATcpLink@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPawn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUUnrealLodMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMutator@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMapLocations@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UFireTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUSystem@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAClipMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPrimitive@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerPawn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerStart@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UWaveTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWeapon@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABreakableGlass@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPathNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMover@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABoneRope@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0PAG@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SAActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SULevelSummary@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FStringOutputDevice@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUEnum@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerSave@@6BFArchive@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0PAG@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_SACarcass@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAUdpLink@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASavedMove@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUStrProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADecal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SANavigationPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPackageMap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUStructProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFunction@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAButtonMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FBufferArchive@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAGameInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggers@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@UFMeshTri@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAPlayerReplicationInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFontTrueType@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASoftParticleAffector@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUClassProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SABeamSystem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUInput@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@H@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUDukeMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAParticleSystem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATeleporter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMeshEffect@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAFocalPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAScout@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInterpolationStation@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@UFMeshVert@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASkyZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFloatProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUConst@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUGameEngine@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7HActorVertex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUNameProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAParticleCollisionActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAKeypoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPackage@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAItem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPalette@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FLazyLoader@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UFractalTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMusic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAHUD@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUCommandlet@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWarpZoneMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggerMarker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FBufferWriter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUBoolProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADecoration@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInterpolationPoint@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADamageType@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMaterial@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUPolys@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUUnrealMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FConfigCache@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAReplicationInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUFixedArrayProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UIceTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UWaterTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADOTAffector@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADoorMover@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAFlareLight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ULinkerLoad@@6BFArchive@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATrigger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUArrayProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUVoiceSound@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAGameReplicationInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAMeshDecal@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SATriggerLight@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7FCollisionHashBase@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7UWetTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$TLazyArray@UFMeshVertConnect@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUIntProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUStruct@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SULinker@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SADukeNet@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SASoftParticleSystem@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAWarpZoneInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInventorySpot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUModel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUByteProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALiftCenter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA2PAG
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SUScriptedTexture@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SURenderIterator@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUMapProperty@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALevelInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2PAG
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_SUTextBuffer@@6BUObject@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SACamera@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SALiftExit@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAProjectile@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SUClass@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_SAInternetInfo@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ, xdata$x
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_autoclassUFireTexture
PUBLIC	?PrivateStaticClass@UFireTexture@@0VUClass@@A	; UFireTexture::PrivateStaticClass
PUBLIC	_hInstance
PUBLIC	_autoclassUWaterTexture
PUBLIC	_autoclassUWaveTexture
PUBLIC	?PrivateStaticClass@UWaterTexture@@0VUClass@@A	; UWaterTexture::PrivateStaticClass
PUBLIC	_autoclassUWetTexture
PUBLIC	?PrivateStaticClass@UWaveTexture@@0VUClass@@A	; UWaveTexture::PrivateStaticClass
PUBLIC	?PrivateStaticClass@UWetTexture@@0VUClass@@A	; UWetTexture::PrivateStaticClass
PUBLIC	_autoclassUIceTexture
PUBLIC	?PrivateStaticClass@UIceTexture@@0VUClass@@A	; UIceTexture::PrivateStaticClass
PUBLIC	_SpeedRindex
PUBLIC	_StaleRindex
PUBLIC	_SpeedRandArr
PUBLIC	_PhaseTable
PUBLIC	_SignedPhaseTable
PUBLIC	_LightPhaseTable
PUBLIC	_autoclassUFractalTexture
PUBLIC	_LTimeTotal1
PUBLIC	_LTimeTotal2
PUBLIC	_LinePixels
PUBLIC	?TotalTime0@@3_JA				; TotalTime0
PUBLIC	?TotalTime1@@3_JA				; TotalTime1
PUBLIC	?TotalTime2@@3_JA				; TotalTime2
PUBLIC	?TotalTime3@@3_JA				; TotalTime3
PUBLIC	?TotalTime4@@3_JA				; TotalTime4
PUBLIC	?TotalPixels@@3_JA				; TotalPixels
PUBLIC	?TotalFrames@@3HA				; TotalFrames
PUBLIC	?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
PUBLIC	_GPackage
_BSS	SEGMENT
?LastMouseX@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UFireTexture::FirePaint'::`2'::LastMouseX
?LastMouseY@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UFireTexture::FirePaint'::`2'::LastMouseY
?LastLeftButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UFireTexture::FirePaint'::`2'::LastLeftButton
?LastRightButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UFireTexture::FirePaint'::`2'::LastRightButton
_autoclassUFireTexture DD 01H DUP (?)
?PrivateStaticClass@UFireTexture@@0VUClass@@A DB 0528H DUP (?) ; UFireTexture::PrivateStaticClass
_hInstance DD	01H DUP (?)
?LastMouseX@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UWaterTexture::WaterPaint'::`2'::LastMouseX
?LastMouseY@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UWaterTexture::WaterPaint'::`2'::LastMouseY
?LastLeftButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UWaterTexture::WaterPaint'::`2'::LastLeftButton
?LastRightButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA DD 01H DUP (?) ; `UWaterTexture::WaterPaint'::`2'::LastRightButton
_autoclassUWaterTexture DD 01H DUP (?)
_autoclassUWaveTexture DD 01H DUP (?)
?PrivateStaticClass@UWaterTexture@@0VUClass@@A DB 0528H DUP (?) ; UWaterTexture::PrivateStaticClass
_autoclassUWetTexture DD 01H DUP (?)
?PrivateStaticClass@UWaveTexture@@0VUClass@@A DB 0528H DUP (?) ; UWaveTexture::PrivateStaticClass
?PrivateStaticClass@UWetTexture@@0VUClass@@A DB 0528H DUP (?) ; UWetTexture::PrivateStaticClass
?MouseLastU@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA DD 01H DUP (?) ; `UIceTexture::MousePosition'::`2'::MouseLastU
?MouseLastV@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA DD 01H DUP (?) ; `UIceTexture::MousePosition'::`2'::MouseLastV
_autoclassUIceTexture DD 01H DUP (?)
?PrivateStaticClass@UIceTexture@@0VUClass@@A DB 0528H DUP (?) ; UIceTexture::PrivateStaticClass
_SpeedRindex DD	01H DUP (?)
_StaleRindex DD	01H DUP (?)
_SpeedRandArr DB 0200H DUP (?)
_PhaseTable DB	0100H DUP (?)
_SignedPhaseTable DB 0100H DUP (?)
_LightPhaseTable DB 0100H DUP (?)
?Initialized@?1??InitTables@@YAXXZ@4HA DD 01H DUP (?)	; `InitTables'::`2'::Initialized
_autoclassUFractalTexture DD 01H DUP (?)
?LightPinX@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA DD 01H DUP (?) ; `UFireTexture::AddSpark'::`2'::LightPinX
	ALIGN	8

_LTimeTotal1 DQ	01H DUP (?)
?LightPinY@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA DD 01H DUP (?) ; `UFireTexture::AddSpark'::`2'::LightPinY
	ALIGN	8

_LTimeTotal2 DQ	01H DUP (?)
_LinePixels DQ	01H DUP (?)
?TotalTime0@@3_JA DQ 01H DUP (?)			; TotalTime0
?TotalTime1@@3_JA DQ 01H DUP (?)			; TotalTime1
?TotalTime2@@3_JA DQ 01H DUP (?)			; TotalTime2
?TotalTime3@@3_JA DQ 01H DUP (?)			; TotalTime3
?TotalTime4@@3_JA DQ 01H DUP (?)			; TotalTime4
?TotalPixels@@3_JA DQ 01H DUP (?)			; TotalPixels
?TotalFrames@@3HA DD 01H DUP (?)			; TotalFrames
?PrivateStaticClass@UFractalTexture@@0VUClass@@A DB 0528H DUP (?) ; UFractalTexture::PrivateStaticClass
_BSS	ENDS
_DATA	SEGMENT
_GPackage DB	'F', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 00H, 00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S189	DD	FLAT:_$E188
_$S192	DD	FLAT:_$E191
_$S198	DD	FLAT:_$E197
_$S201	DD	FLAT:_$E200
_$S207	DD	FLAT:_$E206
_$S210	DD	FLAT:_$E209
_$S216	DD	FLAT:_$E215
_$S219	DD	FLAT:_$E218
_$S225	DD	FLAT:_$E224
_$S228	DD	FLAT:_$E227
_$S234	DD	FLAT:_$E233
_$S237	DD	FLAT:_$E236
CRT$XCU	ENDS
PUBLIC	_DllMain@12
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_hInInstance$ = 8
_DllMain@12 PROC NEAR					; COMDAT

; 89   : IMPLEMENT_PACKAGE(Fire);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hInInstance$[esp-4]
  00004	a3 00 00 00 00	 mov	 DWORD PTR _hInstance, eax
  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	c2 0c 00	 ret	 12			; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
PUBLIC	?FakeAtan@@YANN@Z				; FakeAtan
PUBLIC	__real@00000000
PUBLIC	__real@3ff921cac0000000
PUBLIC	__real@3ff0000000000000
EXTRN	__fltused:NEAR
;	COMDAT __real@00000000
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@3ff921cac0000000
CONST	SEGMENT
__real@3ff921cac0000000 DQ 03ff921cac0000000r	; 1.57075
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?FakeAtan@@YANN@Z
_TEXT	SEGMENT
_X$ = 8
?FakeAtan@@YANN@Z PROC NEAR				; FakeAtan, COMDAT

; 132  :     return 3.1415F * 0.5F * X / (Abs((FLOAT)X) + 1.0);

  00000	dd 44 24 04	 fld	 QWORD PTR _X$[esp-4]
  00004	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  0000a	df e0		 fnstsw	 ax
  0000c	f6 c4 01	 test	 ah, 1
  0000f	74 02		 je	 SHORT $L116679
  00011	d9 e0		 fchs
$L116679:
  00013	dd 44 24 04	 fld	 QWORD PTR _X$[esp-4]
  00017	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ff921cac0000000
  0001d	d9 c9		 fxch	 ST(1)
  0001f	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00025	de f9		 fdivp	 ST(1), ST(0)

; 133  : }

  00027	c3		 ret	 0
?FakeAtan@@YANN@Z ENDP					; FakeAtan
_TEXT	ENDS
PUBLIC	?InitTables@@YAXXZ				; InitTables
PUBLIC	__real@3b800000
PUBLIC	__real@40c90fdb
PUBLIC	__real@405fe00000000000
PUBLIC	__real@405fdcccc0000000
EXTRN	__imp__rand:NEAR
;	COMDAT __real@3b800000
; File ..\..\Core\Inc\UnFile.h
CONST	SEGMENT
__real@3b800000 DD 03b800000r			; 0.00390625
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@405fe00000000000
CONST	SEGMENT
__real@405fe00000000000 DQ 0405fe00000000000r	; 127.5
CONST	ENDS
;	COMDAT __real@405fdcccc0000000
CONST	SEGMENT
__real@405fdcccc0000000 DQ 0405fdcccc0000000r	; 127.45
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?InitTables@@YAXXZ
_TEXT	SEGMENT
_t$108539 = -8
_I$116696 = -4
$T116698 = -8
?InitTables@@YAXXZ PROC NEAR				; InitTables, COMDAT

; 144  : 	static INT  Initialized=0;
; 145  : 	if( !Initialized )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Initialized@?1??InitTables@@YAXXZ@4HA
  00005	83 ec 08	 sub	 esp, 8
  00008	85 c0		 test	 eax, eax
  0000a	0f 85 c1 00 00
	00		 jne	 $L108538

; 146  : 	{
; 147  : 		// Init 8-bit sine table.
; 148  : 		for( INT t=0; t<256; t++ )

  00010	33 c0		 xor	 eax, eax
  00012	89 44 24 00	 mov	 DWORD PTR _t$108539[esp+8], eax
$L108540:

; 149  : 		{
; 150  : 			PhaseTable[t] = appRound(127.45F + 127.5F*appSin( ((FLOAT)t/256.0F) * 6.2831853F ));

  00016	db 44 24 00	 fild	 DWORD PTR _t$108539[esp+8]
  0001a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b800000
  00020	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@40c90fdb
  00026	d9 fe		 fsin
  00028	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@405fe00000000000
  0002e	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@405fdcccc0000000
  00034	d9 5c 24 00	 fstp	 DWORD PTR $T116698[esp+8]
  00038	d9 44 24 00	 fld	 DWORD PTR $T116698[esp+8]
  0003c	db 5c 24 04	 fistp	 DWORD PTR _I$116696[esp+8]
  00040	8a 4c 24 04	 mov	 cl, BYTE PTR _I$116696[esp+8]
  00044	88 88 00 00 00
	00		 mov	 BYTE PTR _PhaseTable[eax], cl
  0004a	40		 inc	 eax
  0004b	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00050	89 44 24 00	 mov	 DWORD PTR _t$108539[esp+8], eax
  00054	7c c0		 jl	 SHORT $L108540
  00056	56		 push	 esi

; 151  : 		}
; 152  : 
; 153  : 		for( t=0; t<256; t++ )

  00057	33 c0		 xor	 eax, eax
  00059	57		 push	 edi

; 174  : 	}
; 175  : }

  0005a	8d 9b 00 00 00
	00		 npad	 6

; 151  : 		}
; 152  : 
; 153  : 		for( t=0; t<256; t++ )

$L108544:

; 154  : 		{
; 155  : 		 	  LightPhaseTable[t] = Clamp (PhaseTable[t] + LIGHTPHASEBIAS, 0, 255);

  00060	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR _PhaseTable[eax]
  00066	0f b6 f1	 movzx	 esi, cl
  00069	83 c6 20	 add	 esi, 32			; 00000020H
  0006c	79 04		 jns	 SHORT $L116709
  0006e	33 d2		 xor	 edx, edx
  00070	eb 0f		 jmp	 SHORT $L116708
$L116709:
  00072	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00078	8b d6		 mov	 edx, esi
  0007a	7c 05		 jl	 SHORT $L116708
  0007c	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
$L116708:

; 156  : 			 SignedPhaseTable[t] = (BYTE)( -128 + (SBYTE)PhaseTable[t] );

  00081	80 c1 80	 add	 cl, 128			; 00000080H
  00084	88 90 00 00 00
	00		 mov	 BYTE PTR _LightPhaseTable[eax], dl
  0008a	88 88 00 00 00
	00		 mov	 BYTE PTR _SignedPhaseTable[eax], cl
  00090	40		 inc	 eax
  00091	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00096	7c c8		 jl	 SHORT $L108544

; 157  : 		}
; 158  : 
; 159  : 		for( t=0 ; t<512 ; t++ )

  00098	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  0009e	33 f6		 xor	 esi, esi
$L108554:

; 160  : 			SpeedRandArr[t] = (BYTE)(appRand() & 255);

  000a0	ff d7		 call	 edi
  000a2	88 86 00 00 00
	00		 mov	 BYTE PTR _SpeedRandArr[esi], al
  000a8	46		 inc	 esi
  000a9	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  000af	7c ef		 jl	 SHORT $L108554
  000b1	5f		 pop	 edi

; 161  : 
; 162  : 		// Speedy random number generator: initialize & align the index.
; 163  : 
; 164  : #if     RANDASM
; 165  : 		//SpeedRindex = ((DWORD)(&SpeedRandArr) +0xFF ) & 0xFFFFFF00;
; 166  : 		SpeedRindex=0;

  000b2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _SpeedRindex, 0

; 167  : #else
; 168  : 		SpeedRindex=0;
; 169  : #endif
; 170  : 		StaleRindex=0;

  000bc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _StaleRindex, 0

; 171  : 
; 172  : 		// Now initialized;
; 173  : 		Initialized=1;

  000c6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?Initialized@?1??InitTables@@YAXXZ@4HA, 1
  000d0	5e		 pop	 esi
$L108538:

; 174  : 	}
; 175  : }

  000d1	83 c4 08	 add	 esp, 8
  000d4	c3		 ret	 0
?InitTables@@YAXXZ ENDP					; InitTables
_TEXT	ENDS
PUBLIC	?AddSpark@UFireTexture@@AAEXHH@Z		; UFireTexture::AddSpark
; Function compile flags: /Ogty
;	COMDAT ?AddSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT
_MouseX$ = 8
_MouseY$ = 12
_TempSpeed$108624 = 8
_t$108632 = -8
_t$108638 = -8
?AddSpark@UFireTexture@@AAEXHH@Z PROC NEAR		; UFireTexture::AddSpark, COMDAT
; _this$ = ecx

; 464  : 	// Edit-time only.
; 465  : 	static INT  LightPinX=0;
; 466  : 	static INT  LightPinY=0;
; 467  : 
; 468  : 	// Return if out of bounds or out of sparks.
; 469  :     if( MouseX<0 || MouseY<0 || MouseX>=USize || MouseY>=VSize || ActiveSparkNum>=SparksLimit )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _MouseX$[esp-4]
  00004	83 ec 08	 sub	 esp, 8
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	33 d2		 xor	 edx, edx
  0000c	3b c2		 cmp	 eax, edx
  0000e	57		 push	 edi
  0000f	8b f1		 mov	 esi, ecx
  00011	0f 8c df 07 00
	00		 jl	 $L108670
  00017	8b 5c 24 20	 mov	 ebx, DWORD PTR _MouseY$[esp+20]
  0001b	3b da		 cmp	 ebx, edx
  0001d	0f 8c d3 07 00
	00		 jl	 $L108670
  00023	3b 46 34	 cmp	 eax, DWORD PTR [esi+52]
  00026	0f 8d ca 07 00
	00		 jge	 $L108670
  0002c	3b 5e 38	 cmp	 ebx, DWORD PTR [esi+56]
  0002f	0f 8d c1 07 00
	00		 jge	 $L108670
  00035	8b be f8 00 00
	00		 mov	 edi, DWORD PTR [esi+248]
  0003b	3b be f4 00 00
	00		 cmp	 edi, DWORD PTR [esi+244]
  00041	0f 8d af 07 00
	00		 jge	 $L108670

; 470  :         return;
; 471  : 
; 472  :     // Dynamic spark arrays: ActiveSparkNum/SparksLimit  have the current sparks and the current maximum
; 473  : 	// size; with these, the dynamic array is used as a *static* array in all spark adders/setters.
; 474  : 	
; 475  : 	// Make new spark.
; 476  :     INT  S = ActiveSparkNum++;  // ->Sparks[0] is the first one.

  00047	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0004a	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 477  : 
; 478  : 	// General new spark initialization.
; 479  :     Sparks(S).Type = SparkType;

  00050	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00056	89 54 24 1c	 mov	 DWORD PTR 8+[esp+20], edx
  0005a	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  00060	88 14 f9	 mov	 BYTE PTR [ecx+edi*8], dl

; 480  :     Sparks(S).X    = MouseX;

  00063	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00069	88 44 f9 02	 mov	 BYTE PTR [ecx+edi*8+2], al

; 481  :     Sparks(S).Y    = MouseY;

  0006d	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00073	88 5c f9 03	 mov	 BYTE PTR [ecx+edi*8+3], bl

; 482  : 	Sparks(S).Heat = FX_Heat; 

  00077	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0007d	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  00083	88 54 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], dl

; 483  : 
; 484  :     // Spark-type specific assignments.
; 485  :     switch( SparkType )
; 486  :     {

  00087	8a 8e e0 00 00
	00		 mov	 cl, BYTE PTR [esi+224]
  0008d	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  00091	0f b6 e9	 movzx	 ebp, cl
  00094	4d		 dec	 ebp
  00095	83 fd 1b	 cmp	 ebp, 27			; 0000001bH
  00098	0f 87 58 07 00
	00		 ja	 $L108670
  0009e	ff 24 ad 00 00
	00 00		 jmp	 DWORD PTR $L117054[ebp*4]
$L108610:

; 487  : 		case SPARK_Sparkle:
; 488  : 			Sparks(S).ByteA  = FX_Size;

  000a5	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  000ab	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  000b1	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 489  : 			Sparks(S).ByteB  = FX_AuxSize;

  000b5	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  000bb	8a 96 ea 00 00
	00		 mov	 dl, BYTE PTR [esi+234]
  000c1	88 54 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], dl
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5d		 pop	 ebp
  000c8	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  000c9	83 c4 08	 add	 esp, 8
  000cc	c2 08 00	 ret	 8
$L108611:

; 490  : 			break;
; 491  : 
; 492  :         case SPARK_Pulse:
; 493  :             Sparks(S).Heat  = DrawPhase + AuxPhase;  

  000cf	8a 8e dc 00 00
	00		 mov	 cl, BYTE PTR [esi+220]
  000d5	8a 86 dd 00 00
	00		 mov	 al, BYTE PTR [esi+221]
  000db	02 c1		 add	 al, cl
  000dd	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  000e3	88 44 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], al

; 494  : 			DrawPhase      += FX_Phase;         //

  000e7	8a 86 dc 00 00
	00		 mov	 al, BYTE PTR [esi+220]
  000ed	8a 96 ed 00 00
	00		 mov	 dl, BYTE PTR [esi+237]
  000f3	02 c2		 add	 al, dl
  000f5	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al

; 495  : 			Sparks(S).ByteD = FX_Frequency;     // Improve useful range.
; 496  :             break;

  000fb	e9 8e 05 00 00	 jmp	 $L117053
$L108612:

; 497  : 
; 498  :         case SPARK_Signal:
; 499  :             Sparks(S).Heat  = SpeedRand();      //

  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0010c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00112	83 c2 04	 add	 edx, 4
  00115	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0011b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00121	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00127	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0012d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00133	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00139	88 44 fa 01	 mov	 BYTE PTR [edx+edi*8+1], al

; 500  : 			Sparks(S).ByteD = FX_Frequency;     // Improve useful range.

  0013d	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00143	8a 8e ec 00 00
	00		 mov	 cl, BYTE PTR [esi+236]
  00149	88 4c f8 07	 mov	 BYTE PTR [eax+edi*8+7], cl

; 501  : 			Sparks(S).ByteC = (255 - FX_Heat);  //

  0014d	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  00153	80 ca ff	 or	 dl, 255			; 000000ffH
  00156	2a d0		 sub	 dl, al
  00158	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0015e	88 54 f8 06	 mov	 BYTE PTR [eax+edi*8+6], dl
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5d		 pop	 ebp
  00165	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00166	83 c4 08	 add	 esp, 8
  00169	c2 08 00	 ret	 8
$L108613:

; 502  :             break;                           
; 503  : 
; 504  :         case SPARK_Stars:    // Stars, FieldA for this type holds (negative) start Intensity.
; 505  :             Sparks(S).ByteA = FX_Heat;

  0016c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00172	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  00178	88 54 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], dl
  0017c	5f		 pop	 edi

; 506  : 			StarStatus = 1;  // At least one star..

  0017d	c6 86 10 05 00
	00 01		 mov	 BYTE PTR [esi+1296], 1
  00184	5e		 pop	 esi
  00185	5d		 pop	 ebp
  00186	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00187	83 c4 08	 add	 esp, 8
  0018a	c2 08 00	 ret	 8
$L108614:

; 507  :             break;
; 508  : 
; 509  : 		case SPARK_Organic:  // Organic blaze-up.
; 510  : 			Sparks(S).ByteC = FX_Area; 

  0018d	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00193	8a 8e eb 00 00
	00		 mov	 cl, BYTE PTR [esi+235]
  00199	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl
  0019d	5f		 pop	 edi
  0019e	5e		 pop	 esi
  0019f	5d		 pop	 ebp
  001a0	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  001a1	83 c4 08	 add	 esp, 8
  001a4	c2 08 00	 ret	 8
$L108616:

; 511  : 			break;             
; 512  : 
; 513  : 		case SPARK_Eels: 
; 514  : 			Sparks(S).ByteC = FX_Size;
; 515  : 			break;
; 516  : 
; 517  : 		case SPARK_BlazeLeft:
; 518  : 		case SPARK_BlazeRight:
; 519  : 			Sparks(S).ByteC = FX_Size;

  001a7	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  001ad	8a 96 e9 00 00
	00		 mov	 dl, BYTE PTR [esi+233]
  001b3	88 54 f9 06	 mov	 BYTE PTR [ecx+edi*8+6], dl
  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	5d		 pop	 ebp
  001ba	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  001bb	83 c4 08	 add	 esp, 8
  001be	c2 08 00	 ret	 8
$L108620:

; 520  : 			break;
; 521  : 
; 522  : 		case SPARK_OzHasSpoken: 
; 523  : 			break;  
; 524  : 
; 525  : 		case SPARK_Emit: // Spawn at angle , lifetime , linear movers.
; 526  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;
; 527  : 			Sparks(S).ByteB  = 127 ^ FX_VertSpeed;
; 528  : 			Sparks(S).ByteD  = 255/( (INT)FX_Size +1);
; 529  : 			break;
; 530  : 
; 531  : 		case SPARK_Fountain: // As Emit, with gravity.
; 532  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;

  001c1	8a 86 ee 00 00
	00		 mov	 al, BYTE PTR [esi+238]
  001c7	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  001cd	04 80		 add	 al, 128			; 00000080H
  001cf	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 533  : 			Sparks(S).ByteB  = 127 ^ FX_VertSpeed;

  001d3	8a 96 ef 00 00
	00		 mov	 dl, BYTE PTR [esi+239]
  001d9	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  001df	80 f2 7f	 xor	 dl, 127			; 0000007fH
  001e2	88 54 f8 05	 mov	 BYTE PTR [eax+edi*8+5], dl

; 534  : 			Sparks(S).ByteD  = 255/( (INT)FX_Size + 1);

  001e6	0f b6 8e e9 00
	00 00		 movzx	 ecx, BYTE PTR [esi+233]
  001ed	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  001f2	99		 cdq
  001f3	41		 inc	 ecx
  001f4	f7 f9		 idiv	 ecx
  001f6	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  001fc	88 44 fa 07	 mov	 BYTE PTR [edx+edi*8+7], al
  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5d		 pop	 ebp
  00203	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00204	83 c4 08	 add	 esp, 8
  00207	c2 08 00	 ret	 8
$L108622:

; 535  : 			break;
; 536  : 	
; 537  : 		case SPARK_Cylinder: // Twister (X=sin()) movement.
; 538  : 		case SPARK_Cylinder3D: // Twister (X=sin()) movement.
; 539  : 			{
; 540  : 				INT TempSize = FX_Size;
; 541  : 				INT TempSpeed = FX_HorizSpeed - 128;

  0020a	0f b6 ae ee 00
	00 00		 movzx	 ebp, BYTE PTR [esi+238]

; 542  : 				INT ThisIdx = S;
; 543  : 				INT Axis2 = PenDownX*2 + FX_Size;

  00211	8a 8e 11 05 00
	00		 mov	 cl, BYTE PTR [esi+1297]
  00217	0f b6 96 e9 00
	00 00		 movzx	 edx, BYTE PTR [esi+233]
  0021e	81 ed 80 00 00
	00		 sub	 ebp, 128		; 00000080H

; 544  : 
; 545  : 				// Scale to imaginary axis while mousebutton remains down.
; 546  : 				if( (DrawMode > DRAW_Normal) && (PenDownX != 0) )

  00224	80 be f0 00 00
	00 00		 cmp	 BYTE PTR [esi+240], 0
  0022b	89 6c 24 1c	 mov	 DWORD PTR _TempSpeed$108624[esp+20], ebp
  0022f	0f b6 e9	 movzx	 ebp, cl
  00232	8d 2c 6a	 lea	 ebp, DWORD PTR [edx+ebp*2]
  00235	76 2c		 jbe	 SHORT $L108628
  00237	84 c9		 test	 cl, cl
  00239	74 28		 je	 SHORT $L108628

; 547  : 				{
; 548  : 					TempSize = Axis2 - MouseX*2;

  0023b	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  0023e	8b d5		 mov	 edx, ebp
  00240	2b d1		 sub	 edx, ecx

; 549  : 
; 550  : 					// Axis = at PenDownX + 0.5 * FX_Size.
; 551  : 
; 552  : 					if( TempSize<0 )  // Crossed the axis.

  00242	79 1f		 jns	 SHORT $L108628

; 553  : 					{	
; 554  : 						TempSize = MouseX*2 - Axis2;

  00244	2b cd		 sub	 ecx, ebp
  00246	8b d1		 mov	 edx, ecx

; 555  : 						Sparks(S).X = MouseX - TempSize;  // Minus total diameter.

  00248	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0024e	2a c2		 sub	 al, dl
  00250	88 44 f9 02	 mov	 BYTE PTR [ecx+edi*8+2], al

; 556  : 						TempSpeed = (256-TempSpeed) & 255; 

  00254	8b 44 24 1c	 mov	 eax, DWORD PTR _TempSpeed$108624[esp+20]
  00258	f7 d8		 neg	 eax
  0025a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0025f	89 44 24 1c	 mov	 DWORD PTR _TempSpeed$108624[esp+20], eax
$L108628:

; 557  : 					}
; 558  : 				};
; 559  : 				
; 560  : 				Sparks(S).ByteA  = ( GlobalPhase * FX_Frequency + FX_Phase ) & 255;

  00263	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]
  00269	f6 ae d8 00 00
	00		 imul	 BYTE PTR [esi+216]
  0026f	02 86 ed 00 00
	00		 add	 al, BYTE PTR [esi+237]
  00275	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0027b	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 561  : 				Sparks(S).ByteB  = TempSize;  // Size.

  0027f	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00285	88 54 f8 05	 mov	 BYTE PTR [eax+edi*8+5], dl

; 562  : 				Sparks(S).ByteD  = TempSpeed;

  00289	8a 44 24 1c	 mov	 al, BYTE PTR _TempSpeed$108624[esp+20]
  0028d	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00293	88 44 f9 07	 mov	 BYTE PTR [ecx+edi*8+7], al

; 563  : 				
; 564  : 				// Draw second spark at +0.5 phase
; 565  : 				if( (DrawMode == DRAW_Lathe_2) && (ActiveSparkNum < SparksLimit) ) 

  00297	80 be f0 00 00
	00 02		 cmp	 BYTE PTR [esi+240], 2
  0029e	0f 85 87 00 00
	00		 jne	 $L108629
  002a4	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  002aa	3b 86 f4 00 00
	00		 cmp	 eax, DWORD PTR [esi+244]
  002b0	7d 79		 jge	 SHORT $L108629

; 566  : 				{
; 567  : 					INT  S = ActiveSparkNum++; 
; 568  : 					Sparks(S).Type = SparkType;

  002b2	89 54 24 10	 mov	 DWORD PTR -8+[esp+24], edx
  002b6	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  002bc	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  002bf	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  002c5	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  002cb	88 14 c1	 mov	 BYTE PTR [ecx+eax*8], dl

; 569  : 					Sparks(S).X    = Sparks(ThisIdx).X;

  002ce	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  002d4	8a 4c fd 02	 mov	 cl, BYTE PTR [ebp+edi*8+2]
  002d8	88 4c c5 02	 mov	 BYTE PTR [ebp+eax*8+2], cl

; 570  : 					Sparks(S).Y    = MouseY;

  002dc	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  002e2	88 5c c1 03	 mov	 BYTE PTR [ecx+eax*8+3], bl

; 571  : 					Sparks(S).Heat = FX_Heat; 

  002e6	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  002ec	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  002f2	88 54 c1 01	 mov	 BYTE PTR [ecx+eax*8+1], dl

; 572  : 
; 573  : 					Sparks(S).ByteA  = Sparks(ThisIdx).ByteA + 128;

  002f6	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  002fc	8a 4c fd 04	 mov	 cl, BYTE PTR [ebp+edi*8+4]

; 574  : 					Sparks(S).ByteB  = TempSize;  // size

  00300	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
  00304	80 c1 80	 add	 cl, 128			; 00000080H
  00307	88 4c c5 04	 mov	 BYTE PTR [ebp+eax*8+4], cl
  0030b	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00311	88 54 c1 05	 mov	 BYTE PTR [ecx+eax*8+5], dl

; 575  : 					Sparks(S).ByteD  = TempSpeed;

  00315	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0031b	89 54 24 10	 mov	 DWORD PTR -8+[esp+24], edx
  0031f	8a 54 24 1c	 mov	 dl, BYTE PTR _TempSpeed$108624[esp+20]
  00323	88 54 c1 07	 mov	 BYTE PTR [ecx+eax*8+7], dl
  00327	8b 54 24 10	 mov	 edx, DWORD PTR -8+[esp+24]
$L108629:

; 576  : 				}
; 577  : 				
; 578  : 				// Draw 2 more sparks at   +.33/.67 phases.
; 579  : 				if( ( DrawMode == DRAW_Lathe_3 ) && ( (ActiveSparkNum+2) <= SparksLimit ) )

  0032b	80 be f0 00 00
	00 03		 cmp	 BYTE PTR [esi+240], 3
  00332	0f 85 b3 00 00
	00		 jne	 $L108635
  00338	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  0033e	8b 8e f4 00 00
	00		 mov	 ecx, DWORD PTR [esi+244]
  00344	83 c0 02	 add	 eax, 2
  00347	3b c1		 cmp	 eax, ecx
  00349	0f 8f 9c 00 00
	00		 jg	 $L108635

; 580  : 				{
; 581  : 					for( INT t=1; t<3; t++ )

  0034f	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _t$108632[esp+24], 1
$L117049:

; 582  : 					{
; 583  : 						INT  S = ActiveSparkNum++; 

  00357	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  0035d	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00360	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 584  : 						Sparks(S).Type   = SparkType;

  00366	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0036c	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  00370	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  00376	88 14 c8	 mov	 BYTE PTR [eax+ecx*8], dl

; 585  : 						Sparks(S).X      = Sparks(ThisIdx).X;

  00379	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  0037f	8a 44 fd 02	 mov	 al, BYTE PTR [ebp+edi*8+2]
  00383	88 44 cd 02	 mov	 BYTE PTR [ebp+ecx*8+2], al

; 586  : 						Sparks(S).Y      = MouseY;

  00387	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0038d	88 5c c8 03	 mov	 BYTE PTR [eax+ecx*8+3], bl

; 587  : 						Sparks(S).Heat   = FX_Heat; 

  00391	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00397	8a 9e e8 00 00
	00		 mov	 bl, BYTE PTR [esi+232]

; 588  : 
; 589  : 						Sparks(S).ByteA  = Sparks(ThisIdx).ByteA + (t*(256/3) );
; 590  : 						Sparks(S).ByteB  = TempSize; // Size.

  0039d	8b 54 24 14	 mov	 edx, DWORD PTR -4+[esp+24]
  003a1	88 5c c8 01	 mov	 BYTE PTR [eax+ecx*8+1], bl
  003a5	8a 44 24 10	 mov	 al, BYTE PTR _t$108632[esp+24]
  003a9	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  003af	b3 55		 mov	 bl, 85			; 00000055H
  003b1	f6 eb		 imul	 bl
  003b3	8a 5c fd 04	 mov	 bl, BYTE PTR [ebp+edi*8+4]
  003b7	02 d8		 add	 bl, al
  003b9	88 5c cd 04	 mov	 BYTE PTR [ebp+ecx*8+4], bl
  003bd	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]

; 591  : 						Sparks(S).ByteD  = TempSpeed;

  003c3	8a 5c 24 1c	 mov	 bl, BYTE PTR _TempSpeed$108624[esp+20]
  003c7	88 54 c8 05	 mov	 BYTE PTR [eax+ecx*8+5], dl
  003cb	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  003d1	88 5c c8 07	 mov	 BYTE PTR [eax+ecx*8+7], bl
  003d5	8b 44 24 10	 mov	 eax, DWORD PTR _t$108632[esp+24]
  003d9	8b 5c 24 20	 mov	 ebx, DWORD PTR _MouseY$[esp+20]
  003dd	40		 inc	 eax
  003de	83 f8 03	 cmp	 eax, 3
  003e1	89 44 24 10	 mov	 DWORD PTR _t$108632[esp+24], eax
  003e5	0f 8c 6c ff ff
	ff		 jl	 $L117049
$L108635:

; 592  : 					}
; 593  : 				}			
; 594  : 
; 595  : 				// Draw 2 more sparks at   +.33/.67 phases.
; 596  : 				if( ( DrawMode == DRAW_Lathe_4 ) && ( (ActiveSparkNum+3) <= SparksLimit ) )

  003eb	80 be f0 00 00
	00 04		 cmp	 BYTE PTR [esi+240], 4
  003f2	0f 85 fe 03 00
	00		 jne	 $L108670
  003f8	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  003fe	8b 86 f4 00 00
	00		 mov	 eax, DWORD PTR [esi+244]
  00404	83 c1 03	 add	 ecx, 3
  00407	3b c8		 cmp	 ecx, eax
  00409	0f 8f e7 03 00
	00		 jg	 $L108670

; 597  : 				{
; 598  : 					for( INT t=1; t<4; t++ )

  0040f	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR _t$108638[esp+24], 1
  00417	eb 07		 jmp	 SHORT $L108639
$L117050:
  00419	8b 5c 24 20	 mov	 ebx, DWORD PTR _MouseY$[esp+20]

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  0041d	8d 49 00	 npad	 3
$L108639:

; 599  : 					{
; 600  : 						INT  S = ActiveSparkNum++; 

  00420	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  00426	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00429	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 601  : 						Sparks(S).Type   = SparkType;

  0042f	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00435	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  00439	8a 96 e0 00 00
	00		 mov	 dl, BYTE PTR [esi+224]
  0043f	88 14 c1	 mov	 BYTE PTR [ecx+eax*8], dl

; 602  : 						Sparks(S).X      = Sparks(ThisIdx).X;

  00442	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  00448	8a 4c fd 02	 mov	 cl, BYTE PTR [ebp+edi*8+2]

; 603  : 						Sparks(S).Y      = MouseY;
; 604  : 						Sparks(S).Heat   = FX_Heat; 
; 605  : 
; 606  : 						Sparks(S).ByteA  = Sparks(ThisIdx).ByteA +( t * 64 );
; 607  : 						Sparks(S).ByteB  = TempSize; // Size.

  0044c	8b 54 24 14	 mov	 edx, DWORD PTR -4+[esp+24]
  00450	88 4c c5 02	 mov	 BYTE PTR [ebp+eax*8+2], cl
  00454	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0045a	88 5c c1 03	 mov	 BYTE PTR [ecx+eax*8+3], bl
  0045e	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00464	8a 9e e8 00 00
	00		 mov	 bl, BYTE PTR [esi+232]
  0046a	88 5c c1 01	 mov	 BYTE PTR [ecx+eax*8+1], bl
  0046e	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  00474	8a 4c 24 10	 mov	 cl, BYTE PTR _t$108638[esp+24]
  00478	8a 5c fd 04	 mov	 bl, BYTE PTR [ebp+edi*8+4]
  0047c	c0 e1 06	 shl	 cl, 6
  0047f	02 d9		 add	 bl, cl
  00481	88 5c c5 04	 mov	 BYTE PTR [ebp+eax*8+4], bl
  00485	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]

; 608  : 						Sparks(S).ByteD  = TempSpeed;

  0048b	8a 5c 24 1c	 mov	 bl, BYTE PTR _TempSpeed$108624[esp+20]
  0048f	88 54 c1 05	 mov	 BYTE PTR [ecx+eax*8+5], dl
  00493	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00499	88 5c c1 07	 mov	 BYTE PTR [ecx+eax*8+7], bl
  0049d	8b 44 24 10	 mov	 eax, DWORD PTR _t$108638[esp+24]
  004a1	40		 inc	 eax
  004a2	83 f8 04	 cmp	 eax, 4
  004a5	89 44 24 10	 mov	 DWORD PTR _t$108638[esp+24], eax
  004a9	0f 8c 6a ff ff
	ff		 jl	 $L117050
  004af	5f		 pop	 edi
  004b0	5e		 pop	 esi
  004b1	5d		 pop	 ebp
  004b2	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  004b3	83 c4 08	 add	 esp, 8
  004b6	c2 08 00	 ret	 8
$L108643:

; 609  : 					}
; 610  : 				}			
; 611  : 			}
; 612  : 			break;
; 613  : 
; 614  : 		case SPARK_Jugglers: // Twister (X=sin()) movement.
; 615  : 			Sparks(S).ByteA  = ( GlobalPhase * FX_Frequency + FX_Phase ) & 255;

  004b9	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]
  004bf	f6 ae d8 00 00
	00		 imul	 BYTE PTR [esi+216]
  004c5	8a 8e ed 00 00
	00		 mov	 cl, BYTE PTR [esi+237]
  004cb	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  004d1	02 c1		 add	 al, cl
  004d3	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 616  : 			Sparks(S).ByteB  = FX_Size;  // size

  004d7	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  004dd	8a 8e e9 00 00
	00		 mov	 cl, BYTE PTR [esi+233]
  004e3	88 4c f8 05	 mov	 BYTE PTR [eax+edi*8+5], cl

; 617  : 			Sparks(S).ByteD  = FX_HorizSpeed - 128;

  004e7	8a 96 ee 00 00
	00		 mov	 dl, BYTE PTR [esi+238]
  004ed	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  004f3	80 c2 80	 add	 dl, 128			; 00000080H
  004f6	88 54 f8 07	 mov	 BYTE PTR [eax+edi*8+7], dl
  004fa	5f		 pop	 edi
  004fb	5e		 pop	 esi
  004fc	5d		 pop	 ebp
  004fd	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  004fe	83 c4 08	 add	 esp, 8
  00501	c2 08 00	 ret	 8
$L108644:

; 618  : 			break;
; 619  : 
; 620  : 		case SPARK_Lissajous:
; 621  : 			Sparks(S).Heat  = FX_Size;       // size

  00504	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  0050a	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00510	88 44 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], al

; 622  : 			Sparks(S).ByteA = FX_Phase;      // phase u

  00514	8a 86 ed 00 00
	00		 mov	 al, BYTE PTR [esi+237]
  0051a	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00520	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 623  : 			Sparks(S).ByteB = FX_Frequency;  // phase v

  00524	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0052a	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]
  00530	88 44 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], al

; 624  : 			Sparks(S).ByteC = FX_HorizSpeed - 128;

  00534	8a 8e ee 00 00
	00		 mov	 cl, BYTE PTR [esi+238]
  0053a	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00540	80 c1 80	 add	 cl, 128			; 00000080H
  00543	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl

; 625  : 			Sparks(S).ByteD = FX_VertSpeed  - 128;

  00547	8a 8e ef 00 00
	00		 mov	 cl, BYTE PTR [esi+239]
  0054d	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00553	80 c1 80	 add	 cl, 128			; 00000080H
  00556	88 4c f8 07	 mov	 BYTE PTR [eax+edi*8+7], cl

; 626  : 			// Special-cases redirected to more efficient setters.
; 627  : 			if( Sparks(S).ByteC == 0 ) Sparks(S).Type = SPARK_LissajY;

  0055a	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00560	8d 04 f9	 lea	 eax, DWORD PTR [ecx+edi*8]
  00563	38 50 06	 cmp	 BYTE PTR [eax+6], dl
  00566	75 03		 jne	 SHORT $L108645
  00568	c6 00 1e	 mov	 BYTE PTR [eax], 30	; 0000001eH
$L108645:

; 628  : 			if( Sparks(S).ByteD == 0 ) Sparks(S).Type = SPARK_LissajX;

  0056b	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00571	8d 3c f8	 lea	 edi, DWORD PTR [eax+edi*8]
  00574	38 57 07	 cmp	 BYTE PTR [edi+7], dl
  00577	0f 85 79 02 00
	00		 jne	 $L108670
  0057d	c6 07 1d	 mov	 BYTE PTR [edi], 29	; 0000001dH
  00580	5f		 pop	 edi
  00581	5e		 pop	 esi
  00582	5d		 pop	 ebp
  00583	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00584	83 c4 08	 add	 esp, 8
  00587	c2 08 00	 ret	 8
$L108647:

; 629  : 			break;
; 630  : 
; 631  :         case SPARK_SphereLightning: // Spherical lightning.
; 632  :             Sparks(S).Heat   = FX_Heat;  // heat

  0058a	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00590	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  00596	88 54 f9 01	 mov	 BYTE PTR [ecx+edi*8+1], dl

; 633  :             Sparks(S).ByteC  = FX_Size;  // radius

  0059a	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  005a0	8a 8e e9 00 00
	00		 mov	 cl, BYTE PTR [esi+233]
  005a6	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl

; 634  :             // minimal 8 (=radius 4)
; 635  :             if( Sparks(S).ByteC <8 ) Sparks(S).ByteC = 8;

  005aa	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  005b0	8a 4c fa 06	 mov	 cl, BYTE PTR [edx+edi*8+6]
  005b4	80 f9 08	 cmp	 cl, 8
  005b7	8d 44 fa 06	 lea	 eax, DWORD PTR [edx+edi*8+6]
  005bb	73 03		 jae	 SHORT $L108648
  005bd	c6 00 08	 mov	 BYTE PTR [eax], 8
$L108648:

; 636  : 			Sparks(S).ByteD  = 96;  // Hardcoded chance.

  005c0	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  005c6	c6 44 f8 07 60	 mov	 BYTE PTR [eax+edi*8+7], 96 ; 00000060H
  005cb	5f		 pop	 edi
  005cc	5e		 pop	 esi
  005cd	5d		 pop	 ebp
  005ce	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  005cf	83 c4 08	 add	 esp, 8
  005d2	c2 08 00	 ret	 8
$L108649:

; 637  :             break;
; 638  : 
; 639  : 		case SPARK_Flocks:
; 640  : 			Sparks(S).ByteA  = 128;

  005d5	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  005db	b0 80		 mov	 al, 128			; 00000080H
  005dd	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 641  : 			Sparks(S).ByteB  = FX_Size;   // Lifetime

  005e1	8a 8e e9 00 00
	00		 mov	 cl, BYTE PTR [esi+233]
  005e7	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  005ed	88 4c fa 05	 mov	 BYTE PTR [edx+edi*8+5], cl

; 642  : 			Sparks(S).ByteC  = 128;

  005f1	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  005f7	88 44 fa 06	 mov	 BYTE PTR [edx+edi*8+6], al

; 643  : 			Sparks(S).ByteD  = (255-FX_Area);   // spawn direction delta

  005fb	8a 8e eb 00 00
	00		 mov	 cl, BYTE PTR [esi+235]
  00601	0c ff		 or	 al, 255			; 000000ffH
  00603	2a c1		 sub	 al, cl
  00605	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0060b	88 44 f9 07	 mov	 BYTE PTR [ecx+edi*8+7], al
  0060f	5f		 pop	 edi
  00610	5e		 pop	 esi
  00611	5d		 pop	 ebp
  00612	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00613	83 c4 08	 add	 esp, 8
  00616	c2 08 00	 ret	 8
$L108650:

; 644  : 			break;
; 645  : 
; 646  : 		case SPARK_Wheel:  // Swirly emitter.
; 647  : 			Sparks(S).ByteA  = FX_Phase;  // Initial spawn dir.

  00619	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0061f	8a 86 ed 00 00
	00		 mov	 al, BYTE PTR [esi+237]
  00625	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 648  : 			Sparks(S).ByteB  = FX_Size;   // Lifetime

  00629	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0062f	8a 96 e9 00 00
	00		 mov	 dl, BYTE PTR [esi+233]
  00635	88 54 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], dl

; 649  : 			Sparks(S).ByteC  = FX_Frequency; 

  00639	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0063f	8a 8e ec 00 00
	00		 mov	 cl, BYTE PTR [esi+236]
  00645	88 4c f8 06	 mov	 BYTE PTR [eax+edi*8+6], cl

; 650  : 			Sparks(S).ByteD  = (255-FX_Area);   // spawn direction delta

  00649	8a 86 eb 00 00
	00		 mov	 al, BYTE PTR [esi+235]
  0064f	80 ca ff	 or	 dl, 255			; 000000ffH
  00652	2a d0		 sub	 dl, al
  00654	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0065a	88 54 f8 07	 mov	 BYTE PTR [eax+edi*8+7], dl
  0065e	5f		 pop	 edi
  0065f	5e		 pop	 esi
  00660	5d		 pop	 ebp
  00661	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00662	83 c4 08	 add	 esp, 8
  00665	c2 08 00	 ret	 8
$L108651:

; 651  : 			break;
; 652  : 	
; 653  : 		case SPARK_Sprinkler: 
; 654  : 			Sparks(S).ByteA  = FX_Phase;  // Initial spawn dir.

  00668	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0066e	8a 96 ed 00 00
	00		 mov	 dl, BYTE PTR [esi+237]
  00674	88 54 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], dl

; 655  : 			Sparks(S).ByteB  = - 128;

  00678	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0067e	b0 80		 mov	 al, 128			; 00000080H
  00680	88 44 f9 05	 mov	 BYTE PTR [ecx+edi*8+5], al

; 656  : 			Sparks(S).ByteC  = 128;       // lifetime

  00684	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0068a	88 44 fa 06	 mov	 BYTE PTR [edx+edi*8+6], al
$L117053:

; 657  : 			Sparks(S).ByteD  = FX_Frequency;

  0068e	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00694	8a 8e ec 00 00
	00		 mov	 cl, BYTE PTR [esi+236]
  0069a	88 4c f8 07	 mov	 BYTE PTR [eax+edi*8+7], cl
  0069e	5f		 pop	 edi
  0069f	5e		 pop	 esi
  006a0	5d		 pop	 ebp
  006a1	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  006a2	83 c4 08	 add	 esp, 8
  006a5	c2 08 00	 ret	 8
$L108652:

; 658  : 			break;
; 659  : 
; 660  : 		case SPARK_Gametes: 
; 661  : 			Sparks(S).ByteC  = FX_Size;    // Lifetime of spawned spermatozoids.

  006a8	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  006ae	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  006b4	88 44 fa 06	 mov	 BYTE PTR [edx+edi*8+6], al
  006b8	5f		 pop	 edi
  006b9	5e		 pop	 esi
  006ba	5d		 pop	 ebp
  006bb	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  006bc	83 c4 08	 add	 esp, 8
  006bf	c2 08 00	 ret	 8
$L108653:

; 662  : 			break;
; 663  : 
; 664  : 		case SPARK_LocalCloud:
; 665  : 			Sparks(S).ByteC  = FX_Area;

  006c2	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  006c8	8a 96 eb 00 00
	00		 mov	 dl, BYTE PTR [esi+235]
  006ce	88 54 f9 06	 mov	 BYTE PTR [ecx+edi*8+6], dl
$L108654:

; 666  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;         

  006d2	8a 86 ee 00 00
	00		 mov	 al, BYTE PTR [esi+238]
  006d8	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  006de	04 80		 add	 al, 128			; 00000080H
  006e0	88 44 f9 04	 mov	 BYTE PTR [ecx+edi*8+4], al

; 667  :             Sparks(S).ByteB  = (255 ^ FX_VertSpeed) - 128;  

  006e4	8a 96 ef 00 00
	00		 mov	 dl, BYTE PTR [esi+239]
  006ea	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  006f0	f6 d2		 not	 dl
  006f2	80 c2 80	 add	 dl, 128			; 00000080H
  006f5	88 54 f8 05	 mov	 BYTE PTR [eax+edi*8+5], dl

; 668  : 			Sparks(S).ByteD  = 255-FX_Size;

  006f9	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  006ff	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00705	80 c9 ff	 or	 cl, 255			; 000000ffH
  00708	2a c8		 sub	 cl, al
  0070a	88 4c fa 07	 mov	 BYTE PTR [edx+edi*8+7], cl
  0070e	5f		 pop	 edi
  0070f	5e		 pop	 esi
  00710	5d		 pop	 ebp
  00711	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  00712	83 c4 08	 add	 esp, 8
  00715	c2 08 00	 ret	 8
$L108656:

; 669  : 			break;
; 670  : 
; 671  : 		case SPARK_CustomCloud:
; 672  : 			Sparks(S).ByteA  = FX_HorizSpeed - 128;         
; 673  :             Sparks(S).ByteB  = (255 ^ FX_VertSpeed) - 128;  
; 674  : 			Sparks(S).ByteD  = 255-FX_Size;
; 675  : 			break;
; 676  : 
; 677  :         case SPARK_LineLightning: // 2-point lightning bolts.
; 678  :         case SPARK_RampLightning: 
; 679  :             // We have a new spark if no other was an 'open' one.
; 680  : 			// Not always the last one since short-lived sparks may shuffle the spark
; 681  : 			// order at any moment.
; 682  :             do { S--; }

  00718	4f		 dec	 edi

; 683  : 			while( (S>=0) && !( (Sparks(S).Type == SparkType) && (Sparks(S).ByteD == 0))  );

  00719	0f 88 b1 00 00
	00		 js	 $L108660
  0071f	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]
  00725	38 4c fd 00	 cmp	 BYTE PTR [ebp+edi*8], cl
  00729	8d 6c fd 00	 lea	 ebp, DWORD PTR [ebp+edi*8]
  0072d	75 e9		 jne	 SHORT $L108656
  0072f	38 55 07	 cmp	 BYTE PTR [ebp+7], dl
  00732	75 e4		 jne	 SHORT $L108656

; 684  : 
; 685  :             if( S>=0 )
; 686  :             // Open point found, draw it while being stretched.
; 687  :             {
; 688  :                 ActiveSparkNum--; // so don't allocate 'current' spark

  00734	ff 8e f8 00 00
	00		 dec	 DWORD PTR [esi+248]

; 689  : 
; 690  : 				// Refresh to 'starting' point
; 691  : 				Sparks(S).X  = LightPinX;

  0073a	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00740	89 54 24 20	 mov	 DWORD PTR 12+[esp+20], edx
  00744	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?LightPinX@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA
  0074a	88 54 f9 02	 mov	 BYTE PTR [ecx+edi*8+2], dl

; 692  : 				Sparks(S).Y  = LightPinY;

  0074e	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00754	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?LightPinY@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA
  0075a	88 54 f9 03	 mov	 BYTE PTR [ecx+edi*8+3], dl

; 693  : 
; 694  :                 // Dragging the lightning: Must have a heat value.
; 695  :                 // Close it by setting ByteD = heat ?
; 696  :                 // To nonzero, eventually.
; 697  : 
; 698  :                 Sparks(S).Heat = 3 | (FX_Heat); // Brightness.

  0075e	8a 8e e8 00 00
	00		 mov	 cl, BYTE PTR [esi+232]
  00764	8b ae fc 00 00
	00		 mov	 ebp, DWORD PTR [esi+252]

; 699  : 
; 700  :                 INT  LenX = MouseX - (INT)Sparks(S).X;
; 701  :                 INT  LenY = MouseY - (INT)Sparks(S).Y;

  0076a	8b 54 24 20	 mov	 edx, DWORD PTR 12+[esp+20]
  0076e	80 c9 03	 or	 cl, 3
  00771	88 4c fd 01	 mov	 BYTE PTR [ebp+edi*8+1], cl
  00775	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0077b	0f b6 6c f9 02	 movzx	 ebp, BYTE PTR [ecx+edi*8+2]
  00780	8d 0c f9	 lea	 ecx, DWORD PTR [ecx+edi*8]
  00783	2b c5		 sub	 eax, ebp
  00785	0f b6 69 03	 movzx	 ebp, BYTE PTR [ecx+3]
  00789	2b dd		 sub	 ebx, ebp

; 702  : 
; 703  : 				if( LenX<0 )	LenX  = (- LenX) | 1;

  0078b	3b c2		 cmp	 eax, edx
  0078d	7d 07		 jge	 SHORT $L108665
  0078f	f7 d8		 neg	 eax
  00791	83 c8 01	 or	 eax, 1

; 704  :                 else			LenX &= 0xFFFFFFFE;

  00794	eb 03		 jmp	 SHORT $L108666
$L108665:
  00796	83 e0 fe	 and	 eax, -2			; fffffffeH
$L108666:

; 705  : 				if( LenY<0 )	LenY  = (- LenY) | 1;

  00799	3b da		 cmp	 ebx, edx
  0079b	7d 07		 jge	 SHORT $L108667
  0079d	f7 db		 neg	 ebx
  0079f	83 cb 01	 or	 ebx, 1

; 706  :                 else			LenY &= 0xFFFFFFFE;

  007a2	eb 03		 jmp	 SHORT $L108668
$L108667:
  007a4	83 e3 fe	 and	 ebx, -2			; fffffffeH
$L108668:

; 707  : 
; 708  :                 if( (LenX == 0) && (LenY == 0) )

  007a7	3b c2		 cmp	 eax, edx
  007a9	75 07		 jne	 SHORT $L108669
  007ab	3b da		 cmp	 ebx, edx
  007ad	75 03		 jne	 SHORT $L108669

; 709  :                     Sparks(S).Heat=0;  // too short!

  007af	88 51 01	 mov	 BYTE PTR [ecx+1], dl
$L108669:

; 710  : 
; 711  :                 Sparks(S).ByteA = LenX;

  007b2	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  007b8	88 44 fa 04	 mov	 BYTE PTR [edx+edi*8+4], al

; 712  :                 Sparks(S).ByteB = LenY;

  007bc	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  007c2	88 5c f8 05	 mov	 BYTE PTR [eax+edi*8+5], bl
  007c6	5f		 pop	 edi
  007c7	5e		 pop	 esi
  007c8	5d		 pop	 ebp
  007c9	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  007ca	83 c4 08	 add	 esp, 8
  007cd	c2 08 00	 ret	 8
$L108660:

; 713  :                 // ByteD Stays 0 while drawing to indicate open bolt.
; 714  : 
; 715  :             } // Open point found.
; 716  : 
; 717  :             else
; 718  : 
; 719  :             { // No open point found: new lightning thing.
; 720  :                 S = ActiveSparkNum - 1;

  007d0	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]

; 721  :                 Sparks(S).ByteD=0; // Signify open bolt.

  007d6	8b be fc 00 00
	00		 mov	 edi, DWORD PTR [esi+252]
  007dc	49		 dec	 ecx
  007dd	88 54 cf 07	 mov	 BYTE PTR [edi+ecx*8+7], dl

; 722  : 				Sparks(S).Heat =0; //

  007e1	8b b6 fc 00 00
	00		 mov	 esi, DWORD PTR [esi+252]
  007e7	88 54 ce 01	 mov	 BYTE PTR [esi+ecx*8+1], dl

; 723  : 				LightPinX = MouseX;

  007eb	a3 00 00 00 00	 mov	 DWORD PTR ?LightPinX@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA, eax

; 724  : 				LightPinY = MouseY;

  007f0	89 1d 00 00 00
	00		 mov	 DWORD PTR ?LightPinY@?1??AddSpark@UFireTexture@@AAEXHH@Z@4HA, ebx
$L108670:
  007f6	5f		 pop	 edi
  007f7	5e		 pop	 esi
  007f8	5d		 pop	 ebp
  007f9	5b		 pop	 ebx

; 725  :             }
; 726  : 			break;
; 727  : 	}
; 728  : }

  007fa	83 c4 08	 add	 esp, 8
  007fd	c2 08 00	 ret	 8
$L117054:
  00800	00 00 00 00	 DD	 $L108610
  00804	00 00 00 00	 DD	 $L108611
  00808	00 00 00 00	 DD	 $L108612
  0080c	00 00 00 00	 DD	 $L108670
  00810	00 00 00 00	 DD	 $L108670
  00814	00 00 00 00	 DD	 $L108670
  00818	00 00 00 00	 DD	 $L108616
  0081c	00 00 00 00	 DD	 $L108616
  00820	00 00 00 00	 DD	 $L108622
  00824	00 00 00 00	 DD	 $L108622
  00828	00 00 00 00	 DD	 $L108644
  0082c	00 00 00 00	 DD	 $L108643
  00830	00 00 00 00	 DD	 $L108620
  00834	00 00 00 00	 DD	 $L108620
  00838	00 00 00 00	 DD	 $L108649
  0083c	00 00 00 00	 DD	 $L108652
  00840	00 00 00 00	 DD	 $L108614
  00844	00 00 00 00	 DD	 $L108670
  00848	00 00 00 00	 DD	 $L108670
  0084c	00 00 00 00	 DD	 $L108654
  00850	00 00 00 00	 DD	 $L108653
  00854	00 00 00 00	 DD	 $L108613
  00858	00 00 00 00	 DD	 $L108656
  0085c	00 00 00 00	 DD	 $L108656
  00860	00 00 00 00	 DD	 $L108647
  00864	00 00 00 00	 DD	 $L108650
  00868	00 00 00 00	 DD	 $L108652
  0086c	00 00 00 00	 DD	 $L108651
?AddSpark@UFireTexture@@AAEXHH@Z ENDP			; UFireTexture::AddSpark
_TEXT	ENDS
PUBLIC	?CloseSpark@UFireTexture@@AAEXHH@Z		; UFireTexture::CloseSpark
; Function compile flags: /Ogty
;	COMDAT ?CloseSpark@UFireTexture@@AAEXHH@Z
_TEXT	SEGMENT
?CloseSpark@UFireTexture@@AAEXHH@Z PROC NEAR		; UFireTexture::CloseSpark, COMDAT
; _this$ = ecx

; 732  : {

  00000	56		 push	 esi

; 733  :     INT  S = ActiveSparkNum; // Sparks[S=0] is only one if ActiveSparkNum = 1.

  00001	8b b1 f8 00 00
	00		 mov	 esi, DWORD PTR [ecx+248]
$L108677:

; 734  : 
; 735  : 	        // Warning: extremely kludgy.
; 736  :             // Find ANY old spark of type 17/18 which has an 'open' end.
; 737  :             do { S--; } while( (S>=0) && !(	(

  00007	4e		 dec	 esi

; 738  : 				                   (Sparks(S).Type == SPARK_LineLightning)
; 739  : 							    || (Sparks(S).Type == SPARK_RampLightning)
; 740  : 								)
; 741  : 								&& (Sparks(S).ByteD == 0))  );

  00008	78 3c		 js	 SHORT $L108683
  0000a	8b 81 fc 00 00
	00		 mov	 eax, DWORD PTR [ecx+252]
  00010	8d 14 f0	 lea	 edx, DWORD PTR [eax+esi*8]
  00013	8a 02		 mov	 al, BYTE PTR [edx]
  00015	3c 17		 cmp	 al, 23			; 00000017H
  00017	74 04		 je	 SHORT $L108681
  00019	3c 18		 cmp	 al, 24			; 00000018H
  0001b	75 ea		 jne	 SHORT $L108677
$L108681:
  0001d	8a 42 07	 mov	 al, BYTE PTR [edx+7]
  00020	84 c0		 test	 al, al
  00022	75 e3		 jne	 SHORT $L108677

; 742  :             if( S>=0 )
; 743  :             // Open point found, closin' it.
; 744  :             {
; 745  :                 // ByteD, minimally 1...
; 746  : 				Sparks(S).ByteD  = FX_Frequency;

  00024	8a 81 ec 00 00
	00		 mov	 al, BYTE PTR [ecx+236]
  0002a	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00030	88 44 f2 07	 mov	 BYTE PTR [edx+esi*8+7], al

; 747  : 				if( Sparks(S).ByteD == 0 ) Sparks(S).ByteD = 1; // Ensure != 0.

  00034	8b 89 fc 00 00
	00		 mov	 ecx, DWORD PTR [ecx+252]
  0003a	8d 44 f1 07	 lea	 eax, DWORD PTR [ecx+esi*8+7]
  0003e	80 38 00	 cmp	 BYTE PTR [eax], 0
  00041	75 03		 jne	 SHORT $L108683
  00043	c6 00 01	 mov	 BYTE PTR [eax], 1
$L108683:
  00046	5e		 pop	 esi

; 748  : 			}
; 749  : }

  00047	c2 08 00	 ret	 8
?CloseSpark@UFireTexture@@AAEXHH@Z ENDP			; UFireTexture::CloseSpark
_TEXT	ENDS
PUBLIC	?DeleteSparks@UFireTexture@@AAEXHHH@Z		; UFireTexture::DeleteSparks
; Function compile flags: /Ogty
;	COMDAT ?DeleteSparks@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT
_SparkX$ = 8
_SparkY$ = 12
_AreaWidth$ = 16
?DeleteSparks@UFireTexture@@AAEXHHH@Z PROC NEAR		; UFireTexture::DeleteSparks, COMDAT
; _this$ = ecx

; 758  : {

  00000	53		 push	 ebx

; 759  :     if( ActiveSparkNum > 0 )

  00001	8b 99 f8 00 00
	00		 mov	 ebx, DWORD PTR [ecx+248]
  00007	85 db		 test	 ebx, ebx
  00009	56		 push	 esi
  0000a	7e 58		 jle	 SHORT $L108694

; 760  : 	{
; 761  : 		for( INT S=0; S<ActiveSparkNum; S++ )

  0000c	33 f6		 xor	 esi, esi
  0000e	85 db		 test	 ebx, ebx
  00010	7e 52		 jle	 SHORT $L108694
  00012	55		 push	 ebp
  00013	57		 push	 edi
$L108692:

; 762  : 		{
; 763  : 			// Diamond-shaped eraser.
; 764  : 			if( AreaWidth >= Abs(SparkX - Sparks(S).X) + Abs(SparkY - Sparks(S).Y ) )

  00014	8b 81 fc 00 00
	00		 mov	 eax, DWORD PTR [ecx+252]
  0001a	0f b6 7c f0 02	 movzx	 edi, BYTE PTR [eax+esi*8+2]
  0001f	8b 54 24 14	 mov	 edx, DWORD PTR _SparkX$[esp+12]
  00023	2b d7		 sub	 edx, edi
  00025	79 02		 jns	 SHORT $L117088
  00027	f7 da		 neg	 edx
$L117088:
  00029	0f b6 6c f0 03	 movzx	 ebp, BYTE PTR [eax+esi*8+3]
  0002e	8b 7c 24 18	 mov	 edi, DWORD PTR _SparkY$[esp+12]
  00032	2b fd		 sub	 edi, ebp
  00034	79 02		 jns	 SHORT $L117099
  00036	f7 df		 neg	 edi
$L117099:
  00038	03 fa		 add	 edi, edx
  0003a	39 7c 24 1c	 cmp	 DWORD PTR _AreaWidth$[esp+12], edi
  0003e	7c 17		 jl	 SHORT $L108693

; 765  : 			{
; 766  : 				// Delete spark by replacing it with last one (+ delete last one).
; 767  : 				INT LastSpark = --ActiveSparkNum;

  00040	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  00043	89 91 f8 00 00
	00		 mov	 DWORD PTR [ecx+248], edx

; 768  : 				Sparks(S) =   Sparks(LastSpark);

  00049	8b 3c d0	 mov	 edi, DWORD PTR [eax+edx*8]
  0004c	89 3c f0	 mov	 DWORD PTR [eax+esi*8], edi
  0004f	8b 54 d0 04	 mov	 edx, DWORD PTR [eax+edx*8+4]
  00053	89 54 f0 04	 mov	 DWORD PTR [eax+esi*8+4], edx
$L108693:
  00057	8b 99 f8 00 00
	00		 mov	 ebx, DWORD PTR [ecx+248]
  0005d	46		 inc	 esi
  0005e	3b f3		 cmp	 esi, ebx
  00060	7c b2		 jl	 SHORT $L108692
  00062	5f		 pop	 edi
  00063	5d		 pop	 ebp
$L108694:
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx

; 769  : 			}
; 770  : 		}
; 771  : 	}
; 772  : }

  00066	c2 0c 00	 ret	 12			; 0000000cH
?DeleteSparks@UFireTexture@@AAEXHHH@Z ENDP		; UFireTexture::DeleteSparks
_TEXT	ENDS
PUBLIC	?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z	; UFireTexture::DrawSparkLine
; Function compile flags: /Ogty
;	COMDAT ?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z
_TEXT	SEGMENT
_Xinc$ = 16
_Yinc$ = 8
_DivY2$108734 = 12
_DivX2$108744 = 12
_StartX$ = 8
_StartY$ = 12
_DestX$ = 16
_DestY$ = 20
_this$ = -4
?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z PROC NEAR	; UFireTexture::DrawSparkLine, COMDAT
; _this$ = ecx

; 780  : {

  00000	51		 push	 ecx

; 781  :     INT  Xinc, Yinc;
; 782  : 
; 783  :     INT  DivX = DestX - StartX;

  00001	8b 44 24 10	 mov	 eax, DWORD PTR _DestX$[esp]
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	8b 74 24 14	 mov	 esi, DWORD PTR _StartX$[esp+12]
  0000c	89 4c 24 0c	 mov	 DWORD PTR _this$[esp+16], ecx

; 784  :     INT  DivY = DestY - StartY;

  00010	8b 4c 24 20	 mov	 ecx, DWORD PTR _DestY$[esp+12]
  00014	57		 push	 edi
  00015	8b 7c 24 1c	 mov	 edi, DWORD PTR _StartY$[esp+16]
  00019	2b c6		 sub	 eax, esi
  0001b	2b cf		 sub	 ecx, edi

; 785  : 
; 786  :     if( (DivX == 0) && (DivY == 0) )

  0001d	83 ca ff	 or	 edx, -1
  00020	85 c0		 test	 eax, eax
  00022	75 0a		 jne	 SHORT $L117134
  00024	85 c9		 test	 ecx, ecx
  00026	0f 84 e2 00 00
	00		 je	 $L108750

; 787  :         return;
; 788  : 
; 789  :     if( DivX<0 )

  0002c	eb 14		 jmp	 SHORT $L108719
$L117134:
  0002e	7d 06		 jge	 SHORT $L108717

; 790  :         Xinc = -1;

  00030	89 54 24 20	 mov	 DWORD PTR _Xinc$[esp+16], edx

; 791  :     else

  00034	eb 14		 jmp	 SHORT $L108720
$L108717:

; 792  :     {
; 793  :         if( DivX>0 )

  00036	85 c0		 test	 eax, eax

; 794  :             Xinc = 1;

  00038	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _Xinc$[esp+16], 1
  00040	7f 08		 jg	 SHORT $L108720
$L108719:

; 795  :         else
; 796  :             Xinc=0;

  00042	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _Xinc$[esp+16], 0
$L108720:

; 797  :     }
; 798  : 
; 799  :     if( DivY<0 )

  0004a	85 c9		 test	 ecx, ecx

; 800  :         Yinc = -1;
; 801  :     else

  0004c	7c 07		 jl	 SHORT $L117135

; 802  :     {
; 803  :         if( DivY>0 )

  0004e	33 d2		 xor	 edx, edx
  00050	85 c9		 test	 ecx, ecx
  00052	0f 9f c2	 setg	 dl
$L117135:

; 804  :             Yinc = 1;
; 805  :         else
; 806  :             Yinc=0;
; 807  :     }
; 808  : 
; 809  :     DivX = Abs(DivX);

  00055	85 c0		 test	 eax, eax
  00057	89 54 24 18	 mov	 DWORD PTR _Yinc$[esp+16], edx
  0005b	7d 02		 jge	 SHORT $L117119
  0005d	f7 d8		 neg	 eax
$L117119:

; 810  :     DivY = Abs(DivY);

  0005f	85 c9		 test	 ecx, ecx
  00061	7d 02		 jge	 SHORT $L117126
  00063	f7 d9		 neg	 ecx
$L117126:

; 811  : 
; 812  :     INT  Xpoint = StartX;
; 813  :     INT  Ypoint = StartY;
; 814  : 
; 815  :     if( DivX>=DivY )   // Draw line based on X loop.

  00065	3b c1		 cmp	 eax, ecx
  00067	8b de		 mov	 ebx, esi
  00069	7c 5b		 jl	 SHORT $L108733

; 816  :     {
; 817  :         INT  DivY2  = DivY + DivY;

  0006b	03 c9		 add	 ecx, ecx

; 818  :         INT  Diff   = DivY2 - DivX;

  0006d	8b f1		 mov	 esi, ecx

; 819  :         INT  DivXY2 = DivY2 - DivX - DivX;

  0006f	8d 14 00	 lea	 edx, DWORD PTR [eax+eax]
  00072	8b e9		 mov	 ebp, ecx
  00074	2b f0		 sub	 esi, eax
  00076	2b ea		 sub	 ebp, edx

; 820  : 
; 821  :         for( INT LCount = 1; LCount<=DivX; LCount++ )

  00078	83 f8 01	 cmp	 eax, 1
  0007b	89 4c 24 1c	 mov	 DWORD PTR _DivY2$108734[esp+16], ecx
  0007f	0f 8c 89 00 00
	00		 jl	 $L108750

; 816  :     {
; 817  :         INT  DivY2  = DivY + DivY;

  00085	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax

; 853  :         }
; 854  :     }
; 855  : }

  00089	8d a4 24 00 00
	00 00		 npad	 7
$L108738:

; 822  :         {
; 823  :             AddSpark(Xpoint,Ypoint);

  00090	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  00094	57		 push	 edi
  00095	53		 push	 ebx
  00096	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 824  : 
; 825  :             if( Diff<0 )

  0009b	85 f6		 test	 esi, esi
  0009d	7d 06		 jge	 SHORT $L108741

; 826  :                 Diff += DivY2;

  0009f	03 74 24 1c	 add	 esi, DWORD PTR _DivY2$108734[esp+16]

; 827  :             else

  000a3	eb 08		 jmp	 SHORT $L108742
$L108741:

; 828  :             {
; 829  :                 Diff   += DivXY2;
; 830  :                 Ypoint += Yinc;

  000a5	8b 44 24 18	 mov	 eax, DWORD PTR _Yinc$[esp+16]
  000a9	03 f5		 add	 esi, ebp
  000ab	03 f8		 add	 edi, eax
$L108742:

; 831  :             }
; 832  :         Xpoint += Xinc;

  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR _Xinc$[esp+16]
  000b1	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  000b5	03 d9		 add	 ebx, ecx
  000b7	48		 dec	 eax
  000b8	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
  000bc	75 d2		 jne	 SHORT $L108738
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5d		 pop	 ebp
  000c1	5b		 pop	 ebx

; 853  :         }
; 854  :     }
; 855  : }

  000c2	59		 pop	 ecx
  000c3	c2 14 00	 ret	 20			; 00000014H
$L108733:

; 833  :         }
; 834  :     }
; 835  :     else    // Draw line based on Y loop.
; 836  :     {
; 837  :         INT  DivX2  = DivX  + DivX;

  000c6	03 c0		 add	 eax, eax

; 838  :         INT  Diff   = DivX2 - DivY;

  000c8	8b f0		 mov	 esi, eax

; 839  :         INT  DivXY2 = DivX2 - DivY - DivY;

  000ca	8d 14 09	 lea	 edx, DWORD PTR [ecx+ecx]
  000cd	8b e8		 mov	 ebp, eax
  000cf	2b f1		 sub	 esi, ecx
  000d1	2b ea		 sub	 ebp, edx

; 840  : 
; 841  :         for( INT LCount = 1; LCount<=DivY; LCount++ )

  000d3	83 f9 01	 cmp	 ecx, 1
  000d6	89 44 24 1c	 mov	 DWORD PTR _DivX2$108744[esp+16], eax
  000da	7c 32		 jl	 SHORT $L108750

; 833  :         }
; 834  :     }
; 835  :     else    // Draw line based on Y loop.
; 836  :     {
; 837  :         INT  DivX2  = DivX  + DivX;

  000dc	89 4c 24 24	 mov	 DWORD PTR 20+[esp+16], ecx
$L108748:

; 842  :         {
; 843  :             AddSpark(Xpoint,Ypoint);

  000e0	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$[esp+20]
  000e4	57		 push	 edi
  000e5	53		 push	 ebx
  000e6	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 844  : 
; 845  :             if( Diff<0 )

  000eb	85 f6		 test	 esi, esi
  000ed	7d 06		 jge	 SHORT $L108751

; 846  :                 Diff += DivX2;

  000ef	03 74 24 1c	 add	 esi, DWORD PTR _DivX2$108744[esp+16]

; 847  :             else

  000f3	eb 08		 jmp	 SHORT $L108752
$L108751:

; 848  :             {
; 849  :                 Diff   += DivXY2;
; 850  :                 Xpoint += Xinc;

  000f5	8b 44 24 20	 mov	 eax, DWORD PTR _Xinc$[esp+16]
  000f9	03 f5		 add	 esi, ebp
  000fb	03 d8		 add	 ebx, eax
$L108752:

; 851  :             }
; 852  :             Ypoint += Yinc;

  000fd	8b 4c 24 18	 mov	 ecx, DWORD PTR _Yinc$[esp+16]
  00101	8b 44 24 24	 mov	 eax, DWORD PTR 20+[esp+16]
  00105	03 f9		 add	 edi, ecx
  00107	48		 dec	 eax
  00108	89 44 24 24	 mov	 DWORD PTR 20+[esp+16], eax
  0010c	75 d2		 jne	 SHORT $L108748
$L108750:
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5d		 pop	 ebp
  00111	5b		 pop	 ebx

; 853  :         }
; 854  :     }
; 855  : }

  00112	59		 pop	 ecx
  00113	c2 14 00	 ret	 20			; 00000014H
?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z ENDP		; UFireTexture::DrawSparkLine
_TEXT	ENDS
PUBLIC	?FirePaint@UFireTexture@@AAEXHHK@Z		; UFireTexture::FirePaint
; Function compile flags: /Ogty
;	COMDAT ?FirePaint@UFireTexture@@AAEXHHK@Z
_TEXT	SEGMENT
_MouseX$ = 8
_MouseY$ = 12
_Buttons$ = 16
_RightButton$ = -4
_LeftButton$ = -16
_PosChanged$ = 16
_RightChanged$ = -8
_LeftChanged$ = -12
?FirePaint@UFireTexture@@AAEXHHK@Z PROC NEAR		; UFireTexture::FirePaint, COMDAT
; _this$ = ecx

; 865  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 866  : 	UBOOL RightButton = (Buttons & MOUSE_Right);

  00003	8b 44 24 1c	 mov	 eax, DWORD PTR _Buttons$[esp+12]

; 867  : 	UBOOL  LeftButton = (Buttons & MOUSE_Left);
; 868  : 
; 869  : 	// Perform painting.
; 870  :     static INT  LastMouseX=0, LastMouseY=0, LastLeftButton=0, LastRightButton=0;
; 871  : 
; 872  :     UBOOL  PosChanged   = ((LastMouseX != MouseX) || (LastMouseY != MouseY));

  00007	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?LastMouseY@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA
  0000d	53		 push	 ebx
  0000e	8b 5c 24 18	 mov	 ebx, DWORD PTR _MouseX$[esp+16]
  00012	55		 push	 ebp
  00013	56		 push	 esi
  00014	8b f0		 mov	 esi, eax
  00016	83 e0 01	 and	 eax, 1
  00019	8b e8		 mov	 ebp, eax
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?LastMouseX@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA
  00020	83 e6 02	 and	 esi, 2
  00023	3b c3		 cmp	 eax, ebx
  00025	57		 push	 edi
  00026	8b f9		 mov	 edi, ecx
  00028	89 74 24 1c	 mov	 DWORD PTR _RightButton$[esp+32], esi
  0002c	89 6c 24 10	 mov	 DWORD PTR _LeftButton$[esp+32], ebp
  00030	75 0e		 jne	 SHORT $L117139
  00032	3b 54 24 28	 cmp	 edx, DWORD PTR _MouseY$[esp+28]
  00036	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR _PosChanged$[esp+28], 0
  0003e	74 08		 je	 SHORT $L117140
$L117139:
  00040	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR _PosChanged$[esp+28], 1
$L117140:

; 873  :     UBOOL  RightChanged =  (LastRightButton != RightButton);

  00048	33 c9		 xor	 ecx, ecx
  0004a	39 35 00 00 00
	00		 cmp	 DWORD PTR ?LastRightButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, esi
  00050	0f 95 c1	 setne	 cl
  00053	89 4c 24 18	 mov	 DWORD PTR _RightChanged$[esp+32], ecx

; 874  :     UBOOL  LeftChanged  =  (LastLeftButton  != LeftButton);

  00057	33 c9		 xor	 ecx, ecx
  00059	39 2d 00 00 00
	00		 cmp	 DWORD PTR ?LastLeftButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, ebp
  0005f	0f 95 c1	 setne	 cl

; 875  : 
; 876  : 
; 877  : 	
; 878  : 	if( LeftChanged && LeftButton )

  00062	85 c9		 test	 ecx, ecx
  00064	89 4c 24 14	 mov	 DWORD PTR _LeftChanged$[esp+32], ecx
  00068	74 33		 je	 SHORT $L108773
  0006a	85 ed		 test	 ebp, ebp
  0006c	74 1f		 je	 SHORT $L117201

; 879  : 	{
; 880  : 		PenDownX = MouseX;
; 881  : 		PenDownY = MouseY;

  0006e	8a 54 24 28	 mov	 dl, BYTE PTR _MouseY$[esp+28]
  00072	88 97 12 05 00
	00		 mov	 BYTE PTR [edi+1298], dl

; 896  : 			{	
; 897  :             AddSpark( MouseX, MouseY);

  00078	8b 54 24 28	 mov	 edx, DWORD PTR _MouseY$[esp+28]
  0007c	52		 push	 edx
  0007d	53		 push	 ebx
  0007e	8b cf		 mov	 ecx, edi
  00080	88 9f 11 05 00
	00		 mov	 BYTE PTR [edi+1297], bl
  00086	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 898  : 			}
; 899  :     }
; 900  :     else // LeftButton == 0

  0008b	eb 63		 jmp	 SHORT $L108779
$L117201:

; 882  : 	}
; 883  : 	if( LeftChanged && (!LeftButton) )
; 884  : 	{
; 885  : 		PenDownX=0;

  0008d	c6 87 11 05 00
	00 00		 mov	 BYTE PTR [edi+1297], 0

; 886  : 		PenDownY=0;

  00094	c6 87 12 05 00
	00 00		 mov	 BYTE PTR [edi+1298], 0

; 887  : 	}
; 888  :     
; 889  :     // Draws the kind of spark/linetype currently selected.
; 890  :     if( LeftButton )

  0009b	eb 46		 jmp	 SHORT $L108780
$L108773:
  0009d	85 ed		 test	 ebp, ebp
  0009f	74 3a		 je	 SHORT $L117202

; 891  :     {
; 892  :         if( !LeftChanged && PosChanged && ( SparkType<4 ))

  000a1	8b 4c 24 2c	 mov	 ecx, DWORD PTR _PosChanged$[esp+28]
  000a5	85 c9		 test	 ecx, ecx
  000a7	74 57		 je	 SHORT $L117200
  000a9	80 bf e0 00 00
	00 04		 cmp	 BYTE PTR [edi+224], 4
  000b0	73 11		 jae	 SHORT $L117198

; 893  :             DrawSparkLine( LastMouseX, LastMouseY, MouseX, MouseY, 1);

  000b2	8b 4c 24 28	 mov	 ecx, DWORD PTR _MouseY$[esp+28]
  000b6	6a 01		 push	 1
  000b8	51		 push	 ecx
  000b9	53		 push	 ebx
  000ba	52		 push	 edx
  000bb	50		 push	 eax
  000bc	8b cf		 mov	 ecx, edi
  000be	e8 00 00 00 00	 call	 ?DrawSparkLine@UFireTexture@@AAEXHHHHH@Z ; UFireTexture::DrawSparkLine
$L117198:

; 894  : 
; 895  :         if( LeftChanged || ( PosChanged && ( SparkType>=4 )  )  )

  000c3	80 bf e0 00 00
	00 04		 cmp	 BYTE PTR [edi+224], 4
  000ca	72 2c		 jb	 SHORT $L117199

; 896  : 			{	
; 897  :             AddSpark( MouseX, MouseY);

  000cc	8b 54 24 28	 mov	 edx, DWORD PTR _MouseY$[esp+28]
  000d0	52		 push	 edx
  000d1	53		 push	 ebx
  000d2	8b cf		 mov	 ecx, edi
  000d4	e8 00 00 00 00	 call	 ?AddSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::AddSpark

; 898  : 			}
; 899  :     }
; 900  :     else // LeftButton == 0

  000d9	eb 15		 jmp	 SHORT $L108779
$L117202:

; 901  : 	{
; 902  : 		// Lightning bolt close on release + movement.
; 903  : 		if( LeftChanged || PosChanged )

  000db	8b 44 24 2c	 mov	 eax, DWORD PTR _PosChanged$[esp+28]
  000df	85 c0		 test	 eax, eax
  000e1	74 2e		 je	 SHORT $L108781
$L108780:

; 904  : 		{
; 905  : 			CloseSpark( MouseX, MouseY );

  000e3	8b 44 24 28	 mov	 eax, DWORD PTR _MouseY$[esp+28]
  000e7	50		 push	 eax
  000e8	53		 push	 ebx
  000e9	8b cf		 mov	 ecx, edi
  000eb	e8 00 00 00 00	 call	 ?CloseSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::CloseSpark
$L108779:

; 906  : 		}
; 907  : 	}
; 908  : 
; 909  :     // Lightning bolt close on non-moving re-clicking.
; 910  : 	if( (!LeftChanged) && (! PosChanged) && LeftButton )

  000f0	8b 44 24 14	 mov	 eax, DWORD PTR _LeftChanged$[esp+32]
  000f4	85 c0		 test	 eax, eax
  000f6	75 19		 jne	 SHORT $L108781
$L117199:
  000f8	8b 44 24 2c	 mov	 eax, DWORD PTR _PosChanged$[esp+28]
  000fc	85 c0		 test	 eax, eax
  000fe	75 11		 jne	 SHORT $L108781
$L117200:
  00100	85 ed		 test	 ebp, ebp
  00102	74 0d		 je	 SHORT $L108781

; 911  : 	{
; 912  : 		CloseSpark( MouseX, MouseY );

  00104	8b 4c 24 28	 mov	 ecx, DWORD PTR _MouseY$[esp+28]
  00108	51		 push	 ecx
  00109	53		 push	 ebx
  0010a	8b cf		 mov	 ecx, edi
  0010c	e8 00 00 00 00	 call	 ?CloseSpark@UFireTexture@@AAEXHH@Z ; UFireTexture::CloseSpark
$L108781:

; 913  : 	}
; 914  : 
; 915  : 	// Delete any sparks within certain range of mouse cursor.
; 916  :     if( RightButton && (PosChanged || RightChanged) )

  00111	85 f6		 test	 esi, esi
  00113	74 77		 je	 SHORT $L117192
  00115	8b 44 24 2c	 mov	 eax, DWORD PTR _PosChanged$[esp+28]
  00119	85 c0		 test	 eax, eax
  0011b	75 08		 jne	 SHORT $L108783
  0011d	8b 44 24 18	 mov	 eax, DWORD PTR _RightChanged$[esp+32]
  00121	85 c0		 test	 eax, eax
  00123	74 67		 je	 SHORT $L117192
$L108783:

; 917  : 	{
; 918  :         DeleteSparks( MouseX, MouseY, DEL_RANGE );

  00125	8b af f8 00 00
	00		 mov	 ebp, DWORD PTR [edi+248]
  0012b	85 ed		 test	 ebp, ebp
  0012d	7e 59		 jle	 SHORT $L117207
  0012f	33 d2		 xor	 edx, edx
  00131	85 ed		 test	 ebp, ebp
  00133	7e 53		 jle	 SHORT $L117207
$L117190:
  00135	8b 87 fc 00 00
	00		 mov	 eax, DWORD PTR [edi+252]
  0013b	0f b6 74 d0 02	 movzx	 esi, BYTE PTR [eax+edx*8+2]
  00140	8b cb		 mov	 ecx, ebx
  00142	2b ce		 sub	 ecx, esi
  00144	79 02		 jns	 SHORT $L117175
  00146	f7 d9		 neg	 ecx
$L117175:
  00148	0f b6 5c d0 03	 movzx	 ebx, BYTE PTR [eax+edx*8+3]
  0014d	8b 74 24 28	 mov	 esi, DWORD PTR _MouseY$[esp+28]
  00151	2b f3		 sub	 esi, ebx
  00153	79 02		 jns	 SHORT $L117181
  00155	f7 de		 neg	 esi
$L117181:
  00157	03 f1		 add	 esi, ecx
  00159	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  0015c	7f 17		 jg	 SHORT $L117191
  0015e	8d 4d ff	 lea	 ecx, DWORD PTR [ebp-1]
  00161	89 8f f8 00 00
	00		 mov	 DWORD PTR [edi+248], ecx
  00167	8b 34 c8	 mov	 esi, DWORD PTR [eax+ecx*8]
  0016a	89 34 d0	 mov	 DWORD PTR [eax+edx*8], esi
  0016d	8b 4c c8 04	 mov	 ecx, DWORD PTR [eax+ecx*8+4]
  00171	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx
$L117191:
  00175	8b af f8 00 00
	00		 mov	 ebp, DWORD PTR [edi+248]
  0017b	8b 5c 24 24	 mov	 ebx, DWORD PTR _MouseX$[esp+28]
  0017f	42		 inc	 edx
  00180	3b d5		 cmp	 edx, ebp
  00182	7c b1		 jl	 SHORT $L117190
  00184	8b 74 24 1c	 mov	 esi, DWORD PTR _RightButton$[esp+32]
$L117207:
  00188	8b 6c 24 10	 mov	 ebp, DWORD PTR _LeftButton$[esp+32]
$L117192:

; 919  : 	}
; 920  : 
; 921  : 	// Remember.
; 922  :     LastMouseX      = MouseX;
; 923  :     LastMouseY      = MouseY;

  0018c	8b 54 24 28	 mov	 edx, DWORD PTR _MouseY$[esp+28]
  00190	5f		 pop	 edi

; 924  :     LastLeftButton  = LeftButton;
; 925  :     LastRightButton = RightButton;

  00191	89 35 00 00 00
	00		 mov	 DWORD PTR ?LastRightButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, esi
  00197	5e		 pop	 esi
  00198	89 2d 00 00 00
	00		 mov	 DWORD PTR ?LastLeftButton@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, ebp
  0019e	5d		 pop	 ebp
  0019f	89 1d 00 00 00
	00		 mov	 DWORD PTR ?LastMouseX@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, ebx
  001a5	89 15 00 00 00
	00		 mov	 DWORD PTR ?LastMouseY@?1??FirePaint@UFireTexture@@AAEXHHK@Z@4HA, edx
  001ab	5b		 pop	 ebx

; 926  : }

  001ac	83 c4 10	 add	 esp, 16			; 00000010H
  001af	c2 0c 00	 ret	 12			; 0000000cH
?FirePaint@UFireTexture@@AAEXHHK@Z ENDP			; UFireTexture::FirePaint
_TEXT	ENDS
PUBLIC	?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z	; UFireTexture::MoveSparkXY
; Function compile flags: /Ogty
;	COMDAT ?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z
_TEXT	SEGMENT
_Spark$ = 8
_Xspeed$ = 12
_Yspeed$ = 16
?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z PROC NEAR ; UFireTexture::MoveSparkXY, COMDAT
; _this$ = ecx

; 1018 : {

  00000	53		 push	 ebx

; 1019 :     if( Xspeed<0 ) // move left

  00001	8a 5c 24 0c	 mov	 bl, BYTE PTR _Xspeed$[esp]
  00005	84 db		 test	 bl, bl
  00007	56		 push	 esi
  00008	8b 74 24 0c	 mov	 esi, DWORD PTR _Spark$[esp+4]
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx
  0000f	7d 51		 jge	 SHORT $L108790

; 1020 :     {
; 1021 :         if( (SpeedRand()&127) < -Xspeed )

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0001d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00023	83 c2 04	 add	 edx, 4
  00026	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0002c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00032	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00038	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0003e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00044	0f be cb	 movsx	 ecx, bl
  00047	f7 d9		 neg	 ecx
  00049	83 e0 7f	 and	 eax, 127		; 0000007fH
  0004c	3b c1		 cmp	 eax, ecx
  0004e	7d 5c		 jge	 SHORT $L108793

; 1022 :             Spark->X = UMask & (Spark->X-1);

  00050	8a 56 02	 mov	 dl, BYTE PTR [esi+2]
  00053	8a 87 c8 00 00
	00		 mov	 al, BYTE PTR [edi+200]
  00059	fe ca		 dec	 dl
  0005b	22 d0		 and	 dl, al
  0005d	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 1023 :     }
; 1024 :     else // move right

  00060	eb 4a		 jmp	 SHORT $L108793
$L108790:

; 1025 :     {
; 1026 :         if( (SpeedRand()&127) <  Xspeed )

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00068	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0006e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00074	83 c2 04	 add	 edx, 4
  00077	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0007d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00083	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00089	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0008f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00095	83 e0 7f	 and	 eax, 127		; 0000007fH
  00098	3a c3		 cmp	 al, bl
  0009a	7d 10		 jge	 SHORT $L108793

; 1027 :             Spark->X = UMask & (Spark->X+1);

  0009c	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  0009f	8a 8f c8 00 00
	00		 mov	 cl, BYTE PTR [edi+200]
  000a5	fe c0		 inc	 al
  000a7	22 c1		 and	 al, cl
  000a9	88 46 02	 mov	 BYTE PTR [esi+2], al
$L108793:

; 1028 :     }
; 1029 : 
; 1030 :     if( Yspeed<0 ) // move up

  000ac	8a 5c 24 18	 mov	 bl, BYTE PTR _Yspeed$[esp+8]
  000b0	84 db		 test	 bl, bl
  000b2	7d 55		 jge	 SHORT $L108794

; 1031 :     {
; 1032 :         if( (SpeedRand()&127) < -Yspeed )

  000b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000c0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000c6	83 c2 04	 add	 edx, 4
  000c9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000cf	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000d5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000db	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000e1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000e7	0f be cb	 movsx	 ecx, bl
  000ea	f7 d9		 neg	 ecx
  000ec	83 e0 7f	 and	 eax, 127		; 0000007fH
  000ef	3b c1		 cmp	 eax, ecx
  000f1	7d 60		 jge	 SHORT $L108797

; 1033 :             Spark->Y = VMask &(Spark->Y-1);

  000f3	8a 56 03	 mov	 dl, BYTE PTR [esi+3]
  000f6	8a 87 cc 00 00
	00		 mov	 al, BYTE PTR [edi+204]
  000fc	fe ca		 dec	 dl
  000fe	22 d0		 and	 dl, al
  00100	5f		 pop	 edi
  00101	88 56 03	 mov	 BYTE PTR [esi+3], dl
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx

; 1039 :     }
; 1040 : }

  00106	c2 0c 00	 ret	 12			; 0000000cH
$L108794:

; 1034 :     }
; 1035 :     else // move down
; 1036 :     {
; 1037 :         if( (SpeedRand()&127) <  Yspeed )

  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0010f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00115	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0011b	83 c2 04	 add	 edx, 4
  0011e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00124	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0012a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00130	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00136	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0013c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0013f	3a c3		 cmp	 al, bl
  00141	7d 10		 jge	 SHORT $L108797

; 1038 : 			Spark->Y = VMask &(Spark->Y+1);

  00143	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  00146	8a 8f cc 00 00
	00		 mov	 cl, BYTE PTR [edi+204]
  0014c	fe c0		 inc	 al
  0014e	22 c1		 and	 al, cl
  00150	88 46 03	 mov	 BYTE PTR [esi+3], al
$L108797:
  00153	5f		 pop	 edi
  00154	5e		 pop	 esi
  00155	5b		 pop	 ebx

; 1039 :     }
; 1040 : }

  00156	c2 0c 00	 ret	 12			; 0000000cH
?MoveSparkXY@UFireTexture@@AAEXPAVFSpark@@CC@Z ENDP	; UFireTexture::MoveSparkXY
_TEXT	ENDS
PUBLIC	?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z	; UFireTexture::MoveSpark
; Function compile flags: /Ogty
;	COMDAT ?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT
_Spark$ = 8
?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z PROC NEAR	; UFireTexture::MoveSpark, COMDAT
; _this$ = ecx

; 1128 : {

  00000	56		 push	 esi

; 1129 :     if( (SBYTE)Spark->ByteA<0 ) // move left

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Spark$[esp]
  00005	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00008	84 c0		 test	 al, al
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	7d 52		 jge	 SHORT $L108803

; 1130 :     {
; 1131 :         if( (SpeedRand()&127) < -(SBYTE)Spark->ByteA )

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0001b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00021	83 c2 04	 add	 edx, 4
  00024	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0002a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00030	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00036	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0003c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00042	0f be 4e 04	 movsx	 ecx, BYTE PTR [esi+4]
  00046	f7 d9		 neg	 ecx
  00048	83 e0 7f	 and	 eax, 127		; 0000007fH
  0004b	3b c1		 cmp	 eax, ecx
  0004d	7d 5f		 jge	 SHORT $L108808

; 1132 :             Spark->X = UMask & (Spark->X-1);

  0004f	8a 56 02	 mov	 dl, BYTE PTR [esi+2]
  00052	8a 87 c8 00 00
	00		 mov	 al, BYTE PTR [edi+200]
  00058	fe ca		 dec	 dl
  0005a	22 d0		 and	 dl, al
  0005c	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 1133 :     }
; 1134 :     else // move right

  0005f	eb 4d		 jmp	 SHORT $L108808
$L108803:

; 1135 :     {
; 1136 :         if( (SpeedRand()&127) <  (SBYTE)Spark->ByteA )

  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0006d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00073	83 c2 04	 add	 edx, 4
  00076	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0007c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00082	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00088	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0008e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00094	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  00097	83 e0 7f	 and	 eax, 127		; 0000007fH
  0009a	3a c1		 cmp	 al, cl
  0009c	7d 10		 jge	 SHORT $L108808

; 1137 :             Spark->X = UMask & (Spark->X+1);

  0009e	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000a1	8a 8f c8 00 00
	00		 mov	 cl, BYTE PTR [edi+200]
  000a7	fe c0		 inc	 al
  000a9	22 c1		 and	 al, cl
  000ab	88 46 02	 mov	 BYTE PTR [esi+2], al
$L108808:

; 1138 :     }
; 1139 : 
; 1140 :     if( (SBYTE)Spark->ByteB<0 ) // move up

  000ae	8a 46 05	 mov	 al, BYTE PTR [esi+5]
  000b1	84 c0		 test	 al, al
  000b3	7d 55		 jge	 SHORT $L108810

; 1141 :     {
; 1142 :         if( (SpeedRand()&127) < -(SBYTE)Spark->ByteB )

  000b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000c1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000c7	83 c2 04	 add	 edx, 4
  000ca	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000d0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000d6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000dc	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000e2	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000e8	0f be 4e 05	 movsx	 ecx, BYTE PTR [esi+5]
  000ec	f7 d9		 neg	 ecx
  000ee	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f1	3b c1		 cmp	 eax, ecx
  000f3	7d 62		 jge	 SHORT $L108815

; 1143 :             Spark->Y = VMask &(Spark->Y-1);

  000f5	8a 56 03	 mov	 dl, BYTE PTR [esi+3]
  000f8	8a 87 cc 00 00
	00		 mov	 al, BYTE PTR [edi+204]
  000fe	fe ca		 dec	 dl
  00100	22 d0		 and	 dl, al
  00102	5f		 pop	 edi
  00103	88 56 03	 mov	 BYTE PTR [esi+3], dl
  00106	5e		 pop	 esi

; 1149 :     }
; 1150 : }

  00107	c2 04 00	 ret	 4
$L108810:

; 1144 :     }
; 1145 :     else // move down
; 1146 :     {
; 1147 :         if( (SpeedRand()&127) <  (SBYTE)Spark->ByteB )

  0010a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00110	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00116	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0011c	83 c2 04	 add	 edx, 4
  0011f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00125	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0012b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00131	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00137	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0013d	8a 4e 05	 mov	 cl, BYTE PTR [esi+5]
  00140	83 e0 7f	 and	 eax, 127		; 0000007fH
  00143	3a c1		 cmp	 al, cl
  00145	7d 10		 jge	 SHORT $L108815

; 1148 : 			Spark->Y = VMask &(Spark->Y+1);

  00147	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  0014a	8a 8f cc 00 00
	00		 mov	 cl, BYTE PTR [edi+204]
  00150	fe c0		 inc	 al
  00152	22 c1		 and	 al, cl
  00154	88 46 03	 mov	 BYTE PTR [esi+3], al
$L108815:
  00157	5f		 pop	 edi
  00158	5e		 pop	 esi

; 1149 :     }
; 1150 : }

  00159	c2 04 00	 ret	 4
?MoveSpark@UFireTexture@@AAEXPAVFSpark@@@Z ENDP		; UFireTexture::MoveSpark
_TEXT	ENDS
PUBLIC	?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z ; UFireTexture::MoveSparkAngle
; Function compile flags: /Ogty
;	COMDAT ?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z
_TEXT	SEGMENT
_Spark$ = 8
_Angle$ = 12
_Ydir$ = 12
?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z PROC NEAR ; UFireTexture::MoveSparkAngle, COMDAT
; _this$ = ecx

; 1157 : 
; 1158 : 	SBYTE Xdir = -127 + (SBYTE)PhaseTable[ Angle ];

  00000	8a 44 24 08	 mov	 al, BYTE PTR _Angle$[esp-4]
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1159 :     SBYTE Ydir = -127 + (SBYTE)PhaseTable[ BYTE(Angle+64 ) ];
; 1160 : 
; 1161 :     if( (SBYTE)Xdir<0 ) 

  00006	8b 74 24 0c	 mov	 esi, DWORD PTR _Spark$[esp+4]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	33 c9		 xor	 ecx, ecx
  0000f	8a c8		 mov	 cl, al
  00011	04 40		 add	 al, 64			; 00000040H
  00013	33 d2		 xor	 edx, edx
  00015	8a d0		 mov	 dl, al
  00017	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  0001d	80 eb 7f	 sub	 bl, 127			; 0000007fH
  00020	8a 82 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[edx]
  00026	2c 7f		 sub	 al, 127			; 0000007fH
  00028	84 db		 test	 bl, bl
  0002a	88 44 24 14	 mov	 BYTE PTR _Ydir$[esp+8], al
  0002e	7d 51		 jge	 SHORT $L108826

; 1162 :     {
; 1163 : 		// Move left.
; 1164 :         if( (SpeedRand()&127) < -(SBYTE)Xdir )

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00036	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0003c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00042	83 c2 04	 add	 edx, 4
  00045	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0004b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00051	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00057	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0005d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00063	0f be cb	 movsx	 ecx, bl
  00066	f7 d9		 neg	 ecx
  00068	83 e0 7f	 and	 eax, 127		; 0000007fH
  0006b	3b c1		 cmp	 eax, ecx
  0006d	7d 5c		 jge	 SHORT $L108831

; 1165 :              Spark->X = UMask & ( Spark->X-1);

  0006f	8a 56 02	 mov	 dl, BYTE PTR [esi+2]
  00072	8a 87 c8 00 00
	00		 mov	 al, BYTE PTR [edi+200]
  00078	fe ca		 dec	 dl
  0007a	22 d0		 and	 dl, al
  0007c	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 1166 :     }
; 1167 :     else 

  0007f	eb 4a		 jmp	 SHORT $L108831
$L108826:

; 1168 :     {
; 1169 : 		// Move right.
; 1170 :         if( (SpeedRand()&127) <  (SBYTE)Xdir )

  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00087	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0008d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00093	83 c2 04	 add	 edx, 4
  00096	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0009c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000a2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000a8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000ae	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000b4	83 e0 7f	 and	 eax, 127		; 0000007fH
  000b7	3a c3		 cmp	 al, bl
  000b9	7d 10		 jge	 SHORT $L108831

; 1171 :              Spark->X = UMask & ( Spark->X+1);

  000bb	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000be	8a 8f c8 00 00
	00		 mov	 cl, BYTE PTR [edi+200]
  000c4	fe c0		 inc	 al
  000c6	22 c1		 and	 al, cl
  000c8	88 46 02	 mov	 BYTE PTR [esi+2], al
$L108831:

; 1172 :     }
; 1173 : 
; 1174 :     if( (SBYTE)Ydir<0 ) 

  000cb	8a 5c 24 14	 mov	 bl, BYTE PTR _Ydir$[esp+8]
  000cf	84 db		 test	 bl, bl
  000d1	7d 55		 jge	 SHORT $L108833

; 1175 :     {
; 1176 : 		// Move up.
; 1177 :         if( (SpeedRand()&127) < -(SBYTE)Ydir )

  000d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000df	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000e5	83 c2 04	 add	 edx, 4
  000e8	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000ee	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000f4	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000fa	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00100	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00106	0f be cb	 movsx	 ecx, bl
  00109	f7 d9		 neg	 ecx
  0010b	83 e0 7f	 and	 eax, 127		; 0000007fH
  0010e	3b c1		 cmp	 eax, ecx
  00110	7d 60		 jge	 SHORT $L108838

; 1178 :              Spark->Y = VMask &( Spark->Y-1);

  00112	8a 56 03	 mov	 dl, BYTE PTR [esi+3]
  00115	8a 87 cc 00 00
	00		 mov	 al, BYTE PTR [edi+204]
  0011b	fe ca		 dec	 dl
  0011d	22 c2		 and	 al, dl
  0011f	5f		 pop	 edi
  00120	88 46 03	 mov	 BYTE PTR [esi+3], al
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx

; 1185 :     }
; 1186 : }

  00125	c2 08 00	 ret	 8
$L108833:

; 1179 :     }
; 1180 :     else 
; 1181 :     {
; 1182 : 		// Move down.
; 1183 :         if( (SpeedRand()&127) <  (SBYTE)Ydir )

  00128	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0012e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00134	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0013a	83 c2 04	 add	 edx, 4
  0013d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00143	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00149	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0014f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00155	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0015b	83 e0 7f	 and	 eax, 127		; 0000007fH
  0015e	3a c3		 cmp	 al, bl
  00160	7d 10		 jge	 SHORT $L108838

; 1184 : 			 Spark->Y = VMask &( Spark->Y+1);

  00162	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  00165	8a 97 cc 00 00
	00		 mov	 dl, BYTE PTR [edi+204]
  0016b	fe c1		 inc	 cl
  0016d	22 d1		 and	 dl, cl
  0016f	88 56 03	 mov	 BYTE PTR [esi+3], dl
$L108838:
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx

; 1185 :     }
; 1186 : }

  00175	c2 08 00	 ret	 8
?MoveSparkAngle@UFireTexture@@AAEXPAVFSpark@@E@Z ENDP	; UFireTexture::MoveSparkAngle
_TEXT	ENDS
PUBLIC	?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z	; UFireTexture::MoveSparkTwo
; Function compile flags: /Ogty
;	COMDAT ?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z
_TEXT	SEGMENT
_Spark$ = 8
?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z PROC NEAR	; UFireTexture::MoveSparkTwo, COMDAT
; _this$ = ecx

; 1190 : {    

  00000	56		 push	 esi

; 1191 :     if( (SBYTE)Spark->ByteA<0 ) 

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Spark$[esp]
  00005	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00008	84 c0		 test	 al, al
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	7d 52		 jge	 SHORT $L108844

; 1192 :     {
; 1193 : 		// Negative update.
; 1194 :         if( (SpeedRand()&127) < -(SBYTE)Spark->ByteA )

  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00015	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0001b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00021	83 c2 04	 add	 edx, 4
  00024	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0002a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00030	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00036	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0003c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00042	0f be 4e 04	 movsx	 ecx, BYTE PTR [esi+4]
  00046	f7 d9		 neg	 ecx
  00048	83 e0 7f	 and	 eax, 127		; 0000007fH
  0004b	3b c1		 cmp	 eax, ecx
  0004d	7d 5f		 jge	 SHORT $L108849

; 1195 :             Spark->X = UMask & (Spark->X-1);

  0004f	8a 56 02	 mov	 dl, BYTE PTR [esi+2]
  00052	8a 87 c8 00 00
	00		 mov	 al, BYTE PTR [edi+200]
  00058	fe ca		 dec	 dl
  0005a	22 d0		 and	 dl, al
  0005c	88 56 02	 mov	 BYTE PTR [esi+2], dl

; 1196 :     }
; 1197 :     else    

  0005f	eb 4d		 jmp	 SHORT $L108849
$L108844:

; 1198 :     {
; 1199 : 		// Positive update.
; 1200 :         if( (SpeedRand()&127) <  (SBYTE)Spark->ByteA )

  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0006d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00073	83 c2 04	 add	 edx, 4
  00076	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0007c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00082	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00088	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0008e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00094	8a 4e 04	 mov	 cl, BYTE PTR [esi+4]
  00097	83 e0 7f	 and	 eax, 127		; 0000007fH
  0009a	3a c1		 cmp	 al, cl
  0009c	7d 10		 jge	 SHORT $L108849

; 1201 :             Spark->X = UMask & (Spark->X+1);

  0009e	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  000a1	8a 8f c8 00 00
	00		 mov	 cl, BYTE PTR [edi+200]
  000a7	fe c0		 inc	 al
  000a9	22 c1		 and	 al, cl
  000ab	88 46 02	 mov	 BYTE PTR [esi+2], al
$L108849:

; 1202 :     }
; 1203 :     Spark->Y = VMask &(Spark->Y-2);

  000ae	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  000b1	8a 87 cc 00 00
	00		 mov	 al, BYTE PTR [edi+204]
  000b7	80 e9 02	 sub	 cl, 2
  000ba	22 c8		 and	 cl, al
  000bc	5f		 pop	 edi
  000bd	88 4e 03	 mov	 BYTE PTR [esi+3], cl
  000c0	5e		 pop	 esi

; 1204 : }

  000c1	c2 04 00	 ret	 4
?MoveSparkTwo@UFireTexture@@AAEXPAVFSpark@@@Z ENDP	; UFireTexture::MoveSparkTwo
_TEXT	ENDS
PUBLIC	??2@YAPAXI@Z					; operator new
PUBLIC	??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@		; `string'
EXTRN	__imp_?GMalloc@@3PAVFMalloc@@A:DWORD
;	COMDAT ??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@
; File ..\..\Core\Inc\UnFile.h
_DATA	SEGMENT
??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ DB 'n', 00H, 'e', 00H, 'w', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ??2@YAPAXI@Z
_TEXT	SEGMENT
_Size$ = 8
??2@YAPAXI@Z PROC NEAR					; operator new, COMDAT

; 624  : 	return appMalloc( Size, TEXT("new") );

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _Size$[esp-4]
  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00012	50		 push	 eax
  00013	ff 12		 call	 DWORD PTR [edx]

; 625  : }

  00015	c3		 ret	 0
??2@YAPAXI@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z	; UFireTexture::DrawFlashRamp
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
;	COMDAT ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z
_TEXT	SEGMENT
_LL$ = 8
_Color1$ = 12
_Color2$ = 16
_FlashArray$ = -256
_Xstep$ = -276
_Ystep$ = -280
_RealYlen$ = -264
_FlashPos$ = -284
_ColorSlope$ = -260
_FlashBias$108880 = -280
_FlashBias$108887 = -276
?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z PROC NEAR ; UFireTexture::DrawFlashRamp, COMDAT
; _this$ = ecx

; 1209 : {

  00000	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00006	53		 push	 ebx

; 1210 :     DWORD	SparkDest;
; 1211 :     BYTE	FlashArray[256];
; 1212 : 	INT  Xstep,Ystep,RealYlen,RealXlen;
; 1213 : 
; 1214 : 	// Make writing cache-friendlier by drawing approximately to the right or downwards.
; 1215 : 
; 1216 : 	if( ( ( LL.Ylen & 1 ) && ((LL.Ylen*2) >= LL.Xlen ) ) || 
; 1217 : 	     ( ( LL.Xlen & 1 ) && ((LL.Ylen*2) <  LL.Xlen ) ) )

  00007	8a 9c 24 2b 01
	00 00		 mov	 bl, BYTE PTR _LL$[esp+291]
  0000e	55		 push	 ebp
  0000f	8a c3		 mov	 al, bl
  00011	56		 push	 esi
  00012	24 01		 and	 al, 1
  00014	8b f1		 mov	 esi, ecx
  00016	8a 8c 24 32 01
	00 00		 mov	 cl, BYTE PTR _LL$[esp+298]
  0001d	57		 push	 edi
  0001e	88 44 24 13	 mov	 BYTE PTR -285+[esp+304], al
  00022	74 0e		 je	 SHORT $L108864
  00024	33 c0		 xor	 eax, eax
  00026	8a c1		 mov	 al, cl
  00028	0f b6 fb	 movzx	 edi, bl
  0002b	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  0002e	3b d0		 cmp	 edx, eax
  00030	7d 13		 jge	 SHORT $L108863
$L108864:
  00032	f6 c1 01	 test	 cl, 1
  00035	74 6a		 je	 SHORT $L108862
  00037	33 c0		 xor	 eax, eax
  00039	8a c1		 mov	 al, cl
  0003b	0f b6 fb	 movzx	 edi, bl
  0003e	8d 14 3f	 lea	 edx, DWORD PTR [edi+edi]
  00041	3b d0		 cmp	 edx, eax
  00043	7d 5c		 jge	 SHORT $L108862
$L108863:

; 1218 :     {
; 1219 : 		LL.Xpos = LL.Xpos + ((LL.Xlen & 1)? -LL.Xlen:LL.Xlen );

  00045	f6 c1 01	 test	 cl, 1
  00048	74 02		 je	 SHORT $L117288
  0004a	f7 d8		 neg	 eax
$L117288:
  0004c	8a 94 24 34 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+300]
  00053	02 d0		 add	 dl, al

; 1220 : 		LL.Ypos = LL.Ypos + ((LL.Ylen & 1)? -LL.Ylen:LL.Ylen );

  00055	8a 44 24 13	 mov	 al, BYTE PTR -285+[esp+304]
  00059	84 c0		 test	 al, al
  0005b	88 94 24 34 01
	00 00		 mov	 BYTE PTR _LL$[esp+300], dl
  00062	74 02		 je	 SHORT $L117289
  00064	f7 df		 neg	 edi
$L117289:
  00066	8a 94 24 35 01
	00 00		 mov	 dl, BYTE PTR _LL$[esp+301]
  0006d	8b c7		 mov	 eax, edi
  0006f	02 d0		 add	 dl, al

; 1221 : 		LL.Xlen ^=1;
; 1222 : 		LL.Ylen ^=1;	
; 1223 : 		BYTE Tcol = Color1;

  00071	8a 84 24 38 01
	00 00		 mov	 al, BYTE PTR _Color1$[esp+300]
  00078	88 94 24 35 01
	00 00		 mov	 BYTE PTR _LL$[esp+301], dl

; 1224 : 		Color1 = Color2;

  0007f	8a 94 24 3c 01
	00 00		 mov	 dl, BYTE PTR _Color2$[esp+300]
  00086	80 f1 01	 xor	 cl, 1
  00089	88 8c 24 36 01
	00 00		 mov	 BYTE PTR _LL$[esp+302], cl
  00090	80 f3 01	 xor	 bl, 1
  00093	88 94 24 38 01
	00 00		 mov	 BYTE PTR _Color1$[esp+300], dl

; 1225 : 		Color2 = Tcol;

  0009a	88 84 24 3c 01
	00 00		 mov	 BYTE PTR _Color2$[esp+300], al
$L108862:

; 1226 :     }
; 1227 : 
; 1228 : 	INT MajorLen = 1 | ( (LL.Xlen >= LL.Ylen) ?  LL.Xlen : LL.Ylen );

  000a1	3a cb		 cmp	 cl, bl
  000a3	8a c1		 mov	 al, cl
  000a5	73 02		 jae	 SHORT $L117292
  000a7	8a c3		 mov	 al, bl
$L117292:
  000a9	0f b6 e8	 movzx	 ebp, al
  000ac	83 cd 01	 or	 ebp, 1

; 1229 : 
; 1230 :     // Fill array for the specific length.
; 1231 :     INT  FlashPos=0;

  000af	bf 00 00 00 00	 mov	 edi, 0
  000b4	89 7c 24 14	 mov	 DWORD PTR _FlashPos$[esp+304], edi

; 1232 :     for( INT Flash=0; Flash<MajorLen; Flash++ )

  000b8	7e 56		 jle	 SHORT $L108871

; 1301 : 		}
; 1302 :     }
; 1303 : }

  000ba	8d 9b 00 00 00
	00		 npad	 6
$L108869:

; 1233 :     {
; 1234 :         FlashPos += ( FlashArray[Flash] = SpeedRand() );

  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000cc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000d2	83 c2 04	 add	 edx, 4
  000d5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000db	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000e1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000e7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000ed	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000f3	8b 54 24 14	 mov	 edx, DWORD PTR _FlashPos$[esp+304]
  000f7	88 44 3c 30	 mov	 BYTE PTR _FlashArray$[esp+edi+304], al
  000fb	0f b6 c0	 movzx	 eax, al
  000fe	03 d0		 add	 edx, eax
  00100	47		 inc	 edi
  00101	3b fd		 cmp	 edi, ebp
  00103	89 54 24 14	 mov	 DWORD PTR _FlashPos$[esp+304], edx
  00107	7c b7		 jl	 SHORT $L108869

; 1232 :     for( INT Flash=0; Flash<MajorLen; Flash++ )

  00109	8a 8c 24 36 01
	00 00		 mov	 cl, BYTE PTR _LL$[esp+302]
$L108871:

; 1235 :     }
; 1236 : 
; 1237 : 	if( LL.Ylen & 1 )
; 1238 : 	{
; 1239 : 		Ystep = -1;
; 1240 : 		RealYlen = -LL.Ylen;

  00110	33 c0		 xor	 eax, eax
  00112	8a c3		 mov	 al, bl
  00114	83 ca ff	 or	 edx, -1
  00117	f6 c3 01	 test	 bl, 1
  0011a	89 44 24 24	 mov	 DWORD PTR -268+[esp+304], eax
  0011e	74 08		 je	 SHORT $L108872
  00120	89 54 24 18	 mov	 DWORD PTR _Ystep$[esp+304], edx
  00124	f7 d8		 neg	 eax

; 1241 : 	}
; 1242 : 	else

  00126	eb 08		 jmp	 SHORT $L117319
$L108872:

; 1243 : 	{
; 1244 : 		Ystep = 1;

  00128	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR _Ystep$[esp+304], 1
$L117319:

; 1245 : 		RealYlen =  LL.Ylen;
; 1246 : 	}
; 1247 : 
; 1248 : 
; 1249 : 	if( LL.Xlen & 1 )

  00130	f6 c1 01	 test	 cl, 1

; 1250 : 	{
; 1251 : 		Xstep = -1;
; 1252 : 		RealXlen = -LL.Xlen;

  00133	0f b6 c9	 movzx	 ecx, cl
  00136	89 44 24 28	 mov	 DWORD PTR _RealYlen$[esp+304], eax
  0013a	89 4c 24 20	 mov	 DWORD PTR -272+[esp+304], ecx
  0013e	74 08		 je	 SHORT $L108874
  00140	89 54 24 1c	 mov	 DWORD PTR _Xstep$[esp+304], edx
  00144	f7 d9		 neg	 ecx

; 1253 : 	}
; 1254 : 	else

  00146	eb 08		 jmp	 SHORT $L108875
$L108874:

; 1255 : 	{
; 1256 : 		Xstep = 1;

  00148	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _Xstep$[esp+304], 1
$L108875:

; 1257 : 		RealXlen =  LL.Xlen;
; 1258 : 	}
; 1259 : 
; 1260 : 
; 1261 : 	//  Setup color ramp.
; 1262 : 	INT RampColor  =  Color1 << 23 ;

  00150	0f b6 94 24 38
	01 00 00	 movzx	 edx, BYTE PTR _Color1$[esp+300]

; 1263 : 	INT ColorSlope =  ((Color2 - Color1 ) << 23 ) / MajorLen;

  00158	0f b6 84 24 3c
	01 00 00	 movzx	 eax, BYTE PTR _Color2$[esp+300]
  00160	2b c2		 sub	 eax, edx
  00162	c1 e0 17	 shl	 eax, 23			; 00000017H
  00165	8b fa		 mov	 edi, edx
  00167	99		 cdq
  00168	f7 fd		 idiv	 ebp
  0016a	c1 e7 17	 shl	 edi, 23			; 00000017H
  0016d	89 44 24 2c	 mov	 DWORD PTR _ColorSlope$[esp+304], eax

; 1264 :     
; 1265 : 
; 1266 :     if( LL.Xlen>=LL.Ylen )

  00171	38 9c 24 36 01
	00 00		 cmp	 BYTE PTR _LL$[esp+302], bl
  00178	0f 82 98 00 00
	00		 jb	 $L108878

; 1267 :     {
; 1268 :         // X major axis.
; 1269 :         // calculate BIAS:
; 1270 :         // Bias = (Ylen << 6) - FlashPos;
; 1271 : 
; 1272 :         INT  Ypoz = (LL.Ypos << 6);
; 1273 :         INT  FlashBias = (( (INT)RealYlen << 6) - FlashPos) / MajorLen;  

  0017e	8b 44 24 28	 mov	 eax, DWORD PTR _RealYlen$[esp+304]
  00182	8b 4c 24 14	 mov	 ecx, DWORD PTR _FlashPos$[esp+304]
  00186	c1 e0 06	 shl	 eax, 6
  00189	2b c1		 sub	 eax, ecx
  0018b	99		 cdq
  0018c	f7 fd		 idiv	 ebp
  0018e	0f b6 9c 24 35
	01 00 00	 movzx	 ebx, BYTE PTR _LL$[esp+301]
  00196	c1 e3 06	 shl	 ebx, 6

; 1274 : 
; 1275 :         //
; 1276 :         for( Flash=0; Flash<LL.Xlen; Flash++ )

  00199	33 ed		 xor	 ebp, ebp
  0019b	89 44 24 18	 mov	 DWORD PTR _FlashBias$108880[esp+304], eax
  0019f	8b 44 24 20	 mov	 eax, DWORD PTR -272+[esp+304]
  001a3	85 c0		 test	 eax, eax
  001a5	0f 8e f0 00 00
	00		 jle	 $L108891

; 1301 : 		}
; 1302 :     }
; 1303 : }

  001ab	90 8d 64 24 00	 npad	 5
$L108882:

; 1277 :         {
; 1278 : 			Ypoz += FlashArray[Flash] + FlashBias;

  001b0	0f b6 4c 2c 30	 movzx	 ecx, BYTE PTR _FlashArray$[esp+ebp+304]
  001b5	03 4c 24 18	 add	 ecx, DWORD PTR _FlashBias$108880[esp+304]

; 1279 : 			SparkDest = (((Ypoz >> 6) & VMask) << UBits) + (LL.Xpos & UMask);

  001b9	8a 84 24 34 01
	00 00		 mov	 al, BYTE PTR _LL$[esp+300]
  001c0	03 d9		 add	 ebx, ecx
  001c2	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  001c8	8b d3		 mov	 edx, ebx
  001ca	c1 fa 06	 sar	 edx, 6
  001cd	23 d1		 and	 edx, ecx
  001cf	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  001d2	d3 e2		 shl	 edx, cl
  001d4	33 c9		 xor	 ecx, ecx
  001d6	8a c8		 mov	 cl, al
  001d8	23 8e c8 00 00
	00		 and	 ecx, DWORD PTR [esi+200]
  001de	03 d1		 add	 edx, ecx

; 1280 : 			LL.Xpos += Xstep;   // increase X

  001e0	02 44 24 1c	 add	 al, BYTE PTR _Xstep$[esp+304]

; 1281 : 			Mips(0).DataArray(SparkDest) = ( (RampColor += ColorSlope) >> 23 );

  001e4	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  001ea	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  001ed	88 84 24 34 01
	00 00		 mov	 BYTE PTR _LL$[esp+300], al
  001f4	03 7c 24 2c	 add	 edi, DWORD PTR _ColorSlope$[esp+304]
  001f8	8b c7		 mov	 eax, edi
  001fa	c1 f8 17	 sar	 eax, 23			; 00000017H
  001fd	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00200	8b 44 24 20	 mov	 eax, DWORD PTR -272+[esp+304]
  00204	45		 inc	 ebp
  00205	3b e8		 cmp	 ebp, eax
  00207	7c a7		 jl	 SHORT $L108882
  00209	5f		 pop	 edi
  0020a	5e		 pop	 esi
  0020b	5d		 pop	 ebp
  0020c	5b		 pop	 ebx

; 1301 : 		}
; 1302 :     }
; 1303 : }

  0020d	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  00213	c2 0c 00	 ret	 12			; 0000000cH
$L108878:

; 1282 :         }
; 1283 : 
; 1284 :     }
; 1285 :     else
; 1286 :     {
; 1287 :         //  Y major axis.
; 1288 :         //  calculate BIAS:
; 1289 :         //  Bias = (Xlen << 6) - FlashPos;
; 1290 : 
; 1291 :         INT  Xpoz = (LL.Xpos << 6);
; 1292 :         INT  FlashBias = (( (INT)RealXlen << 6) - FlashPos) / MajorLen;   

  00216	8b c1		 mov	 eax, ecx
  00218	8b 4c 24 14	 mov	 ecx, DWORD PTR _FlashPos$[esp+304]
  0021c	c1 e0 06	 shl	 eax, 6
  0021f	2b c1		 sub	 eax, ecx
  00221	99		 cdq
  00222	f7 fd		 idiv	 ebp
  00224	0f b6 9c 24 34
	01 00 00	 movzx	 ebx, BYTE PTR _LL$[esp+300]
  0022c	c1 e3 06	 shl	 ebx, 6

; 1293 : 
; 1294 :         //
; 1295 :         for( Flash=0; Flash<LL.Ylen; Flash++ )

  0022f	33 ed		 xor	 ebp, ebp
  00231	89 44 24 1c	 mov	 DWORD PTR _FlashBias$108887[esp+304], eax
  00235	8b 44 24 24	 mov	 eax, DWORD PTR -268+[esp+304]
  00239	85 c0		 test	 eax, eax
  0023b	7e 5e		 jle	 SHORT $L108891

; 1301 : 		}
; 1302 :     }
; 1303 : }

  0023d	8d 49 00	 npad	 3
$L108889:

; 1296 :         {
; 1297 : 			Xpoz += FlashArray[Flash] + FlashBias;

  00240	0f b6 54 2c 30	 movzx	 edx, BYTE PTR _FlashArray$[esp+ebp+304]
  00245	8b 4c 24 1c	 mov	 ecx, DWORD PTR _FlashBias$108887[esp+304]

; 1298 : 			SparkDest = ( (LL.Ypos & VMask) << UBits) + ((Xpoz >> 6) & UMask);

  00249	8a 84 24 35 01
	00 00		 mov	 al, BYTE PTR _LL$[esp+301]
  00250	03 d1		 add	 edx, ecx
  00252	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  00258	03 da		 add	 ebx, edx
  0025a	33 d2		 xor	 edx, edx
  0025c	8a d0		 mov	 dl, al
  0025e	23 d1		 and	 edx, ecx
  00260	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00263	d3 e2		 shl	 edx, cl
  00265	8b cb		 mov	 ecx, ebx
  00267	c1 f9 06	 sar	 ecx, 6
  0026a	23 8e c8 00 00
	00		 and	 ecx, DWORD PTR [esi+200]
  00270	03 d1		 add	 edx, ecx

; 1299 : 			LL.Ypos += Ystep;   // increase Y

  00272	02 44 24 18	 add	 al, BYTE PTR _Ystep$[esp+304]

; 1300 : 			Mips(0).DataArray(SparkDest) = ((RampColor += ColorSlope) >> 23);

  00276	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0027c	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0027f	88 84 24 35 01
	00 00		 mov	 BYTE PTR _LL$[esp+301], al
  00286	03 7c 24 2c	 add	 edi, DWORD PTR _ColorSlope$[esp+304]
  0028a	8b c7		 mov	 eax, edi
  0028c	c1 f8 17	 sar	 eax, 23			; 00000017H
  0028f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00292	8b 44 24 24	 mov	 eax, DWORD PTR -268+[esp+304]
  00296	45		 inc	 ebp
  00297	3b e8		 cmp	 ebp, eax
  00299	7c a5		 jl	 SHORT $L108889
$L108891:
  0029b	5f		 pop	 edi
  0029c	5e		 pop	 esi
  0029d	5d		 pop	 ebp
  0029e	5b		 pop	 ebx

; 1301 : 		}
; 1302 :     }
; 1303 : }

  0029f	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  002a5	c2 0c 00	 ret	 12			; 0000000cH
?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ENDP	; UFireTexture::DrawFlashRamp
_TEXT	ENDS
PUBLIC	??3@YAXPAX@Z					; operator delete
; Function compile flags: /Ogty
; File ..\..\Core\Inc\UnFile.h
;	COMDAT ??3@YAXPAX@Z
_TEXT	SEGMENT
_Ptr$ = 8
??3@YAXPAX@Z PROC NEAR					; operator delete, COMDAT

; 628  : 	appFree( Ptr );

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 44 24 04	 mov	 eax, DWORD PTR _Ptr$[esp-4]
  0000b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000d	50		 push	 eax
  0000e	ff 52 08	 call	 DWORD PTR [edx+8]

; 629  : }

  00011	c3		 ret	 0
??3@YAXPAX@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?RedrawSparks@UFireTexture@@AAEXXZ		; UFireTexture::RedrawSparks
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
;	COMDAT ?RedrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT
_Htemp$108934 = -37
_LL$109038 = -28
_HeatA$109039 = -16
_LL$109045 = -24
_HeatA$109046 = -12
_SparkAngle$109052 = -32
_Col1$109054 = -4
_Col2$109055 = -8
_LL$109060 = -20
_TempSpeedY$109134 = -37
_TempSpeedY$109144 = -37
_Ydir$118454 = -37
?RedrawSparks@UFireTexture@@AAEXXZ PROC NEAR		; UFireTexture::RedrawSparks, COMDAT
; _this$ = ecx

; 1315 : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 1316 : 	AuxPhase += FX_Frequency;  

  00008	8a 96 dd 00 00
	00		 mov	 dl, BYTE PTR [esi+221]
  0000e	8a 86 ec 00 00
	00		 mov	 al, BYTE PTR [esi+236]

; 1317 : 	GlobalPhase++;

  00014	8b 8e d8 00 00
	00		 mov	 ecx, DWORD PTR [esi+216]

; 1318 : 
; 1319 : 	// Warning: On any movement or new creation, the integrity of a spark's coordinates
; 1320 :     // must be assured by using UMask and VMask.
; 1321 :     
; 1322 :     for( INT S=0; S<ActiveSparkNum; S++ )

  0001a	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  00020	02 d0		 add	 dl, al
  00022	41		 inc	 ecx
  00023	33 ed		 xor	 ebp, ebp
  00025	85 db		 test	 ebx, ebx
  00027	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  0002d	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  00033	0f 8e 5e 30 00
	00		 jle	 $L108898
  00039	57		 push	 edi

; 2031 : 			break;
; 2032 : 
; 2033 :         } //Switch.
; 2034 : 	}
; 2035 : }

  0003a	8d 9b 00 00 00
	00		 npad	 6
$L108896:

; 1323 : 	{
; 1324 :         FSpark* ThisSpark = &(Sparks(S));

  00040	8b be fc 00 00
	00		 mov	 edi, DWORD PTR [esi+252]

; 1325 : 
; 1326 :         switch( ThisSpark->Type )
; 1327 :         {

  00046	0f b6 04 ef	 movzx	 eax, BYTE PTR [edi+ebp*8]
  0004a	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0004d	0f 87 34 30 00
	00		 ja	 $L108897
  00053	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L118581[eax*4]
$L108904:

; 1328 :         
; 1329 :         case SPARK_Burn:
; 1330 : 			{
; 1331 : 				DWORD SparkDest = (DWORD)(ThisSpark->X + (ThisSpark->Y << UBits) );

  0005a	0f b6 5c ef 03	 movzx	 ebx, BYTE PTR [edi+ebp*8+3]
  0005f	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00062	d3 e3		 shl	 ebx, cl
  00064	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  00069	03 d9		 add	 ebx, ecx

; 1332 : 				Mips(0).DataArray(SparkDest) = SpeedRand();  

  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00071	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00077	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0007d	83 c2 04	 add	 edx, 4
  00080	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00086	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0008c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00092	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00098	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0009e	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  000a4	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  000a7	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al

; 1333 : 				break;

  000aa	e9 d8 2f 00 00	 jmp	 $L108897
$L108907:

; 1334 : 			}
; 1335 : 
; 1336 :         case SPARK_Sparkle: // Normal spark with positional jitter.
; 1337 : 			{
; 1338 : 				DWORD NewSparkX = ( ThisSpark->X + (( SpeedRand() * ThisSpark->ByteA ) >> 8 ) );

  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000b5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  000bb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000c1	83 c2 04	 add	 edx, 4
  000c4	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  000ca	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  000d0	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  000d6	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  000dc	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  000e2	0f b6 5c ef 04	 movzx	 ebx, BYTE PTR [edi+ebp*8+4]
  000e7	33 d2		 xor	 edx, edx
  000e9	8a d0		 mov	 dl, al
  000eb	0f b6 44 ef 02	 movzx	 eax, BYTE PTR [edi+ebp*8+2]
  000f0	0f af da	 imul	 ebx, edx
  000f3	c1 fb 08	 sar	 ebx, 8
  000f6	03 d8		 add	 ebx, eax

; 1339 : 				DWORD NewSparkY = ( ThisSpark->Y + (( SpeedRand() * ThisSpark->ByteB ) >> 8 ) );

  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  000fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00104	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0010a	83 c2 04	 add	 edx, 4
  0010d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00113	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00119	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0011f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00125	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1340 : 				DWORD SparkDest = (DWORD)( (UMask & NewSparkX) + ( (VMask & NewSparkY) << UBits  ) );
; 1341 : 				Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  0012b	0f b6 54 ef 05	 movzx	 edx, BYTE PTR [edi+ebp*8+5]
  00130	0f b6 4c ef 03	 movzx	 ecx, BYTE PTR [edi+ebp*8+3]
  00135	0f b6 c0	 movzx	 eax, al
  00138	0f af d0	 imul	 edx, eax
  0013b	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  00141	c1 fa 08	 sar	 edx, 8
  00144	03 d1		 add	 edx, ecx
  00146	23 96 cc 00 00
	00		 and	 edx, DWORD PTR [esi+204]
  0014c	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0014f	d3 e2		 shl	 edx, cl
  00151	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00157	23 c3		 and	 eax, ebx
  00159	03 d0		 add	 edx, eax
  0015b	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0015e	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00162	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 1342 : 				break;

  00165	e9 1d 2f 00 00	 jmp	 $L108897
$L108912:

; 1343 : 			}
; 1344 : 
; 1345 :         case SPARK_Pulse: // Phased sparks.
; 1346 : 			{
; 1347 : 				DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1348 : 				Mips(0).DataArray(SparkDest) = (BYTE) ThisSpark->Heat;

  0016a	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  0016f	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00172	d3 e2		 shl	 edx, cl
  00174	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0017a	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  0017d	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  00182	8d 44 ef 01	 lea	 eax, DWORD PTR [edi+ebp*8+1]
  00186	03 d3		 add	 edx, ebx
  00188	8a 18		 mov	 bl, BYTE PTR [eax]
  0018a	88 1c 0a	 mov	 BYTE PTR [edx+ecx], bl

; 1349 : 				ThisSpark->Heat +=ThisSpark->ByteD;

  0018d	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  00191	8a 08		 mov	 cl, BYTE PTR [eax]
  00193	02 ca		 add	 cl, dl

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  00195	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  00197	e9 eb 2e 00 00	 jmp	 $L108897
$L108916:

; 1350 : 				break;
; 1351 : 			}
; 1352 : 
; 1353 :         case SPARK_Signal: // Pulse-phased sparks.
; 1354 : 			{
; 1355 : 				DWORD SparkDest = (DWORD)(ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1356 : 
; 1357 : 				if( ThisSpark->Heat > ThisSpark->ByteC )

  0019c	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  001a0	3a 44 ef 06	 cmp	 al, BYTE PTR [edi+ebp*8+6]
  001a4	8d 5c ef 01	 lea	 ebx, DWORD PTR [edi+ebp*8+1]
  001a8	76 1b		 jbe	 SHORT $L108919

; 1358 : 					Mips(0).DataArray(SparkDest) = (BYTE) ThisSpark->Heat;

  001aa	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  001af	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  001b2	d3 e2		 shl	 edx, cl
  001b4	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  001ba	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  001bd	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  001c2	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
$L108919:

; 1359 : 
; 1360 : 				if( (ThisSpark->Heat +=ThisSpark->ByteD) < ThisSpark->ByteD ) 

  001c5	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  001c9	8a 13		 mov	 dl, BYTE PTR [ebx]
  001cb	02 d0		 add	 dl, al
  001cd	8a ca		 mov	 cl, dl
  001cf	3a c8		 cmp	 cl, al
  001d1	88 13		 mov	 BYTE PTR [ebx], dl
  001d3	0f 83 ae 2e 00
	00		 jae	 $L108897

; 1361 : 					ThisSpark->Heat = SpeedRand(); // Renew phase...

  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  001df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  001e5	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  001eb	83 c2 04	 add	 edx, 4
  001ee	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  001f4	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  001fa	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00200	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00206	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  0020c	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  0020e	e9 74 2e 00 00	 jmp	 $L108897
$L108922:

; 1362 : 				break;
; 1363 : 			}
; 1364 : 	
; 1365 : 		case SPARK_Cylinder: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1366 :             {  
; 1367 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1368 : 				// 'Z' distance suggested by brightness.
; 1369 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1370 : 
; 1371 : 				BYTE Htemp = Min( PhaseTable[ (ThisSpark->ByteA+64) & 255 ] +  ThisSpark->Heat, 255);

  00213	0f b6 4c ef 04	 movzx	 ecx, BYTE PTR [edi+ebp*8+4]
  00218	8d 54 ef 04	 lea	 edx, DWORD PTR [edi+ebp*8+4]
  0021c	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  0021f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 1372 : 				BYTE XTemp = ThisSpark->X + (( (PhaseTable[ ThisSpark->ByteA ]) * ThisSpark->ByteB ) >> 8);
; 1373 : 				DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( ThisSpark->Y << UBits ) );
; 1374 : 				Mips(0).DataArray(SparkDest) = Htemp;			
; 1375 : 
; 1376 : 				ThisSpark->ByteA += ThisSpark->ByteD; // Angle increment/decrement
; 1377 :             }
; 1378 :             break;

  00224	eb 18		 jmp	 SHORT $L118580
$L108932:

; 1379 : 
; 1380 : 		case SPARK_Cylinder3D: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1381 :             {  
; 1382 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1383 : 				// 'Z' distance suggested by brightness.
; 1384 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1385 : 
; 1386 : 				if( ((ThisSpark->ByteA+64)&255) < 128 )

  00226	0f b6 4c ef 04	 movzx	 ecx, BYTE PTR [edi+ebp*8+4]
  0022b	8d 54 ef 04	 lea	 edx, DWORD PTR [edi+ebp*8+4]
  0022f	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  00232	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00237	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0023c	7d 5e		 jge	 SHORT $L108933
$L118580:

; 1387 : 				{
; 1388 : 					BYTE Htemp = Min( PhaseTable[ (ThisSpark->ByteA+64) & 255 ] +  ThisSpark->Heat, 255);

  0023e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _PhaseTable[eax]
  00245	0f b6 5c ef 01	 movzx	 ebx, BYTE PTR [edi+ebp*8+1]
  0024a	03 c3		 add	 eax, ebx
  0024c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00251	88 44 24 13	 mov	 BYTE PTR _Htemp$108934[esp+56], al
  00255	7e 05		 jle	 SHORT $L117389
  00257	c6 44 24 13 ff	 mov	 BYTE PTR _Htemp$108934[esp+56], 255 ; 000000ffH
$L117389:

; 1389 : 					BYTE XTemp = ThisSpark->X + (( (PhaseTable[ ThisSpark->ByteA ]) * ThisSpark->ByteB ) >> 8);
; 1390 : 					DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( ThisSpark->Y << UBits ) );
; 1391 : 					Mips(0).DataArray(SparkDest) = Htemp;			

  0025c	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR _PhaseTable[ecx]
  00263	0f b6 44 ef 05	 movzx	 eax, BYTE PTR [edi+ebp*8+5]
  00268	8b 9e c8 00 00
	00		 mov	 ebx, DWORD PTR [esi+200]
  0026e	0f af c8	 imul	 ecx, eax
  00271	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  00275	c1 f9 08	 sar	 ecx, 8
  00278	02 c8		 add	 cl, al
  0027a	33 c0		 xor	 eax, eax
  0027c	8a c1		 mov	 al, cl
  0027e	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00281	23 c3		 and	 eax, ebx
  00283	0f b6 5c ef 03	 movzx	 ebx, BYTE PTR [edi+ebp*8+3]
  00288	d3 e3		 shl	 ebx, cl
  0028a	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00290	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00293	03 c3		 add	 eax, ebx
  00295	8a 5c 24 13	 mov	 bl, BYTE PTR _Htemp$108934[esp+56]
  00299	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl
$L108933:

; 1392 : 				}
; 1393 : 
; 1394 : 				ThisSpark->ByteA += ThisSpark->ByteD; // Angle increment/decrement

  0029c	8a 0a		 mov	 cl, BYTE PTR [edx]
  0029e	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  002a2	02 c8		 add	 cl, al
  002a4	88 0a		 mov	 BYTE PTR [edx], cl

; 1395 :             }
; 1396 :             break;

  002a6	e9 dc 2d 00 00	 jmp	 $L108897
$L108942:

; 1397 : 
; 1398 : 		case SPARK_Jugglers: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1399 :             {  
; 1400 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1401 : 				// 'Z' distance suggested by brightness.
; 1402 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1403 : 
; 1404 : 				BYTE Htemp = Min( PhaseTable[ (ThisSpark->ByteA+64) & 255 ] +  ThisSpark->Heat, 255 );

  002ab	0f b6 4c ef 04	 movzx	 ecx, BYTE PTR [edi+ebp*8+4]
  002b0	0f b6 5c ef 01	 movzx	 ebx, BYTE PTR [edi+ebp*8+1]
  002b5	8d 54 ef 04	 lea	 edx, DWORD PTR [edi+ebp*8+4]
  002b9	8d 41 40	 lea	 eax, DWORD PTR [ecx+64]
  002bc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002c1	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _PhaseTable[eax]
  002c8	03 c3		 add	 eax, ebx
  002ca	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  002cf	7e 02		 jle	 SHORT $L117403
  002d1	0c ff		 or	 al, 255			; 000000ffH
$L117403:

; 1405 : 				BYTE YTemp = ThisSpark->Y + (( (PhaseTable[ ThisSpark->ByteA ]) * ThisSpark->ByteB ) >> 8);
; 1406 : 				DWORD SparkDest = (DWORD)( ThisSpark->X + ( (YTemp & VMask) << UBits )  );
; 1407 : 				Mips(0).DataArray(SparkDest) = Htemp;

  002d3	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR _PhaseTable[ecx]
  002da	0f b6 5c ef 05	 movzx	 ebx, BYTE PTR [edi+ebp*8+5]
  002df	0f af cb	 imul	 ecx, ebx
  002e2	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  002e6	c1 f9 08	 sar	 ecx, 8
  002e9	02 cb		 add	 cl, bl
  002eb	33 db		 xor	 ebx, ebx
  002ed	8a d9		 mov	 bl, cl
  002ef	23 9e cc 00 00
	00		 and	 ebx, DWORD PTR [esi+204]
  002f5	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  002f8	d3 e3		 shl	 ebx, cl
  002fa	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00300	03 59 1c	 add	 ebx, DWORD PTR [ecx+28]
  00303	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  00308	88 04 0b	 mov	 BYTE PTR [ebx+ecx], al

; 1408 : 				ThisSpark->ByteA += ThisSpark->ByteD; //

  0030b	8a 0a		 mov	 cl, BYTE PTR [edx]
  0030d	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  00311	02 c8		 add	 cl, al
  00313	88 0a		 mov	 BYTE PTR [edx], cl

; 1409 :             }
; 1410 :             break;

  00315	e9 6d 2d 00 00	 jmp	 $L108897
$L108951:

; 1318 : 
; 1319 : 	// Warning: On any movement or new creation, the integrity of a spark's coordinates
; 1320 :     // must be assured by using UMask and VMask.
; 1321 :     
; 1322 :     for( INT S=0; S<ActiveSparkNum; S++ )

  0031a	0f b6 4c ef 01	 movzx	 ecx, BYTE PTR [edi+ebp*8+1]

; 1411 : 
; 1412 : 		case SPARK_Lissajous: // Draw [Phase>>?] nr of sparks in a SIZE twister, speed FREQ
; 1413 :             {  
; 1414 : 				// Draw harmonic-motion spark based on size, phase, speed (freq).
; 1415 : 				// 'Z' distance suggested by brightness.
; 1416 : 				// DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1417 : 
; 1418 : 				BYTE Htemp = LightPhaseTable[ (BYTE) (ThisSpark->ByteA+64) ]; // Light phase == A

  0031f	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]

; 1419 : 				BYTE XTemp = ThisSpark->X + (( PhaseTable[ ThisSpark->ByteA ] * ThisSpark->Heat ) >> 8);
; 1420 : 				BYTE YTemp = ThisSpark->Y + (( PhaseTable[ ThisSpark->ByteB ] * ThisSpark->Heat ) >> 8);

  00323	8d 44 ef 05	 lea	 eax, DWORD PTR [edi+ebp*8+5]
  00327	89 44 24 14	 mov	 DWORD PTR -36+[esp+56], eax

; 1421 : 
; 1422 : 				DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( (YTemp & VMask) << UBits )  );
; 1423 : 				Mips(0).DataArray(SparkDest) = Htemp;			

  0032b	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0032e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR _PhaseTable[eax]
  00335	0f af c1	 imul	 eax, ecx
  00338	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  0033c	c1 f8 08	 sar	 eax, 8
  0033f	02 c1		 add	 al, cl
  00341	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  00347	0f b6 c0	 movzx	 eax, al
  0034a	23 c1		 and	 eax, ecx
  0034c	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0034f	d3 e0		 shl	 eax, cl
  00351	33 c9		 xor	 ecx, ecx
  00353	8a ca		 mov	 cl, dl
  00355	8a da		 mov	 bl, dl
  00357	89 44 24 18	 mov	 DWORD PTR -32+[esp+56], eax
  0035b	0f b6 44 ef 01	 movzx	 eax, BYTE PTR [edi+ebp*8+1]
  00360	80 c3 40	 add	 bl, 64			; 00000040H
  00363	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _PhaseTable[ecx]
  0036a	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  00370	0f af d0	 imul	 edx, eax
  00373	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  00377	c1 fa 08	 sar	 edx, 8
  0037a	02 d0		 add	 dl, al
  0037c	33 c0		 xor	 eax, eax
  0037e	8a c2		 mov	 al, dl
  00380	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  00386	0f b6 db	 movzx	 ebx, bl
  00389	23 c1		 and	 eax, ecx
  0038b	8b 4c 24 18	 mov	 ecx, DWORD PTR -32+[esp+56]
  0038f	03 c8		 add	 ecx, eax
  00391	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00394	8a 93 00 00 00
	00		 mov	 dl, BYTE PTR _LightPhaseTable[ebx]
  0039a	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 1424 : 
; 1425 : 				ThisSpark->ByteA += ThisSpark->ByteC;

  0039d	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  003a1	8a 5c ef 04	 mov	 bl, BYTE PTR [edi+ebp*8+4]

; 1426 : 				ThisSpark->ByteB += ThisSpark->ByteD;

  003a5	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  003a9	02 d8		 add	 bl, al
  003ab	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  003af	8a 10		 mov	 dl, BYTE PTR [eax]
  003b1	02 d1		 add	 dl, cl
  003b3	88 5c ef 04	 mov	 BYTE PTR [edi+ebp*8+4], bl
  003b7	88 10		 mov	 BYTE PTR [eax], dl

; 1427 :             }
; 1428 :             break;

  003b9	e9 c9 2c 00 00	 jmp	 $L108897
$L108958:

; 1429 : 
; 1430 : 		
; 1431 : 		case SPARK_LissajX: // Special case: Lissajous without Y-movement.
; 1432 : 			{  
; 1433 : 				BYTE XTemp = ThisSpark->X + (( PhaseTable[ ThisSpark->ByteA ] * ThisSpark->Heat ) >> 8);
; 1434 : 				BYTE Htemp = LightPhaseTable[ (BYTE)(ThisSpark->ByteA+64) ]; // Light phase == B

  003be	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  003c2	89 44 24 18	 mov	 DWORD PTR -32+[esp+56], eax
  003c6	8a 00		 mov	 al, BYTE PTR [eax]
  003c8	8a d0		 mov	 dl, al

; 1435 : 
; 1436 : 				DWORD SparkDest = (DWORD)( (XTemp & UMask) + ( ThisSpark->Y << UBits )  );
; 1437 : 				Mips(0).DataArray(SparkDest) = Htemp;			

  003ca	0f b6 c0	 movzx	 eax, al
  003cd	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _PhaseTable[eax]
  003d4	0f b6 44 ef 01	 movzx	 eax, BYTE PTR [edi+ebp*8+1]
  003d9	8b 9e c8 00 00
	00		 mov	 ebx, DWORD PTR [esi+200]
  003df	0f af c8	 imul	 ecx, eax
  003e2	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  003e6	c1 f9 08	 sar	 ecx, 8
  003e9	02 c8		 add	 cl, al
  003eb	33 c0		 xor	 eax, eax
  003ed	8a c1		 mov	 al, cl
  003ef	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  003f2	80 c2 40	 add	 dl, 64			; 00000040H
  003f5	0f b6 d2	 movzx	 edx, dl
  003f8	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _LightPhaseTable[edx]
  003fe	23 c3		 and	 eax, ebx
  00400	0f b6 5c ef 03	 movzx	 ebx, BYTE PTR [edi+ebp*8+3]
  00405	d3 e3		 shl	 ebx, cl
  00407	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0040d	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00410	03 c3		 add	 eax, ebx
  00412	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 1438 : 
; 1439 : 				ThisSpark->ByteA += ThisSpark->ByteC;

  00415	8b 44 24 18	 mov	 eax, DWORD PTR -32+[esp+56]
  00419	8a 10		 mov	 dl, BYTE PTR [eax]
  0041b	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  0041f	02 d1		 add	 dl, cl
  00421	88 10		 mov	 BYTE PTR [eax], dl

; 1440 :             }
; 1441 :             break;

  00423	e9 5f 2c 00 00	 jmp	 $L108897
$L108964:

; 1442 : 
; 1443 : 		case SPARK_LissajY: // Special case: Lissajous without X-movement.
; 1444 : 			{  
; 1445 : 				BYTE YTemp = ThisSpark->Y + (( PhaseTable[ ThisSpark->ByteB ] * ThisSpark->Heat ) >> 8);
; 1446 : 				BYTE Htemp = LightPhaseTable[ (BYTE)(ThisSpark->ByteB+64) ]; // Light phase == B

  00428	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]

; 1447 : 
; 1448 : 				DWORD SparkDest = (DWORD)( ThisSpark->X + ( (YTemp & VMask) << UBits )  );
; 1449 : 				Mips(0).DataArray(SparkDest) = Htemp;

  0042c	0f b6 5c ef 01	 movzx	 ebx, BYTE PTR [edi+ebp*8+1]
  00431	8a d1		 mov	 dl, cl
  00433	0f b6 c9	 movzx	 ecx, cl
  00436	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR _PhaseTable[ecx]
  0043d	8d 44 ef 05	 lea	 eax, DWORD PTR [edi+ebp*8+5]
  00441	0f af cb	 imul	 ecx, ebx
  00444	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  00448	c1 f9 08	 sar	 ecx, 8
  0044b	02 cb		 add	 cl, bl
  0044d	33 db		 xor	 ebx, ebx
  0044f	8a d9		 mov	 bl, cl
  00451	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  00457	80 c2 40	 add	 dl, 64			; 00000040H
  0045a	0f b6 d2	 movzx	 edx, dl
  0045d	8a 92 00 00 00
	00		 mov	 dl, BYTE PTR _LightPhaseTable[edx]
  00463	23 d9		 and	 ebx, ecx
  00465	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  00468	d3 e3		 shl	 ebx, cl
  0046a	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00470	03 59 1c	 add	 ebx, DWORD PTR [ecx+28]
  00473	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  00478	88 14 0b	 mov	 BYTE PTR [ebx+ecx], dl

; 1450 : 
; 1451 : 				ThisSpark->ByteB += ThisSpark->ByteD;

  0047b	8a 10		 mov	 dl, BYTE PTR [eax]
  0047d	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  00481	02 d1		 add	 dl, cl
  00483	88 10		 mov	 BYTE PTR [eax], dl

; 1452 :             }
; 1453 :             break;

  00485	e9 fd 2b 00 00	 jmp	 $L108897
$L108970:

; 1454 : 
; 1455 :         case SPARK_Blaze: // Emit sparks pseudo-radially.
; 1456 :             if( (ActiveSparkNum < (SparksLimit)) && ( 128 > SpeedRand() ) )

  0048a	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00490	0f 8d f1 2b 00
	00		 jge	 $L108897
  00496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0049c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  004a2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  004a8	83 c2 04	 add	 edx, 4
  004ab	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  004b1	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  004b7	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  004bd	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  004c3	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  004c9	3c 80		 cmp	 al, 128			; 00000080H
  004cb	0f 83 b6 2b 00
	00		 jae	 $L108897

; 1457 :             {   // create it..
; 1458 :                 INT  NS = ActiveSparkNum++;

  004d1	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1459 : 	            Sparks(NS).Type = ISPARK_Drifter;  // Dynamic type.

  004d7	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  004dd	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  004e0	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  004e6	c6 04 d8 20	 mov	 BYTE PTR [eax+ebx*8], 32 ; 00000020H

; 1460 : 				Sparks(NS).Heat = ThisSpark->Heat; // Start heat 

  004ea	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  004f0	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  004f4	88 54 d9 01	 mov	 BYTE PTR [ecx+ebx*8+1], dl

; 1461 :                 Sparks(NS).X = ThisSpark->X;

  004f8	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  004fe	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00502	88 4c d8 02	 mov	 BYTE PTR [eax+ebx*8+2], cl

; 1462 : 				Sparks(NS).Y = ThisSpark->Y;             

  00506	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0050c	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  00510	88 44 da 03	 mov	 BYTE PTR [edx+ebx*8+3], al

; 1463 :                 Sparks(NS).ByteA = SpeedRand();  // Speed

  00514	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0051a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00520	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00526	83 c2 04	 add	 edx, 4
  00529	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0052f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00535	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0053b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00541	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00547	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0054d	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1464 :                 Sparks(NS).ByteB = SpeedRand();  // Speed

  00551	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00557	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0055d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00563	83 c2 04	 add	 edx, 4
  00566	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0056c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00572	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00578	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0057e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00584	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0058a	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1465 : 				Sparks(NS).ByteC = ThisSpark->ByteC;

  0058e	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00594	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  00598	88 4c d8 06	 mov	 BYTE PTR [eax+ebx*8+6], cl

; 1466 : 				Sparks(NS).ByteD = ThisSpark->ByteD;

  0059c	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  005a2	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  005a6	88 44 da 07	 mov	 BYTE PTR [edx+ebx*8+7], al

; 1467 :             }
; 1468 :             break;

  005aa	e9 d8 2a 00 00	 jmp	 $L108897
$L108973:

; 1469 : 
; 1470 :         case SPARK_OzHasSpoken: // V-shaped output.
; 1471 :             if( (ActiveSparkNum < (SparksLimit)) && ( 128 > SpeedRand() ) )

  005af	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  005b5	0f 8d cc 2a 00
	00		 jge	 $L108897
  005bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  005c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  005c7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  005cd	83 c2 04	 add	 edx, 4
  005d0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  005d6	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  005dc	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  005e2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  005e8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  005ee	3c 80		 cmp	 al, 128			; 00000080H
  005f0	0f 83 91 2a 00
	00		 jae	 $L108897

; 1472 :             {   // create it..
; 1473 :                 INT  NS = ActiveSparkNum++;

  005f6	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1474 :                 Sparks(NS).Type  = ISPARK_DriftSlow;

  005fc	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00602	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00605	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  0060b	c6 04 da 21	 mov	 BYTE PTR [edx+ebx*8], 33 ; 00000021H

; 1475 :                 Sparks(NS).Heat  = ThisSpark->Heat;        // Start heat.

  0060f	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00615	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00619	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1476 :                 Sparks(NS).X     = ThisSpark->X;

  0061d	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00623	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  00627	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1477 :                 Sparks(NS).Y     = ThisSpark->Y;

  0062b	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00631	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  00635	88 54 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], dl

; 1478 : 				Sparks(NS).ByteA = (SpeedRand()&127) - 63; // X speed arbit.

  00639	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0063f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00645	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0064b	83 c2 04	 add	 edx, 4
  0064e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00654	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0065a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00660	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00666	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0066c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00672	24 7f		 and	 al, 127			; 0000007fH
  00674	2c 3f		 sub	 al, 63			; 0000003fH
  00676	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1479 :                 Sparks(NS).ByteB = (BYTE)-127;             // Y speed UP..

  0067a	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00680	c6 44 da 05 81	 mov	 BYTE PTR [edx+ebx*8+5], 129 ; 00000081H

; 1480 : 				Sparks(NS).ByteD = 2;  // Life decrement.

  00685	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0068b	c6 44 d8 07 02	 mov	 BYTE PTR [eax+ebx*8+7], 2

; 1481 :             }
; 1482 :             break;

  00690	e9 f2 29 00 00	 jmp	 $L108897
$L108977:

; 1483 : 
; 1484 :         case SPARK_Cone: // Symmetric gravity-emitting - sparks of type 130.
; 1485 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  00695	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  0069b	0f 8d e6 29 00
	00		 jge	 $L108897
  006a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  006a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  006ad	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  006b3	83 c2 04	 add	 edx, 4
  006b6	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  006bc	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  006c2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  006c8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  006ce	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  006d4	3c 40		 cmp	 al, 64			; 00000040H
  006d6	0f 83 ab 29 00
	00		 jae	 $L108897

; 1486 :             {   // create it..
; 1487 :                 INT  NS = ActiveSparkNum++;

  006dc	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1488 :                 Sparks(NS).Type = ISPARK_Faller;

  006e2	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  006e8	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  006eb	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  006f1	c6 04 da 22	 mov	 BYTE PTR [edx+ebx*8], 34 ; 00000022H

; 1489 : 				Sparks(NS).Heat = ThisSpark->Heat;   // Heat.

  006f5	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  006fb	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  006ff	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1490 :                 Sparks(NS).X = ThisSpark->X;

  00703	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00709	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  0070d	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1491 :                 Sparks(NS).Y = ThisSpark->Y;

  00711	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00717	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  0071b	88 54 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], dl

; 1492 : 
; 1493 :                 Sparks(NS).ByteA = (SpeedRand()&127) - 63; // X speed arbit.

  0071f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00725	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0072b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00731	83 c2 04	 add	 edx, 4
  00734	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0073a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00740	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00746	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0074c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00752	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00758	24 7f		 and	 al, 127			; 0000007fH
  0075a	2c 3f		 sub	 al, 63			; 0000003fH
  0075c	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1494 :                 Sparks(NS).ByteB =  0;  // Y speed UP

  00760	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00766	c6 44 da 05 00	 mov	 BYTE PTR [edx+ebx*8+5], 0

; 1495 :                 Sparks(NS).ByteC =  50; // Timer.

  0076b	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00771	c6 44 d8 06 32	 mov	 BYTE PTR [eax+ebx*8+6], 50 ; 00000032H

; 1496 :             }
; 1497 :             break;

  00776	e9 0c 29 00 00	 jmp	 $L108897
$L108980:

; 1498 : 
; 1499 :         case SPARK_BlazeRight: // Erupt to the right.
; 1500 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  0077b	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00781	0f 8d 00 29 00
	00		 jge	 $L108897
  00787	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0078d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00793	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00799	83 c2 04	 add	 edx, 4
  0079c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  007a2	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  007a8	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  007ae	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  007b4	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  007ba	3c 40		 cmp	 al, 64			; 00000040H
  007bc	0f 83 c5 28 00
	00		 jae	 $L108897

; 1501 :             {   // Create it.
; 1502 :                 INT  NS = ActiveSparkNum++;

  007c2	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1503 :                 Sparks(NS).Type = ISPARK_Faller; //

  007c8	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  007ce	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  007d1	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  007d7	c6 04 da 22	 mov	 BYTE PTR [edx+ebx*8], 34 ; 00000022H

; 1504 : 				Sparks(NS).Heat = ThisSpark->Heat;  // Heat.

  007db	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  007e1	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  007e5	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1505 : 				Sparks(NS).X = ThisSpark->X;

  007e9	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  007ef	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  007f3	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1506 :                 Sparks(NS).Y = ThisSpark->Y;

  007f7	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  007fd	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  00801	88 54 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], dl

; 1507 :                 Sparks(NS).ByteA = (SpeedRand()&63) + 63; // X Speed.

  00805	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0080b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00811	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00817	83 c2 04	 add	 edx, 4
  0081a	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00820	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00826	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0082c	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00832	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00838	24 3f		 and	 al, 63			; 0000003fH
  0083a	04 3f		 add	 al, 63			; 0000003fH

; 1508 :                 Sparks(NS).ByteB = (BYTE) -29; // Y speed UP.
; 1509 :                 Sparks(NS).ByteC =  ThisSpark->ByteC; // Timer.
; 1510 :             }
; 1511 :             break;

  0083c	e9 c1 00 00 00	 jmp	 $L118579
$L108984:

; 1512 : 
; 1513 :         case SPARK_BlazeLeft: // Erupt to the left.
; 1514 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  00841	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00847	0f 8d 3a 28 00
	00		 jge	 $L108897
  0084d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00853	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00859	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0085f	83 c2 04	 add	 edx, 4
  00862	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00868	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0086e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00874	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0087a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00880	3c 40		 cmp	 al, 64			; 00000040H
  00882	0f 83 ff 27 00
	00		 jae	 $L108897

; 1515 :             {   // Create it.
; 1516 :                 INT  NS = ActiveSparkNum++;

  00888	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1517 :                 Sparks(NS).Type = ISPARK_Faller;

  0088e	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00894	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00897	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  0089d	c6 04 d8 22	 mov	 BYTE PTR [eax+ebx*8], 34 ; 00000022H

; 1518 : 				Sparks(NS).Heat = ThisSpark->Heat;	  // Heat.

  008a1	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  008a7	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  008ab	88 54 d9 01	 mov	 BYTE PTR [ecx+ebx*8+1], dl

; 1519 : 				Sparks(NS).X = ThisSpark->X;

  008af	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  008b5	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  008b9	88 4c d8 02	 mov	 BYTE PTR [eax+ebx*8+2], cl

; 1520 :                 Sparks(NS).Y = ThisSpark->Y;

  008bd	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  008c3	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  008c7	88 44 da 03	 mov	 BYTE PTR [edx+ebx*8+3], al

; 1521 :                 Sparks(NS).ByteA = (SpeedRand()&63) -128; // X speed 

  008cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  008d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  008d7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  008dd	83 c2 04	 add	 edx, 4
  008e0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  008e6	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  008ec	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  008f2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  008f8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  008fe	24 3f		 and	 al, 63			; 0000003fH
  00900	04 80		 add	 al, 128			; 00000080H
$L118579:
  00902	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00908	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1522 :                 Sparks(NS).ByteB = (BYTE) -29;  // Y speed UP

  0090c	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00912	c6 44 da 05 e3	 mov	 BYTE PTR [edx+ebx*8+5], 227 ; 000000e3H

; 1523 :                 Sparks(NS).ByteC =  ThisSpark->ByteC; // Timer.

  00917	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0091d	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  00921	88 4c d8 06	 mov	 BYTE PTR [eax+ebx*8+6], cl

; 1524 :             }
; 1525 :             break;

  00925	e9 5d 27 00 00	 jmp	 $L108897
$L108988:

; 1526 : 
; 1527 :         case SPARK_Emit: // Erupt to a preset speed & direction.
; 1528 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  0092a	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00930	0f 8d 51 27 00
	00		 jge	 $L108897
  00936	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0093c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00942	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00948	83 c2 04	 add	 edx, 4
  0094b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00951	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00957	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0095d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00963	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00969	3c 40		 cmp	 al, 64			; 00000040H
  0096b	0f 83 16 27 00
	00		 jae	 $L108897

; 1529 :             {   // Create it..
; 1530 :                 INT  NS = ActiveSparkNum++;

  00971	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]

; 1531 :                 Sparks(NS).Type = ISPARK_DriftSlow;

  00977	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0097d	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00980	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  00986	c6 04 c1 21	 mov	 BYTE PTR [ecx+eax*8], 33 ; 00000021H

; 1532 : 				Sparks(NS).Heat = ThisSpark->Heat; // heat

  0098a	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00990	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00994	88 4c c2 01	 mov	 BYTE PTR [edx+eax*8+1], cl

; 1533 :                 Sparks(NS).X = ThisSpark->X;

  00998	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0099e	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  009a2	88 4c c2 02	 mov	 BYTE PTR [edx+eax*8+2], cl

; 1534 :                 Sparks(NS).Y = ThisSpark->Y;

  009a6	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  009ac	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  009b0	88 4c c2 03	 mov	 BYTE PTR [edx+eax*8+3], cl

; 1535 :                 Sparks(NS).ByteA = ThisSpark->ByteA; // X speed

  009b4	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  009ba	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  009be	88 4c c2 04	 mov	 BYTE PTR [edx+eax*8+4], cl

; 1536 :                 Sparks(NS).ByteB = ThisSpark->ByteB; // Y speed

  009c2	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  009c8	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  009cc	88 4c c2 05	 mov	 BYTE PTR [edx+eax*8+5], cl

; 1537 : 				Sparks(NS).ByteD = ThisSpark->ByteD; // Decrement

  009d0	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  009d6	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  009da	88 4c c2 07	 mov	 BYTE PTR [edx+eax*8+7], cl

; 1538 :             }
; 1539 :             break;

  009de	e9 a4 26 00 00	 jmp	 $L108897
$L108991:

; 1540 : 
; 1541 : 		case SPARK_Fountain: // Erupt to a preset speed & direction.
; 1542 :             if( (ActiveSparkNum < (SparksLimit)) && ( 64 > SpeedRand() ) )

  009e3	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  009e9	0f 8d 98 26 00
	00		 jge	 $L108897
  009ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  009f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  009fb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00a01	83 c2 04	 add	 edx, 4
  00a04	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00a0a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00a10	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00a16	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00a1c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00a22	3c 40		 cmp	 al, 64			; 00000040H
  00a24	0f 83 5d 26 00
	00		 jae	 $L108897

; 1543 :             {   // Create it..
; 1544 :                 INT  NS = ActiveSparkNum++;

  00a2a	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]

; 1545 :                 Sparks(NS).Type  = ISPARK_Graviton;

  00a30	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00a36	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00a39	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  00a3f	c6 04 c1 2a	 mov	 BYTE PTR [ecx+eax*8], 42 ; 0000002aH

; 1546 : 				Sparks(NS).Heat  = ThisSpark->Heat; // heat

  00a43	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a49	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  00a4d	88 4c c2 01	 mov	 BYTE PTR [edx+eax*8+1], cl

; 1547 :                 Sparks(NS).X     = ThisSpark->X;

  00a51	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a57	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00a5b	88 4c c2 02	 mov	 BYTE PTR [edx+eax*8+2], cl

; 1548 :                 Sparks(NS).Y     = ThisSpark->Y;

  00a5f	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a65	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  00a69	88 4c c2 03	 mov	 BYTE PTR [edx+eax*8+3], cl

; 1549 :                 Sparks(NS).ByteA = ThisSpark->ByteA; // X speed

  00a6d	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a73	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  00a77	88 4c c2 04	 mov	 BYTE PTR [edx+eax*8+4], cl

; 1550 :                 Sparks(NS).ByteB = ThisSpark->ByteB; // Y speed

  00a7b	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a81	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  00a85	88 4c c2 05	 mov	 BYTE PTR [edx+eax*8+5], cl

; 1551 : 				Sparks(NS).ByteD = ThisSpark->ByteD; // Decrement

  00a89	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00a8f	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  00a93	88 4c c2 07	 mov	 BYTE PTR [edx+eax*8+7], cl

; 1552 :             }
; 1553 :         	break;

  00a97	e9 eb 25 00 00	 jmp	 $L108897
$L108994:

; 1554 : 
; 1555 : 
; 1556 : 		case SPARK_Organic: // Emitting - sparks of type SPARK_VShooter.
; 1557 :      						// Whirly-floaty fire sparks, go up & glow out.
; 1558 :             if( (ActiveSparkNum < (SparksLimit)) && ( 128 > SpeedRand() ) )

  00a9c	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00aa2	0f 8d df 25 00
	00		 jge	 $L108897
  00aa8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00aae	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00ab4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00aba	83 c2 04	 add	 edx, 4
  00abd	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00ac3	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00ac9	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00acf	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00ad5	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00adb	3c 80		 cmp	 al, 128			; 00000080H
  00add	0f 83 a4 25 00
	00		 jae	 $L108897

; 1559 :             {   // create it..
; 1560 :                 INT  NS = ActiveSparkNum++;

  00ae3	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]

; 1561 :                 Sparks(NS).Type = ISPARK_VShooter; //

  00ae9	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00aef	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00af2	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx
  00af8	c6 04 d8 23	 mov	 BYTE PTR [eax+ebx*8], 35 ; 00000023H

; 1562 : 				Sparks(NS).X = UMask & (ThisSpark->X + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  00afc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00b02	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00b08	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00b0e	83 c2 04	 add	 edx, 4
  00b11	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00b17	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00b1d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00b23	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00b29	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00b2f	0f b6 54 ef 06	 movzx	 edx, BYTE PTR [edi+ebp*8+6]
  00b34	33 c9		 xor	 ecx, ecx
  00b36	8a c8		 mov	 cl, al
  00b38	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  00b3e	0f af ca	 imul	 ecx, edx
  00b41	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  00b45	c1 f9 08	 sar	 ecx, 8
  00b48	02 ca		 add	 cl, dl
  00b4a	22 c8		 and	 cl, al
  00b4c	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00b52	88 4c d8 02	 mov	 BYTE PTR [eax+ebx*8+2], cl

; 1563 : 				Sparks(NS).Y = VMask & (ThisSpark->Y + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  00b56	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00b5c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00b62	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00b68	83 c2 04	 add	 edx, 4
  00b6b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00b71	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00b77	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00b7d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00b83	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00b89	0f b6 54 ef 06	 movzx	 edx, BYTE PTR [edi+ebp*8+6]
  00b8e	33 c9		 xor	 ecx, ecx
  00b90	8a c8		 mov	 cl, al
  00b92	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  00b96	0f af ca	 imul	 ecx, edx
  00b99	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  00b9f	c1 f9 08	 sar	 ecx, 8
  00ba2	02 c8		 add	 cl, al
  00ba4	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00baa	22 ca		 and	 cl, dl
  00bac	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1564 :                 Sparks(NS).ByteA = SpeedRand() - 127; // X speed arbit.

  00bb0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00bb6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00bbc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00bc2	83 c2 04	 add	 edx, 4
  00bc5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00bcb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00bd1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00bd7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00bdd	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00be3	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00be9	2c 7f		 sub	 al, 127			; 0000007fH
  00beb	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1565 :                 Sparks(NS).ByteB = 256-127;           // Y speed UP

  00bef	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00bf5	c6 44 da 05 81	 mov	 BYTE PTR [edx+ebx*8+5], 129 ; 00000081H

; 1566 :                 Sparks(NS).ByteC = 255;				  // Timer==heat - steps --2, to 128

  00bfa	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00c00	c6 44 d8 06 ff	 mov	 BYTE PTR [eax+ebx*8+6], 255 ; 000000ffH

; 1567 :             }
; 1568 :             break;

  00c05	e9 7d 24 00 00	 jmp	 $L108897
$L108997:

; 1569 : 
; 1570 :         case SPARK_WanderOrganic: // Emitting VShooters but randomly moves itself.
; 1571 :             if( (ActiveSparkNum < (SparksLimit)) )

  00c0a	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00c10	0f 8d fc 00 00
	00		 jge	 $L108998

; 1572 :             {   // create it..
; 1573 :                 INT  NS = ActiveSparkNum++;

  00c16	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00c19	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 1574 :                 Sparks(NS).Type = ISPARK_VShooter;

  00c1f	c6 04 df 23	 mov	 BYTE PTR [edi+ebx*8], 35 ; 00000023H

; 1575 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  00c23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00c29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00c2f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00c35	83 c2 04	 add	 edx, 4
  00c38	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00c3e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00c44	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00c4a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00c50	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00c56	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  00c5a	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  00c60	24 1f		 and	 al, 31			; 0000001fH
  00c62	02 c2		 add	 al, dl
  00c64	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00c6a	22 c1		 and	 al, cl
  00c6c	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1576 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  00c70	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00c76	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00c7c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00c82	83 c2 04	 add	 edx, 4
  00c85	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00c8b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00c91	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00c97	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00c9d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00ca3	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  00ca7	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  00cad	24 1f		 and	 al, 31			; 0000001fH
  00caf	02 c1		 add	 al, cl
  00cb1	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00cb7	22 c2		 and	 al, dl
  00cb9	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1577 : 
; 1578 :                 Sparks(NS).ByteA = SpeedRand() - 127; // X speed

  00cbd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00cc3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00cc9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00ccf	83 c2 04	 add	 edx, 4
  00cd2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00cd8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00cde	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00ce4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00cea	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00cf0	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00cf6	2c 7f		 sub	 al, 127			; 0000007fH
  00cf8	88 44 da 04	 mov	 BYTE PTR [edx+ebx*8+4], al

; 1579 :                 Sparks(NS).ByteB = 256-127;           // Y speed UP

  00cfc	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00d02	c6 44 d8 05 81	 mov	 BYTE PTR [eax+ebx*8+5], 129 ; 00000081H

; 1580 :                 Sparks(NS).ByteC = 255;               // timer - steps --2, to 128

  00d07	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00d0d	c6 44 d9 06 ff	 mov	 BYTE PTR [ecx+ebx*8+6], 255 ; 000000ffH
$L108998:

; 1581 :             }
; 1582 :             // move around a bit
; 1583 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  00d12	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00d18	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00d1e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00d24	83 c2 04	 add	 edx, 4
  00d27	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00d2d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00d33	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00d39	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00d3f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00d45	a8 01		 test	 al, 1
  00d47	74 49		 je	 SHORT $L109000
  00d49	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00d4f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00d55	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00d5b	83 c2 04	 add	 edx, 4
  00d5e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00d64	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00d6a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00d70	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00d76	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00d7c	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  00d80	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  00d86	24 0f		 and	 al, 15			; 0000000fH
  00d88	02 c3		 add	 al, bl
  00d8a	2c 07		 sub	 al, 7
  00d8c	22 c1		 and	 al, cl
  00d8e	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L109000:

; 1584 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  00d92	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00d98	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00d9e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00da4	83 c2 04	 add	 edx, 4
  00da7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00dad	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00db3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00db9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00dbf	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00dc5	a8 01		 test	 al, 1
  00dc7	0f 84 ba 22 00
	00		 je	 $L108897
  00dcd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00dd3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00dd9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00ddf	83 c2 04	 add	 edx, 4
  00de2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00de8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00dee	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00df4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00dfa	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00e00	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  00e04	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  00e0a	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  00e0e	24 0f		 and	 al, 15			; 0000000fH
  00e10	02 c3		 add	 al, bl
  00e12	2c 07		 sub	 al, 7
  00e14	22 c1		 and	 al, cl
  00e16	88 07		 mov	 BYTE PTR [edi], al

; 1585 :             break;

  00e18	e9 6a 22 00 00	 jmp	 $L108897
$L109002:

; 1586 : 
; 1587 :         case SPARK_RandomCloud: // Emitting Drop but randomly moves itself eratically.
; 1588 :             if( (ActiveSparkNum < (SparksLimit)) )

  00e1d	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  00e23	0f 8d fe 00 00
	00		 jge	 $L109003

; 1589 :             {   // create it..
; 1590 :                 INT  NS = ActiveSparkNum++;

  00e29	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00e2c	89 96 f8 00 00
	00		 mov	 DWORD PTR [esi+248], edx

; 1591 :                 Sparks(NS).Type =  ISPARK_Drop;

  00e32	c6 04 df 24	 mov	 BYTE PTR [edi+ebx*8], 36 ; 00000024H

; 1592 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  00e36	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00e3c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00e42	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00e48	83 c2 04	 add	 edx, 4
  00e4b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00e51	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00e57	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00e5d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00e63	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00e69	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  00e6d	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  00e73	24 1f		 and	 al, 31			; 0000001fH
  00e75	02 c1		 add	 al, cl
  00e77	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00e7d	22 c2		 and	 al, dl
  00e7f	88 44 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], al

; 1593 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  00e83	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00e89	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00e8f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00e95	83 c2 04	 add	 edx, 4
  00e98	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00e9e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00ea4	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00eaa	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00eb0	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00eb6	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  00eba	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  00ec0	24 1f		 and	 al, 31			; 0000001fH
  00ec2	02 c2		 add	 al, dl
  00ec4	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00eca	22 c1		 and	 al, cl
  00ecc	88 44 da 03	 mov	 BYTE PTR [edx+ebx*8+3], al

; 1594 :                 Sparks(NS).ByteA = (SpeedRand()&31) - 15; // X speed

  00ed0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00ed6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00edc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00ee2	83 c2 04	 add	 edx, 4
  00ee5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00eeb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00ef1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00ef7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00efd	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00f03	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  00f09	24 1f		 and	 al, 31			; 0000001fH
  00f0b	2c 0f		 sub	 al, 15			; 0000000fH
  00f0d	88 44 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], al

; 1595 :                 Sparks(NS).ByteB =  256-127;              // Y speed UP

  00f11	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  00f17	c6 44 da 05 81	 mov	 BYTE PTR [edx+ebx*8+5], 129 ; 00000081H

; 1596 :                 Sparks(NS).ByteC =  0;                    // timer=HEAT

  00f1c	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00f22	c6 44 d8 06 00	 mov	 BYTE PTR [eax+ebx*8+6], 0
$L109003:

; 1597 :             }
; 1598 :             // move around a bit
; 1599 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  00f27	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00f2d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00f33	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00f39	83 c2 04	 add	 edx, 4
  00f3c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00f42	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00f48	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00f4e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00f54	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00f5a	a8 01		 test	 al, 1
  00f5c	74 49		 je	 SHORT $L109005
  00f5e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00f64	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00f6a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00f70	83 c2 04	 add	 edx, 4
  00f73	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00f79	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00f7f	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00f85	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00f8b	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00f91	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  00f95	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  00f9b	24 0f		 and	 al, 15			; 0000000fH
  00f9d	02 c3		 add	 al, bl
  00f9f	2c 07		 sub	 al, 7
  00fa1	22 c1		 and	 al, cl
  00fa3	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L109005:

; 1600 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  00fa7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00fad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00fb3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00fb9	83 c2 04	 add	 edx, 4
  00fbc	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00fc2	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00fc8	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00fce	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00fd4	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00fda	a8 01		 test	 al, 1
  00fdc	0f 84 a5 20 00
	00		 je	 $L108897
  00fe2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00fe8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00fee	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00ff4	83 c2 04	 add	 edx, 4
  00ff7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00ffd	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01003	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01009	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0100f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01015	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  01019	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  0101f	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  01023	24 0f		 and	 al, 15			; 0000000fH
  01025	02 c3		 add	 al, bl
  01027	2c 07		 sub	 al, 7
  01029	22 c1		 and	 al, cl
  0102b	88 07		 mov	 BYTE PTR [edi], al

; 1601 :             break;

  0102d	e9 55 20 00 00	 jmp	 $L108897
$L109007:

; 1602 : 
; 1603 :         case SPARK_Eels: // Spawns some Eels.
; 1604 :             if  ( (SpeedRand()<20) &&  ( (ActiveSparkNum < (SparksLimit)) ) )

  01032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01038	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0103e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01044	83 c2 04	 add	 edx, 4
  01047	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0104d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01053	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01059	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0105f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01065	3c 14		 cmp	 al, 20			; 00000014H
  01067	0f 83 55 01 00
	00		 jae	 $L109008
  0106d	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  01073	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01079	0f 8d 43 01 00
	00		 jge	 $L109008

; 1605 :             {
; 1606 :                 // create it..
; 1607 :                 INT  NS = ActiveSparkNum++;
; 1608 : 				Sparks(NS).Heat  = ThisSpark->Heat;

  0107f	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01085	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  01088	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  0108e	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01092	88 44 da 01	 mov	 BYTE PTR [edx+ebx*8+1], al

; 1609 :                 Sparks(NS).Type = ISPARK_SpawnedEel; //

  01096	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0109c	c6 04 d9 26	 mov	 BYTE PTR [ecx+ebx*8], 38 ; 00000026H

; 1610 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  010a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  010a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  010ac	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  010b2	83 c2 04	 add	 edx, 4
  010b5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  010bb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  010c1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  010c7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  010cd	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  010d3	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  010d7	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  010dd	24 1f		 and	 al, 31			; 0000001fH
  010df	02 c1		 add	 al, cl
  010e1	22 c2		 and	 al, dl
  010e3	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  010e9	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1611 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  010ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  010f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  010f9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  010ff	83 c2 04	 add	 edx, 4
  01102	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01108	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0110e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01114	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0111a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01120	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01124	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  0112a	24 1f		 and	 al, 31			; 0000001fH
  0112c	02 c2		 add	 al, dl
  0112e	22 c1		 and	 al, cl
  01130	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01136	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1612 :                 Sparks(NS).ByteA = SpeedRand();

  0113a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01140	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01146	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0114c	83 c2 04	 add	 edx, 4
  0114f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01155	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0115b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01161	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01167	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0116d	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01173	88 44 da 04	 mov	 BYTE PTR [edx+ebx*8+4], al

; 1613 :                 Sparks(NS).ByteB = SpeedRand();

  01177	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0117d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01183	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01189	83 c2 04	 add	 edx, 4
  0118c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01192	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01198	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0119e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  011a4	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  011aa	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  011b0	88 44 d9 05	 mov	 BYTE PTR [ecx+ebx*8+5], al

; 1614 :                 Sparks(NS).ByteC = ThisSpark->ByteC;  // Timer.

  011b4	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  011ba	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  011be	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al
$L109008:

; 1615 :             }
; 1616 :             // move around a bit
; 1617 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  011c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  011c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  011ce	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  011d4	83 c2 04	 add	 edx, 4
  011d7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  011dd	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  011e3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  011e9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  011ef	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  011f5	a8 01		 test	 al, 1
  011f7	74 49		 je	 SHORT $L109010
  011f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  011ff	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01205	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0120b	83 c2 04	 add	 edx, 4
  0120e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01214	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0121a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01220	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01226	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0122c	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  01230	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  01236	24 0f		 and	 al, 15			; 0000000fH
  01238	02 c3		 add	 al, bl
  0123a	2c 07		 sub	 al, 7
  0123c	22 c1		 and	 al, cl
  0123e	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L109010:

; 1618 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  01242	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01248	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0124e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01254	83 c2 04	 add	 edx, 4
  01257	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0125d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01263	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01269	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0126f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01275	a8 01		 test	 al, 1
  01277	0f 84 0a 1e 00
	00		 je	 $L108897
  0127d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01283	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01289	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0128f	83 c2 04	 add	 edx, 4
  01292	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01298	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0129e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  012a4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  012aa	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  012b0	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  012b4	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  012ba	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  012be	24 0f		 and	 al, 15			; 0000000fH
  012c0	02 c3		 add	 al, bl
  012c2	2c 07		 sub	 al, 7
  012c4	22 c1		 and	 al, cl
  012c6	88 07		 mov	 BYTE PTR [edi], al

; 1619 :             break;

  012c8	e9 ba 1d 00 00	 jmp	 $L108897
$L109012:

; 1620 : 
; 1621 : 		case SPARK_Gametes: // Spawns a spermatozoid.
; 1622 :             if  ( (SpeedRand()<20) &&  ( (ActiveSparkNum < (SparksLimit)) ) )

  012cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  012d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  012d9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  012df	83 c2 04	 add	 edx, 4
  012e2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  012e8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  012ee	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  012f4	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  012fa	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01300	3c 14		 cmp	 al, 20			; 00000014H
  01302	0f 83 55 01 00
	00		 jae	 $L109013
  01308	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  0130e	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01314	0f 8d 43 01 00
	00		 jge	 $L109013

; 1623 :             {
; 1624 : 				// Create it.
; 1625 :                 INT  NS = ActiveSparkNum++;
; 1626 :                 Sparks(NS).Type = ISPARK_SpawnedSperm; //

  0131a	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01320	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  01323	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  01329	c6 04 da 2b	 mov	 BYTE PTR [edx+ebx*8], 43 ; 0000002bH

; 1627 : 				Sparks(NS).Heat = ThisSpark->Heat;

  0132d	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01333	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  01337	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1628 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  0133b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01341	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01347	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0134d	83 c2 04	 add	 edx, 4
  01350	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01356	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0135c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01362	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01368	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0136e	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01372	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  01378	24 1f		 and	 al, 31			; 0000001fH
  0137a	02 c1		 add	 al, cl
  0137c	22 c2		 and	 al, dl
  0137e	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01384	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1629 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  01388	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0138e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01394	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0139a	83 c2 04	 add	 edx, 4
  0139d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  013a3	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  013a9	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  013af	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  013b5	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  013bb	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  013bf	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  013c5	24 1f		 and	 al, 31			; 0000001fH
  013c7	02 c2		 add	 al, dl
  013c9	22 c1		 and	 al, cl
  013cb	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  013d1	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1630 :                 Sparks(NS).ByteA = SpeedRand(); // wriggle counter

  013d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  013db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  013e1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  013e7	83 c2 04	 add	 edx, 4
  013ea	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  013f0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  013f6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  013fc	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01402	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01408	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0140e	88 44 da 04	 mov	 BYTE PTR [edx+ebx*8+4], al

; 1631 :                 Sparks(NS).ByteC = ThisSpark->ByteC;  // Timer.

  01412	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01418	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  0141c	88 4c d8 06	 mov	 BYTE PTR [eax+ebx*8+6], cl

; 1632 : 				Sparks(NS).ByteD = SpeedRand(); // Direction

  01420	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01426	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0142c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01432	83 c2 04	 add	 edx, 4
  01435	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0143b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01441	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01447	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0144d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01453	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01459	88 44 da 07	 mov	 BYTE PTR [edx+ebx*8+7], al
$L109013:

; 1633 :             }
; 1634 :             // Move around a bit.
; 1635 :             if( SpeedRand() & 15 == 15 ) ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&15)-7);

  0145d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01463	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01469	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0146f	83 c2 04	 add	 edx, 4
  01472	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01478	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0147e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01484	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0148a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01490	a8 01		 test	 al, 1
  01492	74 49		 je	 SHORT $L109015
  01494	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0149a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  014a0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  014a6	83 c2 04	 add	 edx, 4
  014a9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  014af	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  014b5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  014bb	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  014c1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  014c7	8a 5c ef 02	 mov	 bl, BYTE PTR [edi+ebp*8+2]
  014cb	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  014d1	24 0f		 and	 al, 15			; 0000000fH
  014d3	02 c3		 add	 al, bl
  014d5	2c 07		 sub	 al, 7
  014d7	22 c1		 and	 al, cl
  014d9	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L109015:

; 1636 :             if( SpeedRand() & 15 == 15 ) ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&15)-7);

  014dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  014e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  014e9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  014ef	83 c2 04	 add	 edx, 4
  014f2	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  014f8	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  014fe	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01504	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0150a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01510	a8 01		 test	 al, 1
  01512	0f 84 6f 1b 00
	00		 je	 $L108897
  01518	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0151e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01524	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0152a	83 c2 04	 add	 edx, 4
  0152d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01533	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01539	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0153f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01545	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0154b	8a 5c ef 03	 mov	 bl, BYTE PTR [edi+ebp*8+3]
  0154f	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  01555	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  01559	24 0f		 and	 al, 15			; 0000000fH
  0155b	02 c3		 add	 al, bl
  0155d	2c 07		 sub	 al, 7
  0155f	22 c1		 and	 al, cl
  01561	88 07		 mov	 BYTE PTR [edi], al

; 1637 :             break;

  01563	e9 1f 1b 00 00	 jmp	 $L108897
$L109017:

; 1638 : 
; 1639 :         case SPARK_CustomCloud:  // Custom CLOUDS that move at DrawByteA's speed.
; 1640 :             if( (ActiveSparkNum < (SparksLimit)) )

  01568	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  0156e	0f 8d d1 00 00
	00		 jge	 $L109018

; 1641 :             {
; 1642 :                 // Create it.
; 1643 :                 INT  NS = ActiveSparkNum++;

  01574	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01577	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1644 :                 Sparks(NS).Type = ISPARK_Move; //

  0157d	c6 04 df 25	 mov	 BYTE PTR [edi+ebx*8], 37 ; 00000025H

; 1645 :                 Sparks(NS).X = UMask & (ThisSpark->X + (SpeedRand()&31));

  01581	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01587	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0158d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01593	83 c2 04	 add	 edx, 4
  01596	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0159c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  015a2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  015a8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  015ae	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  015b4	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  015b8	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  015be	24 1f		 and	 al, 31			; 0000001fH
  015c0	02 c1		 add	 al, cl
  015c2	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  015c8	22 c2		 and	 al, dl
  015ca	88 44 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], al

; 1646 :                 Sparks(NS).Y = VMask & (ThisSpark->Y + (SpeedRand()&31));

  015ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  015d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  015da	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  015e0	83 c2 04	 add	 edx, 4
  015e3	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  015e9	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  015ef	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  015f5	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  015fb	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01601	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01605	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  0160b	24 1f		 and	 al, 31			; 0000001fH
  0160d	02 c2		 add	 al, dl
  0160f	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01615	22 c1		 and	 al, cl
  01617	88 44 da 03	 mov	 BYTE PTR [edx+ebx*8+3], al

; 1647 :                 Sparks(NS).ByteA = ThisSpark->ByteA; // X speed

  0161b	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01621	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  01625	88 4c d8 04	 mov	 BYTE PTR [eax+ebx*8+4], cl

; 1648 :                 Sparks(NS).ByteB = ThisSpark->ByteB; // Y speed

  01629	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  0162f	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01633	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1649 :                 Sparks(NS).ByteC = ThisSpark->ByteD; // timer==heat

  01637	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0163d	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  01641	88 54 d9 06	 mov	 BYTE PTR [ecx+ebx*8+6], dl
$L109018:

; 1650 :             }
; 1651 : 
; 1652 :             // Move around a bit.
; 1653 :             ThisSpark->X = UMask & (ThisSpark->X+(SpeedRand()&7)-(SpeedRand()&7));

  01645	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0164b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01651	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01657	83 c2 04	 add	 edx, 4
  0165a	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01660	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01666	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0166c	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01672	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01678	8a d8		 mov	 bl, al
  0167a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01680	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01686	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0168c	83 c2 04	 add	 edx, 4
  0168f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01695	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0169b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  016a1	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  016a7	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  016ad	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  016b1	24 07		 and	 al, 7
  016b3	80 e3 07	 and	 bl, 7
  016b6	2a d8		 sub	 bl, al
  016b8	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  016be	02 d9		 add	 bl, cl
  016c0	22 d8		 and	 bl, al
  016c2	88 5c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], bl

; 1654 :             ThisSpark->Y = VMask & (ThisSpark->Y+(SpeedRand()&7)-(SpeedRand()&7));

  016c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  016cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  016d2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  016d8	83 c2 04	 add	 edx, 4
  016db	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  016e1	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  016e7	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  016ed	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  016f3	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  016f9	8a d8		 mov	 bl, al
  016fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01701	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01707	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0170d	83 c2 04	 add	 edx, 4
  01710	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01716	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0171c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01722	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01728	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1655 :             break;

  0172e	e9 e9 02 00 00	 jmp	 $L118578
$L109020:

; 1656 : 
; 1657 : 		case SPARK_LocalCloud: // Custom clouds that move at DrawByteA's speed.
; 1658 :             if( (ActiveSparkNum < (SparksLimit)) )

  01733	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01739	0f 8d 48 19 00
	00		 jge	 $L108897

; 1659 :             {
; 1660 :                 // create it..
; 1661 :                 INT  NS = ActiveSparkNum++;

  0173f	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01742	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1662 :                 Sparks(NS).Type = ISPARK_Move; //

  01748	c6 04 df 25	 mov	 BYTE PTR [edi+ebx*8], 37 ; 00000025H

; 1663 : 				Sparks(NS).X = UMask & (ThisSpark->X + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  0174c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01752	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01758	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0175e	83 c2 04	 add	 edx, 4
  01761	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01767	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0176d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01773	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01779	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0177f	0f b6 54 ef 06	 movzx	 edx, BYTE PTR [edi+ebp*8+6]
  01784	33 c9		 xor	 ecx, ecx
  01786	8a c8		 mov	 cl, al
  01788	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  0178c	0f af ca	 imul	 ecx, edx
  0178f	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  01795	c1 f9 08	 sar	 ecx, 8
  01798	02 c8		 add	 cl, al
  0179a	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  017a0	22 ca		 and	 cl, dl
  017a2	88 4c d8 02	 mov	 BYTE PTR [eax+ebx*8+2], cl

; 1664 : 				Sparks(NS).Y = VMask & (ThisSpark->Y + ((SpeedRand() * ThisSpark->ByteC) >> 8));

  017a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  017ac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  017b2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  017b8	83 c2 04	 add	 edx, 4
  017bb	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  017c1	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  017c7	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  017cd	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  017d3	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  017d9	0f b6 54 ef 06	 movzx	 edx, BYTE PTR [edi+ebp*8+6]
  017de	33 c9		 xor	 ecx, ecx
  017e0	8a c8		 mov	 cl, al
  017e2	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  017e8	0f af ca	 imul	 ecx, edx
  017eb	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  017ef	c1 f9 08	 sar	 ecx, 8
  017f2	02 ca		 add	 cl, dl
  017f4	22 c8		 and	 cl, al
  017f6	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  017fc	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1665 :                 Sparks(NS).ByteA = ThisSpark->ByteA;  

  01800	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01806	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  0180a	88 54 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], dl

; 1666 :                 Sparks(NS).ByteB = ThisSpark->ByteB; 

  0180e	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01814	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  01818	88 4c d8 05	 mov	 BYTE PTR [eax+ebx*8+5], cl

; 1667 :                 Sparks(NS).ByteC = ThisSpark->ByteD; // timer==heat

  0181c	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01822	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  01826	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1668 :             }
; 1669 :             break;

  0182a	e9 58 18 00 00	 jmp	 $L108897
$L109023:

; 1670 : 
; 1671 :         case SPARK_Flocks: // CLOUDS that move at DrawByteA's speed...
; 1672 :             if( (ActiveSparkNum < (SparksLimit)) )

  0182f	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01835	0f 8d f8 00 00
	00		 jge	 $L109024

; 1673 :             {
; 1674 :                 // Create it..
; 1675 :                 INT  NS = ActiveSparkNum++;

  0183b	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  0183e	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx

; 1676 :                 Sparks(NS).Type  = ISPARK_SpawnedTwirl;

  01844	c6 04 df 27	 mov	 BYTE PTR [edi+ebx*8], 39 ; 00000027H

; 1677 :                 Sparks(NS).X     = UMask & (ThisSpark->X + (SpeedRand()&31));

  01848	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0184e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01854	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0185a	83 c2 04	 add	 edx, 4
  0185d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01863	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01869	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0186f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01875	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0187b	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0187f	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  01885	24 1f		 and	 al, 31			; 0000001fH
  01887	02 c1		 add	 al, cl
  01889	22 c2		 and	 al, dl
  0188b	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01891	88 44 da 02	 mov	 BYTE PTR [edx+ebx*8+2], al

; 1678 :                 Sparks(NS).Y     = VMask & (ThisSpark->Y + (SpeedRand()&31));

  01895	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0189b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  018a1	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  018a7	83 c2 04	 add	 edx, 4
  018aa	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  018b0	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  018b6	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  018bc	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  018c2	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  018c8	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  018cc	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  018d2	24 1f		 and	 al, 31			; 0000001fH
  018d4	02 c2		 add	 al, dl
  018d6	22 c1		 and	 al, cl
  018d8	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  018de	88 44 d9 03	 mov	 BYTE PTR [ecx+ebx*8+3], al

; 1679 : 				Sparks(NS).ByteB = ThisSpark->ByteA;  // Initial direction.

  018e2	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  018e6	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  018ec	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1680 : 				Sparks(NS).ByteA=0;                 // low byte

  018f0	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  018f6	c6 44 d9 04 00	 mov	 BYTE PTR [ecx+ebx*8+4], 0

; 1681 :                 Sparks(NS).ByteC = ThisSpark->ByteB;  // Timer / Size 

  018fb	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01901	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01905	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1682 : 				Sparks(NS).ByteD = ThisSpark->ByteD;  // Angle delta

  01909	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  0190f	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  01913	88 54 d9 07	 mov	 BYTE PTR [ecx+ebx*8+7], dl

; 1683 : 				Sparks(NS).Heat  = ThisSpark->Heat;

  01917	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  0191d	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  01921	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl

; 1684 : 
; 1685 : 				//if( SpeedRand()<1 ) 
; 1686 : 				//	ThisSpark->ByteA = SpeedRand(); // change about every XX sparks
; 1687 : 				//else
; 1688 : 				ThisSpark->ByteA += ThisSpark->ByteC; // Turn spawn direction.

  01925	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  01929	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  0192d	02 c2		 add	 al, dl
  0192f	88 44 ef 04	 mov	 BYTE PTR [edi+ebp*8+4], al
$L109024:

; 1689 :             }
; 1690 :             // move around a bit
; 1691 :             ThisSpark->X = UMask & ( ThisSpark->X + (SpeedRand()&7) - (SpeedRand()&7) );

  01933	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01939	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0193f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01945	83 c2 04	 add	 edx, 4
  01948	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0194e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01954	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0195a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01960	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01966	8a d8		 mov	 bl, al
  01968	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0196e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01974	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0197a	83 c2 04	 add	 edx, 4
  0197d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01983	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01989	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0198f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01995	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0199b	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0199f	24 07		 and	 al, 7
  019a1	80 e3 07	 and	 bl, 7
  019a4	2a d8		 sub	 bl, al
  019a6	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  019ac	02 d9		 add	 bl, cl
  019ae	22 d8		 and	 bl, al
  019b0	88 5c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], bl

; 1692 :             ThisSpark->Y = VMask & ( ThisSpark->Y + (SpeedRand()&7) - (SpeedRand()&7) );

  019b4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  019ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  019c0	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  019c6	83 c2 04	 add	 edx, 4
  019c9	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  019cf	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  019d5	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  019db	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  019e1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  019e7	8a d8		 mov	 bl, al
  019e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  019ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  019f5	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  019fb	83 c2 04	 add	 edx, 4
  019fe	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01a04	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01a0a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01a10	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01a16	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L118578:
  01a1c	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  01a20	24 07		 and	 al, 7
  01a22	80 e3 07	 and	 bl, 7
  01a25	8d 7c ef 03	 lea	 edi, DWORD PTR [edi+ebp*8+3]
  01a29	2a d8		 sub	 bl, al
  01a2b	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  01a31	02 d9		 add	 bl, cl
  01a33	22 d8		 and	 bl, al
  01a35	88 1f		 mov	 BYTE PTR [edi], bl

; 1693 :             break;

  01a37	e9 4b 16 00 00	 jmp	 $L108897
$L109026:

; 1694 : 
; 1695 : 		case SPARK_Wheel:  // CLOUDS that move at DrawByteA's speed.
; 1696 :             if( (ActiveSparkNum < (SparksLimit)) )

  01a3c	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01a42	7d 6c		 jge	 SHORT $L109027

; 1697 :             {   // Create it..
; 1698 :                 INT  NS = ActiveSparkNum++;

  01a44	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01a47	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1699 :                 Sparks(NS).Type = ISPARK_SpawnedTwirl;

  01a4d	c6 04 df 27	 mov	 BYTE PTR [edi+ebx*8], 39 ; 00000027H

; 1700 :                 Sparks(NS).X = ThisSpark->X ;

  01a51	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01a57	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01a5b	88 54 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], dl

; 1701 :                 Sparks(NS).Y = ThisSpark->Y ;

  01a5f	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01a65	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  01a69	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1702 :                 Sparks(NS).ByteB  = ThisSpark->ByteA;      // Initial Direction.

  01a6d	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  01a71	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01a77	88 44 da 05	 mov	 BYTE PTR [edx+ebx*8+5], al

; 1703 : 				Sparks(NS).ByteA =0;                     // low byte

  01a7b	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01a81	c6 44 d9 04 00	 mov	 BYTE PTR [ecx+ebx*8+4], 0

; 1704 :                 Sparks(NS).ByteC  = ThisSpark->ByteB;      // Timer/ Size

  01a86	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01a8c	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01a90	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1705 : 				Sparks(NS).ByteD  = ThisSpark->ByteD;      // 2 << 3 ; //ThisSpark->ByteD;      // Angle delta.

  01a94	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01a9a	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  01a9e	88 54 d9 07	 mov	 BYTE PTR [ecx+ebx*8+7], dl

; 1706 : 				Sparks(NS).Heat   = ThisSpark->Heat;

  01aa2	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01aa8	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  01aac	88 4c d8 01	 mov	 BYTE PTR [eax+ebx*8+1], cl
$L109027:

; 1707 :             }
; 1708 : 			ThisSpark->ByteA += ThisSpark->ByteC;      // Turn spawn direction.

  01ab0	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  01ab4	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  01ab8	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  01abc	02 ca		 add	 cl, dl

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  01abe	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  01ac0	e9 c2 15 00 00	 jmp	 $L108897
$L109029:

; 1709 :             break;
; 1710 : 
; 1711 : 		case SPARK_Sprinkler:  
; 1712 :             if( (ActiveSparkNum < (SparksLimit)) )

  01ac5	3b 9e f4 00 00
	00		 cmp	 ebx, DWORD PTR [esi+244]
  01acb	7d 6c		 jge	 SHORT $L109030

; 1713 :             {   // Create it..
; 1714 :                 INT  NS = ActiveSparkNum++;

  01acd	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  01ad0	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 1715 :                 Sparks(NS).Type = ISPARK_SprinklerTwirl;

  01ad6	c6 04 df 28	 mov	 BYTE PTR [edi+ebx*8], 40 ; 00000028H

; 1716 :                 Sparks(NS).X = ThisSpark->X ;

  01ada	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01ae0	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01ae4	88 54 d9 02	 mov	 BYTE PTR [ecx+ebx*8+2], dl

; 1717 :                 Sparks(NS).Y = ThisSpark->Y ;

  01ae8	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01aee	8a 4c ef 03	 mov	 cl, BYTE PTR [edi+ebp*8+3]
  01af2	88 4c d8 03	 mov	 BYTE PTR [eax+ebx*8+3], cl

; 1718 : 				Sparks(NS).Heat = ThisSpark->Heat;

  01af6	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01afc	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01b00	88 44 da 01	 mov	 BYTE PTR [edx+ebx*8+1], al

; 1719 :                 Sparks(NS).ByteA  = ThisSpark->ByteA;      // Initial Direction.

  01b04	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01b0a	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  01b0e	88 54 d9 04	 mov	 BYTE PTR [ecx+ebx*8+4], dl

; 1720 :                 Sparks(NS).ByteB  = ThisSpark->ByteB;      // 

  01b12	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  01b18	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  01b1c	88 4c d8 05	 mov	 BYTE PTR [eax+ebx*8+5], cl

; 1721 : 				Sparks(NS).ByteC  = ThisSpark->ByteC;

  01b20	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  01b26	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01b2a	88 44 da 06	 mov	 BYTE PTR [edx+ebx*8+6], al

; 1722 : 				Sparks(NS).ByteD  = 2; //ThisSpark->ByteD;      // Angle delta.

  01b2e	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  01b34	c6 44 d9 07 02	 mov	 BYTE PTR [ecx+ebx*8+7], 2
$L109030:

; 1723 :             }
; 1724 : 			ThisSpark->ByteA += ThisSpark->ByteD;      // Turn spawn direction.

  01b39	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  01b3d	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  01b41	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  01b45	02 ca		 add	 cl, dl

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  01b47	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  01b49	e9 39 15 00 00	 jmp	 $L108897
$L109032:

; 1725 :             break;
; 1726 : 
; 1727 :         case SPARK_Stars: // FIXED STARS ! dim according to fire Intensity..
; 1728 : 			{
; 1729 :             // called here just BEFORE update: so RESTORE original pixel.
; 1730 :             // ByteA has the star itself, ByteB the saved bckgrnd
; 1731 : 				DWORD SparkDest = (DWORD)(ThisSpark->X + (ThisSpark->Y << UBits ));
; 1732 : 				Mips(0).DataArray(SparkDest) = ThisSpark->ByteB;

  01b4e	0f b6 44 ef 03	 movzx	 eax, BYTE PTR [edi+ebp*8+3]
  01b53	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  01b56	d3 e0		 shl	 eax, cl
  01b58	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  01b5e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  01b61	8a 4c ef 05	 mov	 cl, BYTE PTR [edi+ebp*8+5]
  01b65	03 c2		 add	 eax, edx
  01b67	0f b6 54 ef 02	 movzx	 edx, BYTE PTR [edi+ebp*8+2]
  01b6c	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1733 : 			}
; 1734 :             break;

  01b6f	e9 13 15 00 00	 jmp	 $L108897
$L109035:

; 1735 : 
; 1736 :         case SPARK_LineLightning:     // Emitting lightning - random bursts, FIXED locations.
; 1737 :             if( ThisSpark->Heat == 0 ) // Too-small bolts have Heat 0

  01b74	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01b78	84 c0		 test	 al, al
  01b7a	8d 4c ef 01	 lea	 ecx, DWORD PTR [edi+ebp*8+1]
  01b7e	0f 84 03 15 00
	00		 je	 $L108897

; 1738 :                 break;
; 1739 :             // Flash in progress ?
; 1740 :             if( ThisSpark->ByteC  > 0 )

  01b84	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01b88	84 c0		 test	 al, al
  01b8a	8d 5c ef 06	 lea	 ebx, DWORD PTR [edi+ebp*8+6]
  01b8e	76 41		 jbe	 SHORT $L109037

; 1741 :             {
; 1742 :                 ThisSpark->ByteC--;  // Countdown effect
; 1743 :                 LineSeg LL;
; 1744 :                 LL.Xlen = ThisSpark->ByteA;
; 1745 :                 LL.Ylen = ThisSpark->ByteB;
; 1746 :                 LL.Xpos = ThisSpark->X;
; 1747 :                 LL.Ypos = ThisSpark->Y;
; 1748 : 				BYTE HeatA = ThisSpark->Heat;

  01b90	8a 09		 mov	 cl, BYTE PTR [ecx]
  01b92	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  01b96	fe c8		 dec	 al
  01b98	88 03		 mov	 BYTE PTR [ebx], al
  01b9a	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01b9e	88 44 24 1f	 mov	 BYTE PTR _LL$109038[esp+59], al
  01ba2	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  01ba6	88 4c 24 28	 mov	 BYTE PTR _HeatA$109039[esp+56], cl
  01baa	88 44 24 1d	 mov	 BYTE PTR _LL$109038[esp+57], al

; 1749 : 				DrawFlashRamp(LL, HeatA, HeatA);

  01bae	8b 44 24 28	 mov	 eax, DWORD PTR _HeatA$109039[esp+56]
  01bb2	88 54 24 1e	 mov	 BYTE PTR _LL$109038[esp+58], dl
  01bb6	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  01bba	50		 push	 eax
  01bbb	88 54 24 20	 mov	 BYTE PTR _LL$109038[esp+60], dl
  01bbf	8b 54 24 20	 mov	 edx, DWORD PTR _LL$109038[esp+60]
  01bc3	50		 push	 eax
  01bc4	52		 push	 edx
  01bc5	8b ce		 mov	 ecx, esi
  01bc7	e8 00 00 00 00	 call	 ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ; UFireTexture::DrawFlashRamp

; 1750 :             }
; 1751 :             else

  01bcc	e9 b6 14 00 00	 jmp	 $L108897
$L109037:

; 1752 :             if( SpeedRand() >= ThisSpark->ByteD )

  01bd1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01bd7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01bdd	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01be3	83 c2 04	 add	 edx, 4
  01be6	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01bec	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01bf2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01bf8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01bfe	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01c04	3a 44 ef 07	 cmp	 al, BYTE PTR [edi+ebp*8+7]
  01c08	0f 82 79 14 00
	00		 jb	 $L108897

; 1753 :             // Initiate new flash ?
; 1754 :             {
; 1755 :                 ThisSpark->ByteC = 1+ SpeedRand() & 5;

  01c0e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01c14	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01c1a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01c20	83 c2 04	 add	 edx, 4
  01c23	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01c29	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01c2f	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01c35	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01c3b	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01c41	fe c0		 inc	 al
  01c43	24 05		 and	 al, 5

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  01c45	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  01c47	e9 3b 14 00 00	 jmp	 $L108897
$L109042:

; 1756 :             }
; 1757 :             break;
; 1758 : 
; 1759 :         case SPARK_RampLightning:     // Emitting lightning - random bursts, FIXED locations.
; 1760 :             if( ThisSpark->Heat == 0 ) // Too-small bolts have heat 0

  01c4c	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01c50	84 c0		 test	 al, al
  01c52	8d 4c ef 01	 lea	 ecx, DWORD PTR [edi+ebp*8+1]
  01c56	0f 84 2b 14 00
	00		 je	 $L108897

; 1761 :                 break;
; 1762 :             // Flash in progress ?
; 1763 :             if( ThisSpark->ByteC  > 0 )

  01c5c	8a 44 ef 06	 mov	 al, BYTE PTR [edi+ebp*8+6]
  01c60	84 c0		 test	 al, al
  01c62	8d 5c ef 06	 lea	 ebx, DWORD PTR [edi+ebp*8+6]
  01c66	76 46		 jbe	 SHORT $L109044

; 1764 :             {
; 1765 :                 ThisSpark->ByteC--; // Countdown.
; 1766 :                 LineSeg LL;
; 1767 :                 LL.Xlen = ThisSpark->ByteA;
; 1768 :                 LL.Ylen = ThisSpark->ByteB;

  01c68	8a 54 ef 05	 mov	 dl, BYTE PTR [edi+ebp*8+5]
  01c6c	fe c8		 dec	 al
  01c6e	88 03		 mov	 BYTE PTR [ebx], al
  01c70	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  01c74	88 44 24 22	 mov	 BYTE PTR _LL$109045[esp+58], al

; 1769 :                 LL.Xpos = ThisSpark->X;

  01c78	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  01c7c	88 44 24 20	 mov	 BYTE PTR _LL$109045[esp+56], al

; 1770 :                 LL.Ypos = ThisSpark->Y;
; 1771 : 				BYTE HeatA = ThisSpark->Heat;
; 1772 : 				BYTE HeatB = HeatA >> 3;
; 1773 :                 DrawFlashRamp( LL, HeatA, HeatB);

  01c80	33 c0		 xor	 eax, eax
  01c82	8a 01		 mov	 al, BYTE PTR [ecx]
  01c84	88 44 24 2c	 mov	 BYTE PTR _HeatA$109046[esp+56], al
  01c88	c0 e8 03	 shr	 al, 3
  01c8b	88 54 24 23	 mov	 BYTE PTR _LL$109045[esp+59], dl
  01c8f	8a 54 ef 03	 mov	 dl, BYTE PTR [edi+ebp*8+3]
  01c93	88 54 24 21	 mov	 BYTE PTR _LL$109045[esp+57], dl
  01c97	8b 4c 24 20	 mov	 ecx, DWORD PTR _LL$109045[esp+56]
  01c9b	50		 push	 eax
  01c9c	8b 44 24 30	 mov	 eax, DWORD PTR _HeatA$109046[esp+60]
  01ca0	50		 push	 eax
  01ca1	51		 push	 ecx
  01ca2	8b ce		 mov	 ecx, esi
  01ca4	e8 00 00 00 00	 call	 ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ; UFireTexture::DrawFlashRamp

; 1774 :             }
; 1775 :             else

  01ca9	e9 d9 13 00 00	 jmp	 $L108897
$L109044:

; 1776 :             if( SpeedRand() >= ThisSpark->ByteD )

  01cae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01cb4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01cba	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01cc0	83 c2 04	 add	 edx, 4
  01cc3	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01cc9	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01ccf	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01cd5	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01cdb	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01ce1	3a 44 ef 07	 cmp	 al, BYTE PTR [edi+ebp*8+7]
  01ce5	0f 82 9c 13 00
	00		 jb	 $L108897

; 1777 :             // Initiate new flash ?
; 1778 :             {
; 1779 :                 ThisSpark->ByteC = 1 + SpeedRand() & 5;

  01ceb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01cf1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01cf7	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01cfd	83 c2 04	 add	 edx, 4
  01d00	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01d06	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01d0c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01d12	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01d18	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01d1e	fe c0		 inc	 al
  01d20	24 05		 and	 al, 5

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  01d22	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  01d24	e9 5e 13 00 00	 jmp	 $L108897
$L109050:

; 1780 :             }
; 1781 :             break;
; 1782 : 
; 1783 :         case SPARK_SphereLightning: // Radial lightning from source point.
; 1784 :             if( SpeedRand() >= ThisSpark->ByteD ) // Frequency.

  01d29	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01d2f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01d35	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d3b	83 c2 04	 add	 edx, 4
  01d3e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01d44	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01d4a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01d50	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01d56	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01d5c	3a 44 ef 07	 cmp	 al, BYTE PTR [edi+ebp*8+7]
  01d60	0f 82 21 13 00
	00		 jb	 $L108897

; 1785 :             {
; 1786 :                 INT  SparkAngle = SpeedRand();

  01d66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01d6c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01d72	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01d78	83 c2 04	 add	 edx, 4
  01d7b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01d81	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01d87	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01d8d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01d93	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1787 :                 INT  Radius = ThisSpark->ByteC;

  01d99	0f b6 5c ef 06	 movzx	 ebx, BYTE PTR [edi+ebp*8+6]
  01d9e	33 c9		 xor	 ecx, ecx
  01da0	8a c8		 mov	 cl, al

; 1788 : 
; 1789 : 				BYTE  Col1 = ThisSpark->Heat;

  01da2	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  01da6	88 44 24 34	 mov	 BYTE PTR _Col1$109054[esp+56], al

; 1790 : 				BYTE  Col2 = ThisSpark->Heat >> 2; // Taper off to (relative) darkness.

  01daa	c0 e8 02	 shr	 al, 2
  01dad	88 44 24 30	 mov	 BYTE PTR _Col2$109055[esp+56], al

; 1791 : 
; 1792 :                 INT  SdispX = ( Radius * ( (INT)PhaseTable[SparkAngle] ) ) >> 8;
; 1793 :                 INT  SdispY = ( Radius * ( (INT)PhaseTable[(SparkAngle+64) & 255] ) ) >> 8;
; 1794 : 
; 1795 :   				LineSeg LL;
; 1796 : 
; 1797 :                 INT  Xlen =  (INT)SdispX - (INT)(Radius/2);

  01db1	8b c3		 mov	 eax, ebx
  01db3	99		 cdq
  01db4	2b c2		 sub	 eax, edx
  01db6	89 4c 24 18	 mov	 DWORD PTR _SparkAngle$109052[esp+56], ecx
  01dba	8b 54 24 18	 mov	 edx, DWORD PTR _SparkAngle$109052[esp+56]
  01dbe	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR _PhaseTable[ecx]
  01dc5	83 c2 40	 add	 edx, 64			; 00000040H
  01dc8	0f af cb	 imul	 ecx, ebx
  01dcb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH

; 1798 :                 INT  Ylen =  (INT)SdispY - (INT)(Radius/2);

  01dd1	0f b6 92 00 00
	00 00		 movzx	 edx, BYTE PTR _PhaseTable[edx]
  01dd8	0f af d3	 imul	 edx, ebx
  01ddb	d1 f8		 sar	 eax, 1
  01ddd	c1 f9 08	 sar	 ecx, 8
  01de0	c1 fa 08	 sar	 edx, 8
  01de3	2b c8		 sub	 ecx, eax
  01de5	2b d0		 sub	 edx, eax

; 1799 : 
; 1800 : 				LL.Xpos = ThisSpark->X;
; 1801 : 				LL.Ypos = ThisSpark->Y;
; 1802 : 
; 1803 :                 // Cram the sign bit into the lsbit.
; 1804 : 				if( Xlen<=0 )   Xlen  = (- Xlen) | 1;

  01de7	85 c9		 test	 ecx, ecx
  01de9	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  01ded	88 44 24 24	 mov	 BYTE PTR _LL$109060[esp+56], al
  01df1	8a 44 ef 03	 mov	 al, BYTE PTR [edi+ebp*8+3]
  01df5	88 44 24 25	 mov	 BYTE PTR _LL$109060[esp+57], al
  01df9	7f 07		 jg	 SHORT $L109067
  01dfb	f7 d9		 neg	 ecx
  01dfd	83 c9 01	 or	 ecx, 1

; 1805 :                     else		Xlen &= 0xFFFFFFFE;

  01e00	eb 03		 jmp	 SHORT $L109068
$L109067:
  01e02	83 e1 fe	 and	 ecx, -2			; fffffffeH
$L109068:

; 1806 : 				if( Ylen<=0 )   Ylen  = (- Ylen) | 1;

  01e05	85 d2		 test	 edx, edx
  01e07	7f 07		 jg	 SHORT $L109069
  01e09	f7 da		 neg	 edx
  01e0b	83 ca 01	 or	 edx, 1

; 1807 :                     else		Ylen &= 0xFFFFFFFE;

  01e0e	eb 03		 jmp	 SHORT $L109070
$L109069:
  01e10	83 e2 fe	 and	 edx, -2			; fffffffeH
$L109070:

; 1808 : 
; 1809 : 				LL.Xlen = Xlen;

  01e13	88 4c 24 26	 mov	 BYTE PTR _LL$109060[esp+58], cl

; 1810 : 				LL.Ylen = Ylen;
; 1811 : 
; 1812 :                 DrawFlashRamp( LL, Col1,Col2);

  01e17	8b 4c 24 30	 mov	 ecx, DWORD PTR _Col2$109055[esp+56]
  01e1b	88 54 24 27	 mov	 BYTE PTR _LL$109060[esp+59], dl
  01e1f	8b 54 24 34	 mov	 edx, DWORD PTR _Col1$109054[esp+56]
  01e23	8b 44 24 24	 mov	 eax, DWORD PTR _LL$109060[esp+56]
  01e27	51		 push	 ecx
  01e28	52		 push	 edx
  01e29	50		 push	 eax
  01e2a	8b ce		 mov	 ecx, esi
  01e2c	e8 00 00 00 00	 call	 ?DrawFlashRamp@UFireTexture@@AAEXULineSeg@@EE@Z ; UFireTexture::DrawFlashRamp

; 1813 :             }
; 1814 :             break;

  01e31	e9 51 12 00 00	 jmp	 $L108897
$L109071:

; 1815 : 
; 1816 :         //
; 1817 :         //  Transient /spawned sparks, emitted by lower spark types.
; 1818 :         //
; 1819 : 
; 1820 :         //  Dynamic emitted sparks. General linear 'drifter', limited lifetime.
; 1821 :         case ISPARK_Drifter:
; 1822 :             if( (( ThisSpark->Heat -= 5 ) < 251 )  )  // Glow out fast.

  01e36	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  01e3a	80 c2 fb	 add	 dl, 251			; 000000fbH
  01e3d	8a c2		 mov	 al, dl
  01e3f	3c fb		 cmp	 al, 251			; 000000fbH
  01e41	88 54 ef 01	 mov	 BYTE PTR [edi+ebp*8+1], dl
  01e45	0f 83 1b 12 00
	00		 jae	 $L109139

; 1823 :             {
; 1824 :                 DWORD SparkDest = (DWORD) (ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1825 :                 // Set spark.
; 1826 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  01e4b	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  01e50	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  01e53	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  01e57	d3 e2		 shl	 edx, cl
  01e59	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  01e5f	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  01e62	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  01e67	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1827 :                 // Advance position.
; 1828 :                 MoveSpark( ThisSpark );

  01e6a	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  01e6e	84 c0		 test	 al, al
  01e70	7d 55		 jge	 SHORT $L118089
  01e72	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01e78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01e7e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01e84	83 c2 04	 add	 edx, 4
  01e87	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01e8d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01e93	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01e99	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01e9f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01ea5	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  01eaa	f7 da		 neg	 edx
  01eac	83 e0 7f	 and	 eax, 127		; 0000007fH
  01eaf	3b c2		 cmp	 eax, edx
  01eb1	7d 64		 jge	 SHORT $L118092
  01eb3	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  01eb7	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  01ebd	fe c8		 dec	 al
  01ebf	22 c1		 and	 al, cl
  01ec1	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  01ec5	eb 50		 jmp	 SHORT $L118092
$L118089:
  01ec7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01ecd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01ed3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01ed9	83 c2 04	 add	 edx, 4
  01edc	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01ee2	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01ee8	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01eee	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01ef4	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01efa	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  01efe	83 e0 7f	 and	 eax, 127		; 0000007fH
  01f01	3a c1		 cmp	 al, cl
  01f03	7d 12		 jge	 SHORT $L118092
  01f05	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  01f09	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  01f0f	fe c1		 inc	 cl
  01f11	22 c8		 and	 cl, al
  01f13	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L118092:
  01f17	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  01f1b	84 c0		 test	 al, al
  01f1d	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  01f21	7d 56		 jge	 SHORT $L118093
  01f23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01f29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01f2f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f35	83 c2 04	 add	 edx, 4
  01f38	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01f3e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01f44	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01f4a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01f50	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  01f56	0f be 17	 movsx	 edx, BYTE PTR [edi]
  01f59	f7 da		 neg	 edx
  01f5b	83 e0 7f	 and	 eax, 127		; 0000007fH
  01f5e	3b c2		 cmp	 eax, edx
  01f60	0f 8d 21 11 00
	00		 jge	 $L108897
  01f66	8a 03		 mov	 al, BYTE PTR [ebx]
  01f68	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  01f6e	fe c8		 dec	 al
  01f70	22 c8		 and	 cl, al
  01f72	88 0b		 mov	 BYTE PTR [ebx], cl
  01f74	e9 0e 11 00 00	 jmp	 $L108897
$L118093:
  01f79	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  01f7f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  01f85	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  01f8b	83 c2 04	 add	 edx, 4
  01f8e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  01f94	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  01f9a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  01fa0	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  01fa6	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L118572:
  01fac	8a 0f		 mov	 cl, BYTE PTR [edi]
  01fae	83 e0 7f	 and	 eax, 127		; 0000007fH
  01fb1	3a c1		 cmp	 al, cl
  01fb3	0f 8d ce 10 00
	00		 jge	 $L108897
  01fb9	8a 13		 mov	 dl, BYTE PTR [ebx]
  01fbb	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  01fc1	fe c2		 inc	 dl
  01fc3	22 c2		 and	 al, dl
  01fc5	88 03		 mov	 BYTE PTR [ebx], al

; 1829 :                 // No gravity.
; 1830 :             }
; 1831 :             else  // Delete the spark.
; 1832 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1833 :             break;

  01fc7	e9 bb 10 00 00	 jmp	 $L108897
$L109076:

; 1834 : 
; 1835 : 
; 1836 :         // Dynamic emitted sparks. Linear movement, longer lifetime.
; 1837 :         case ISPARK_DriftSlow:
; 1838 :             if( ( ThisSpark->Heat -= ThisSpark->ByteD ) > ThisSpark->ByteD ) // Glow out.

  01fcc	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  01fd0	8a 5c ef 01	 mov	 bl, BYTE PTR [edi+ebp*8+1]
  01fd4	2a d9		 sub	 bl, cl
  01fd6	8a c3		 mov	 al, bl
  01fd8	3a c1		 cmp	 al, cl
  01fda	88 5c ef 01	 mov	 BYTE PTR [edi+ebp*8+1], bl
  01fde	0f 86 82 10 00
	00		 jbe	 $L109139

; 1839 :             {
; 1840 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ) );
; 1841 :                 // Set spark.
; 1842 :                 Mips(0).DataArray( SparkDest ) = ThisSpark->Heat;

  01fe4	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  01fe9	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  01fec	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  01ff0	d3 e2		 shl	 edx, cl
  01ff2	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  01ff8	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  01ffb	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  02000	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1843 :                 // Advance position.
; 1844 :                 MoveSpark( ThisSpark );

  02003	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  02007	84 c0		 test	 al, al
  02009	7d 55		 jge	 SHORT $L118133
  0200b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02011	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02017	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0201d	83 c2 04	 add	 edx, 4
  02020	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02026	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0202c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02032	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02038	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0203e	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  02043	f7 da		 neg	 edx
  02045	83 e0 7f	 and	 eax, 127		; 0000007fH
  02048	3b c2		 cmp	 eax, edx
  0204a	7d 64		 jge	 SHORT $L118136
  0204c	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  02050	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02056	fe c8		 dec	 al
  02058	22 c1		 and	 al, cl
  0205a	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  0205e	eb 50		 jmp	 SHORT $L118136
$L118133:
  02060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02066	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0206c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02072	83 c2 04	 add	 edx, 4
  02075	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0207b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02081	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02087	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0208d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02093	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02097	83 e0 7f	 and	 eax, 127		; 0000007fH
  0209a	3a c1		 cmp	 al, cl
  0209c	7d 12		 jge	 SHORT $L118136
  0209e	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  020a2	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  020a8	fe c1		 inc	 cl
  020aa	22 c8		 and	 cl, al
  020ac	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L118136:
  020b0	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  020b4	84 c0		 test	 al, al
  020b6	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  020ba	7d 56		 jge	 SHORT $L118137
  020bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  020c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  020c8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  020ce	83 c2 04	 add	 edx, 4
  020d1	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  020d7	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  020dd	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  020e3	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  020e9	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  020ef	0f be 17	 movsx	 edx, BYTE PTR [edi]
  020f2	f7 da		 neg	 edx
  020f4	83 e0 7f	 and	 eax, 127		; 0000007fH
  020f7	3b c2		 cmp	 eax, edx
  020f9	0f 8d 88 0f 00
	00		 jge	 $L108897
  020ff	8a 03		 mov	 al, BYTE PTR [ebx]
  02101	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02107	fe c8		 dec	 al
  02109	22 c8		 and	 cl, al
  0210b	88 0b		 mov	 BYTE PTR [ebx], cl
  0210d	e9 75 0f 00 00	 jmp	 $L108897
$L118137:
  02112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02118	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0211e	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02124	83 c2 04	 add	 edx, 4
  02127	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0212d	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02133	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02139	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0213f	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1845 :                 // No gravity.
; 1846 :             }
; 1847 :             else // Delete the spark.
; 1848 : 				*ThisSpark = Sparks( --ActiveSparkNum );
; 1849 :             break;

  02145	e9 62 fe ff ff	 jmp	 $L118572
$L109081:

; 1850 : 
; 1851 : 
; 1852 :         //  Dynamic emitted sparks. General: adjustable lifetime and speed.
; 1853 :         case ISPARK_Custom:
; 1854 :             if   ( (( ThisSpark->Heat -= ThisSpark->ByteC ) < 250 )  )  // Glow out slower.

  0214a	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  0214e	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02152	2a d1		 sub	 dl, cl
  02154	8a c2		 mov	 al, dl
  02156	3c fa		 cmp	 al, 250			; 000000faH
  02158	88 54 ef 01	 mov	 BYTE PTR [edi+ebp*8+1], dl
  0215c	0f 83 04 0f 00
	00		 jae	 $L109139

; 1855 :             {
; 1856 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1857 :                 // Set spark.
; 1858 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02162	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  02167	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0216a	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  0216e	d3 e2		 shl	 edx, cl
  02170	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02176	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  02179	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  0217e	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1859 :                 // Advance position.
; 1860 :                 MoveSpark( ThisSpark );

  02181	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  02185	84 c0		 test	 al, al
  02187	7d 55		 jge	 SHORT $L118177
  02189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0218f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02195	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0219b	83 c2 04	 add	 edx, 4
  0219e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  021a4	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  021aa	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  021b0	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  021b6	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  021bc	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  021c1	f7 da		 neg	 edx
  021c3	83 e0 7f	 and	 eax, 127		; 0000007fH
  021c6	3b c2		 cmp	 eax, edx
  021c8	7d 64		 jge	 SHORT $L118180
  021ca	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  021ce	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  021d4	fe c8		 dec	 al
  021d6	22 c1		 and	 al, cl
  021d8	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  021dc	eb 50		 jmp	 SHORT $L118180
$L118177:
  021de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  021e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  021ea	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  021f0	83 c2 04	 add	 edx, 4
  021f3	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  021f9	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  021ff	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02205	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0220b	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02211	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02215	83 e0 7f	 and	 eax, 127		; 0000007fH
  02218	3a c1		 cmp	 al, cl
  0221a	7d 12		 jge	 SHORT $L118180
  0221c	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  02220	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  02226	fe c1		 inc	 cl
  02228	22 c8		 and	 cl, al
  0222a	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L118180:
  0222e	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  02232	84 c0		 test	 al, al
  02234	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  02238	7d 56		 jge	 SHORT $L118181
  0223a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02240	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02246	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0224c	83 c2 04	 add	 edx, 4
  0224f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02255	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0225b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02261	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02267	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0226d	0f be 17	 movsx	 edx, BYTE PTR [edi]
  02270	f7 da		 neg	 edx
  02272	83 e0 7f	 and	 eax, 127		; 0000007fH
  02275	3b c2		 cmp	 eax, edx
  02277	0f 8d 0a 0e 00
	00		 jge	 $L108897
  0227d	8a 03		 mov	 al, BYTE PTR [ebx]
  0227f	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02285	fe c8		 dec	 al
  02287	22 c8		 and	 cl, al
  02289	88 0b		 mov	 BYTE PTR [ebx], cl
  0228b	e9 f7 0d 00 00	 jmp	 $L108897
$L118181:
  02290	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02296	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0229c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  022a2	83 c2 04	 add	 edx, 4
  022a5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  022ab	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  022b1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  022b7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  022bd	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1861 :                 // No gravity.
; 1862 :             }
; 1863 :             else  // Delete the spark.
; 1864 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1865 :             break;

  022c3	e9 e4 fc ff ff	 jmp	 $L118572
$L109086:

; 1866 : 
; 1867 : 
; 1868 :         //  Dynamic falling ones: GRAVITY. if out of range, delete.
; 1869 :         case ISPARK_Faller:
; 1870 :             if( (( ThisSpark->ByteC -= 1 ) > 0 )  )  // Timeout.

  022c8	fe 4c ef 06	 dec	 BYTE PTR [edi+ebp*8+6]
  022cc	0f 84 94 0d 00
	00		 je	 $L109139

; 1871 :             {
; 1872 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1873 :                 // Set spark.
; 1874 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  022d2	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  022d7	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  022da	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  022e0	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  022e4	d3 e2		 shl	 edx, cl
  022e6	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  022e9	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  022ed	03 d1		 add	 edx, ecx
  022ef	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  022f4	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1875 :                 // Advance position.
; 1876 :                 MoveSpark( ThisSpark );

  022f7	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  022fb	84 c0		 test	 al, al
  022fd	7d 55		 jge	 SHORT $L118221
  022ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02305	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0230b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02311	83 c2 04	 add	 edx, 4
  02314	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0231a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02320	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02326	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0232c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02332	0f be 4c ef 04	 movsx	 ecx, BYTE PTR [edi+ebp*8+4]
  02337	f7 d9		 neg	 ecx
  02339	83 e0 7f	 and	 eax, 127		; 0000007fH
  0233c	3b c1		 cmp	 eax, ecx
  0233e	7d 64		 jge	 SHORT $L118224
  02340	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  02344	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  0234a	fe ca		 dec	 dl
  0234c	22 d0		 and	 dl, al
  0234e	88 54 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], dl
  02352	eb 50		 jmp	 SHORT $L118224
$L118221:
  02354	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0235a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02360	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02366	83 c2 04	 add	 edx, 4
  02369	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0236f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02375	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0237b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02381	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02387	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  0238b	83 e0 7f	 and	 eax, 127		; 0000007fH
  0238e	3a c1		 cmp	 al, cl
  02390	7d 12		 jge	 SHORT $L118224
  02392	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  02396	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  0239c	fe c0		 inc	 al
  0239e	22 c1		 and	 al, cl
  023a0	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L118224:
  023a4	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  023a8	84 c0		 test	 al, al
  023aa	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  023ae	7d 47		 jge	 SHORT $L118225
  023b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  023b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  023bc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  023c2	83 c2 04	 add	 edx, 4
  023c5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  023cb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  023d1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  023d7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  023dd	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  023e3	8a 0f		 mov	 cl, BYTE PTR [edi]
  023e5	0f be d1	 movsx	 edx, cl
  023e8	f7 da		 neg	 edx
  023ea	83 e0 7f	 and	 eax, 127		; 0000007fH
  023ed	3b c2		 cmp	 eax, edx
  023ef	7d 50		 jge	 SHORT $L118228
  023f1	8a 03		 mov	 al, BYTE PTR [ebx]
  023f3	fe c8		 dec	 al
  023f5	eb 40		 jmp	 SHORT $L118568
$L118225:
  023f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  023fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02403	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02409	83 c2 04	 add	 edx, 4
  0240c	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02412	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02418	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0241e	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02424	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0242a	8a 0f		 mov	 cl, BYTE PTR [edi]
  0242c	83 e0 7f	 and	 eax, 127		; 0000007fH
  0242f	3a c1		 cmp	 al, cl
  02431	7d 0e		 jge	 SHORT $L118228
  02433	8a 03		 mov	 al, BYTE PTR [ebx]
  02435	fe c0		 inc	 al
$L118568:
  02437	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  0243d	22 d0		 and	 dl, al
  0243f	88 13		 mov	 BYTE PTR [ebx], dl
$L118228:

; 1877 :                 // Gravity:
; 1878 :                 if( (SBYTE)ThisSpark->ByteB < 122 )

  02441	80 f9 7a	 cmp	 cl, 122			; 0000007aH
  02444	0f 8d 3d 0c 00
	00		 jge	 $L108897

; 1879 :                     ThisSpark->ByteB +=3;

  0244a	80 c1 03	 add	 cl, 3
  0244d	88 0f		 mov	 BYTE PTR [edi], cl

; 1880 :             }
; 1881 :             else  // Delete the spark.
; 1882 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1883 :             break;

  0244f	e9 33 0c 00 00	 jmp	 $L108897
$L109093:

; 1884 : 
; 1885 : 		//  Dynamic falling ones for _Fountain.
; 1886 : 		case ISPARK_Graviton:
; 1887 : 			if    (( ThisSpark->Heat -= ThisSpark->ByteD ) > LOWESTGLOW )  // Glow out 

  02454	8a 54 ef 01	 mov	 dl, BYTE PTR [edi+ebp*8+1]
  02458	8a 4c ef 07	 mov	 cl, BYTE PTR [edi+ebp*8+7]
  0245c	2a d1		 sub	 dl, cl
  0245e	8a c2		 mov	 al, dl
  02460	3c 32		 cmp	 al, 50			; 00000032H
  02462	88 54 ef 01	 mov	 BYTE PTR [edi+ebp*8+1], dl
  02466	0f 86 fa 0b 00
	00		 jbe	 $L109139

; 1888 :             {
; 1889 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1890 : 
; 1891 :                 // Set spark.
; 1892 :                 Mips(0).DataArray(SparkDest ) = ThisSpark->Heat;

  0246c	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  02471	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02474	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  02478	d3 e2		 shl	 edx, cl
  0247a	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02480	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  02483	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  02488	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1893 : 
; 1894 :                 // Advance position.
; 1895 :                 MoveSpark( ThisSpark ); 

  0248b	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  0248f	84 c0		 test	 al, al
  02491	7d 55		 jge	 SHORT $L118265
  02493	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02499	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0249f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  024a5	83 c2 04	 add	 edx, 4
  024a8	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  024ae	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  024b4	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  024ba	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  024c0	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  024c6	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  024cb	f7 da		 neg	 edx
  024cd	83 e0 7f	 and	 eax, 127		; 0000007fH
  024d0	3b c2		 cmp	 eax, edx
  024d2	7d 64		 jge	 SHORT $L118268
  024d4	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  024d8	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  024de	fe c8		 dec	 al
  024e0	22 c1		 and	 al, cl
  024e2	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  024e6	eb 50		 jmp	 SHORT $L118268
$L118265:
  024e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  024ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  024f4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  024fa	83 c2 04	 add	 edx, 4
  024fd	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02503	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02509	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0250f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02515	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0251b	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  0251f	83 e0 7f	 and	 eax, 127		; 0000007fH
  02522	3a c1		 cmp	 al, cl
  02524	7d 12		 jge	 SHORT $L118268
  02526	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  0252a	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  02530	fe c1		 inc	 cl
  02532	22 c8		 and	 cl, al
  02534	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L118268:
  02538	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  0253c	84 c0		 test	 al, al
  0253e	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  02542	7d 47		 jge	 SHORT $L118269
  02544	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0254a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02550	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02556	83 c2 04	 add	 edx, 4
  02559	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0255f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02565	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0256b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02571	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02577	8a 0f		 mov	 cl, BYTE PTR [edi]
  02579	0f be d1	 movsx	 edx, cl
  0257c	f7 da		 neg	 edx
  0257e	83 e0 7f	 and	 eax, 127		; 0000007fH
  02581	3b c2		 cmp	 eax, edx
  02583	7d 50		 jge	 SHORT $L118272
  02585	8a 03		 mov	 al, BYTE PTR [ebx]
  02587	fe c8		 dec	 al
  02589	eb 40		 jmp	 SHORT $L118569
$L118269:
  0258b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02591	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02597	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0259d	83 c2 04	 add	 edx, 4
  025a0	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  025a6	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  025ac	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  025b2	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  025b8	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  025be	8a 0f		 mov	 cl, BYTE PTR [edi]
  025c0	83 e0 7f	 and	 eax, 127		; 0000007fH
  025c3	3a c1		 cmp	 al, cl
  025c5	7d 0e		 jge	 SHORT $L118272
  025c7	8a 03		 mov	 al, BYTE PTR [ebx]
  025c9	fe c0		 inc	 al
$L118569:
  025cb	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  025d1	22 d0		 and	 dl, al
  025d3	88 13		 mov	 BYTE PTR [ebx], dl
$L118272:

; 1896 : 
; 1897 :                 // 1/2 Gravity.
; 1898 : 				if( GlobalPhase & 1 )

  025d5	f6 86 d8 00 00
	00 01		 test	 BYTE PTR [esi+216], 1
  025dc	0f 84 a5 0a 00
	00		 je	 $L108897

; 1899 : 				{					
; 1900 : 					if( (SBYTE)ThisSpark->ByteB < 124 )

  025e2	80 f9 7c	 cmp	 cl, 124			; 0000007cH
  025e5	0f 8d 9c 0a 00
	00		 jge	 $L108897

; 1901 : 						ThisSpark->ByteB +=3;

  025eb	80 c1 03	 add	 cl, 3
  025ee	88 0f		 mov	 BYTE PTR [edi], cl

; 1902 : 				}
; 1903 :             }
; 1904 :             else  // Delete the spark.
; 1905 : 				*ThisSpark = Sparks(--ActiveSparkNum);
; 1906 :             break;

  025f0	e9 92 0a 00 00	 jmp	 $L108897
$L109101:

; 1907 : 
; 1908 : 
; 1909 :         //  Whirly-floaty fire sparks, go up & glow out.
; 1910 :         case ISPARK_VShooter:
; 1911 :             if   ((( ThisSpark->ByteC -= 3 ) > 190 )  )  // Timeout.

  025f5	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  025f9	80 c2 fd	 add	 dl, 253			; 000000fdH
  025fc	8a c2		 mov	 al, dl
  025fe	3c be		 cmp	 al, 190			; 000000beH
  02600	88 54 ef 06	 mov	 BYTE PTR [edi+ebp*8+6], dl
  02604	0f 86 77 08 00
	00		 jbe	 $L109130

; 1912 :             {
; 1913 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1914 :                 // Set spark.
; 1915 :                 Mips(0).DataArray(SparkDest) = (BYTE) (ThisSpark->ByteC);

  0260a	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  0260f	8d 4c ef 03	 lea	 ecx, DWORD PTR [edi+ebp*8+3]
  02613	89 4c 24 14	 mov	 DWORD PTR -36+[esp+56], ecx
  02617	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0261a	d3 e2		 shl	 edx, cl
  0261c	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02622	8d 5c ef 02	 lea	 ebx, DWORD PTR [edi+ebp*8+2]

; 1916 :                 // Advance position.
; 1917 :                 MoveSparkTwo( ThisSpark );

  02626	8d 7c ef 04	 lea	 edi, DWORD PTR [edi+ebp*8+4]
  0262a	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  0262d	0f b6 0b	 movzx	 ecx, BYTE PTR [ebx]
  02630	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  02633	80 3f 00	 cmp	 BYTE PTR [edi], 0
  02636	7d 69		 jge	 SHORT $L118301
  02638	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0263e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02644	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0264a	83 c2 04	 add	 edx, 4
  0264d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02653	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02659	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0265f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02665	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0266b	0f be 17	 movsx	 edx, BYTE PTR [edi]
  0266e	f7 da		 neg	 edx
  02670	83 e0 7f	 and	 eax, 127		; 0000007fH
  02673	3b c2		 cmp	 eax, edx
  02675	0f 8d 50 01 00
	00		 jge	 $L118332
  0267b	8a 03		 mov	 al, BYTE PTR [ebx]
  0267d	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02683	fe c8		 dec	 al
  02685	22 c1		 and	 al, cl
  02687	88 03		 mov	 BYTE PTR [ebx], al

; 1931 :                 // Advance position.
; 1932 :                 MoveSparkTwo( ThisSpark );

  02689	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  0268d	8a 10		 mov	 dl, BYTE PTR [eax]

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  0268f	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02695	80 ea 02	 sub	 dl, 2
  02698	22 ca		 and	 cl, dl
  0269a	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  0269c	e9 e6 09 00 00	 jmp	 $L108897

; 1916 :                 // Advance position.
; 1917 :                 MoveSparkTwo( ThisSpark );

$L118301:
  026a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  026a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  026ad	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  026b3	83 c2 04	 add	 edx, 4
  026b6	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  026bc	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  026c2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  026c8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  026ce	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1918 :             }
; 1919 :             else  // Delete the spark.

  026d4	e9 db 00 00 00	 jmp	 $L118575
$L109107:

; 1920 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1921 :             break;
; 1922 : 
; 1923 : 
; 1924 :         //  Whirly-floaty fire sparks, go up & glow out.
; 1925 :         case ISPARK_Drop:
; 1926 :             if( (( ThisSpark->ByteC += 4 ) < 250 )  )  // Timeout.

  026d9	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  026dd	80 c2 04	 add	 dl, 4
  026e0	8a c2		 mov	 al, dl
  026e2	3c fa		 cmp	 al, 250			; 000000faH
  026e4	88 54 ef 06	 mov	 BYTE PTR [edi+ebp*8+6], dl
  026e8	0f 83 93 07 00
	00		 jae	 $L109130

; 1927 :             {
; 1928 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1929 :                 // Set spark.
; 1930 :                 Mips(0).DataArray(SparkDest) = ThisSpark->ByteC;

  026ee	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  026f3	8d 4c ef 03	 lea	 ecx, DWORD PTR [edi+ebp*8+3]
  026f7	89 4c 24 14	 mov	 DWORD PTR -36+[esp+56], ecx
  026fb	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  026fe	d3 e2		 shl	 edx, cl
  02700	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02706	8d 5c ef 02	 lea	 ebx, DWORD PTR [edi+ebp*8+2]

; 1931 :                 // Advance position.
; 1932 :                 MoveSparkTwo( ThisSpark );

  0270a	8d 7c ef 04	 lea	 edi, DWORD PTR [edi+ebp*8+4]
  0270e	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  02711	0f b6 0b	 movzx	 ecx, BYTE PTR [ebx]
  02714	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  02717	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0271a	7d 65		 jge	 SHORT $L118329
  0271c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02722	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02728	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0272e	83 c2 04	 add	 edx, 4
  02731	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02737	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0273d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02743	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02749	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0274f	0f be 17	 movsx	 edx, BYTE PTR [edi]
  02752	f7 da		 neg	 edx
  02754	83 e0 7f	 and	 eax, 127		; 0000007fH
  02757	3b c2		 cmp	 eax, edx
  02759	7d 70		 jge	 SHORT $L118332
  0275b	8a 03		 mov	 al, BYTE PTR [ebx]
  0275d	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02763	fe c8		 dec	 al
  02765	22 c1		 and	 al, cl
  02767	88 03		 mov	 BYTE PTR [ebx], al
  02769	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  0276d	8a 10		 mov	 dl, BYTE PTR [eax]

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  0276f	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02775	80 ea 02	 sub	 dl, 2
  02778	22 ca		 and	 cl, dl
  0277a	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  0277c	e9 06 09 00 00	 jmp	 $L108897

; 1931 :                 // Advance position.
; 1932 :                 MoveSparkTwo( ThisSpark );

$L118329:
  02781	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02787	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0278d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02793	83 c2 04	 add	 edx, 4
  02796	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0279c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  027a2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  027a8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  027ae	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L118575:
  027b4	8a 0f		 mov	 cl, BYTE PTR [edi]
  027b6	83 e0 7f	 and	 eax, 127		; 0000007fH
  027b9	3a c1		 cmp	 al, cl
  027bb	7d 0e		 jge	 SHORT $L118332
  027bd	8a 0b		 mov	 cl, BYTE PTR [ebx]
  027bf	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  027c5	fe c1		 inc	 cl
  027c7	22 c8		 and	 cl, al
  027c9	88 0b		 mov	 BYTE PTR [ebx], cl
$L118332:
  027cb	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  027cf	8a 10		 mov	 dl, BYTE PTR [eax]

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  027d1	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  027d7	80 ea 02	 sub	 dl, 2
  027da	22 ca		 and	 cl, dl
  027dc	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  027de	e9 a4 08 00 00	 jmp	 $L108897
$L109112:

; 1933 :             }
; 1934 :             else // Delete the spark.
; 1935 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1936 :             break;
; 1937 : 
; 1938 : 
; 1939 :         //  Whirly-floaty fire sparks, go down & glow out.
; 1940 :         case ISPARK_Move:
; 1941 :             if   ((( ThisSpark->ByteC += 4 ) < 250 )  )  // Timeout

  027e3	8a 54 ef 06	 mov	 dl, BYTE PTR [edi+ebp*8+6]
  027e7	80 c2 04	 add	 dl, 4
  027ea	8a c2		 mov	 al, dl
  027ec	3c fa		 cmp	 al, 250			; 000000faH
  027ee	88 54 ef 06	 mov	 BYTE PTR [edi+ebp*8+6], dl
  027f2	0f 83 6e 08 00
	00		 jae	 $L109139

; 1942 :             {
; 1943 :                 DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ));
; 1944 :                 // Set spark.
; 1945 :                 Mips(0).DataArray(SparkDest) = ThisSpark->ByteC;

  027f8	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  027fd	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02800	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  02804	d3 e2		 shl	 edx, cl
  02806	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0280c	03 51 1c	 add	 edx, DWORD PTR [ecx+28]
  0280f	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  02814	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1946 :                 // Advance position.
; 1947 :                 MoveSpark( ThisSpark );

  02817	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  0281b	84 c0		 test	 al, al
  0281d	7d 55		 jge	 SHORT $L118365
  0281f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02825	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0282b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02831	83 c2 04	 add	 edx, 4
  02834	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0283a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02840	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02846	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0284c	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02852	0f be 54 ef 04	 movsx	 edx, BYTE PTR [edi+ebp*8+4]
  02857	f7 da		 neg	 edx
  02859	83 e0 7f	 and	 eax, 127		; 0000007fH
  0285c	3b c2		 cmp	 eax, edx
  0285e	7d 64		 jge	 SHORT $L118368
  02860	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  02864	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  0286a	fe c8		 dec	 al
  0286c	22 c1		 and	 al, cl
  0286e	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
  02872	eb 50		 jmp	 SHORT $L118368
$L118365:
  02874	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0287a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02880	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02886	83 c2 04	 add	 edx, 4
  02889	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0288f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02895	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0289b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  028a1	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  028a7	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  028ab	83 e0 7f	 and	 eax, 127		; 0000007fH
  028ae	3a c1		 cmp	 al, cl
  028b0	7d 12		 jge	 SHORT $L118368
  028b2	8a 4c ef 02	 mov	 cl, BYTE PTR [edi+ebp*8+2]
  028b6	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  028bc	fe c1		 inc	 cl
  028be	22 c8		 and	 cl, al
  028c0	88 4c ef 02	 mov	 BYTE PTR [edi+ebp*8+2], cl
$L118368:
  028c4	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  028c8	84 c0		 test	 al, al
  028ca	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  028ce	7d 56		 jge	 SHORT $L118369
  028d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  028d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  028dc	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  028e2	83 c2 04	 add	 edx, 4
  028e5	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  028eb	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  028f1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  028f7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  028fd	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02903	0f be 17	 movsx	 edx, BYTE PTR [edi]
  02906	f7 da		 neg	 edx
  02908	83 e0 7f	 and	 eax, 127		; 0000007fH
  0290b	3b c2		 cmp	 eax, edx
  0290d	0f 8d 74 07 00
	00		 jge	 $L108897
  02913	8a 03		 mov	 al, BYTE PTR [ebx]
  02915	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  0291b	fe c8		 dec	 al
  0291d	22 c8		 and	 cl, al
  0291f	88 0b		 mov	 BYTE PTR [ebx], cl
  02921	e9 61 07 00 00	 jmp	 $L108897
$L118369:
  02926	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0292c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02932	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02938	83 c2 04	 add	 edx, 4
  0293b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02941	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02947	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0294d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02953	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1948 :             }
; 1949 :             else  // Delete the spark.
; 1950 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1951 :             break;

  02959	e9 4e f6 ff ff	 jmp	 $L118572
$L109117:

; 1952 : 
; 1953 : 
; 1954 :         //  'Wormy' sparks, long-lived and sparse.
; 1955 :         case ISPARK_SpawnedEel:
; 1956 : 			if   ((( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout

  0295e	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02962	fe c9		 dec	 cl
  02964	8a c1		 mov	 al, cl
  02966	3c ff		 cmp	 al, 255			; 000000ffH
  02968	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  0296c	0f 83 f4 06 00
	00		 jae	 $L109139

; 1957 :             {
; 1958 : 	            DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ) );
; 1959 :                 // Set spark.
; 1960 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02972	0f b6 54 ef 03	 movzx	 edx, BYTE PTR [edi+ebp*8+3]
  02977	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0297a	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  02980	8d 5c ef 03	 lea	 ebx, DWORD PTR [edi+ebp*8+3]
  02984	d3 e2		 shl	 edx, cl
  02986	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  02989	8a 44 ef 01	 mov	 al, BYTE PTR [edi+ebp*8+1]
  0298d	03 d1		 add	 edx, ecx
  0298f	0f b6 4c ef 02	 movzx	 ecx, BYTE PTR [edi+ebp*8+2]
  02994	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 1961 :                 // (BYTE) (ThisSpark->ByteC);
; 1962 :                 // Advance position.
; 1963 :                 MoveSpark( ThisSpark );

  02997	8a 44 ef 04	 mov	 al, BYTE PTR [edi+ebp*8+4]
  0299b	84 c0		 test	 al, al
  0299d	7d 55		 jge	 SHORT $L118409
  0299f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  029a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  029ab	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  029b1	83 c2 04	 add	 edx, 4
  029b4	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  029ba	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  029c0	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  029c6	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  029cc	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  029d2	0f be 4c ef 04	 movsx	 ecx, BYTE PTR [edi+ebp*8+4]
  029d7	f7 d9		 neg	 ecx
  029d9	83 e0 7f	 and	 eax, 127		; 0000007fH
  029dc	3b c1		 cmp	 eax, ecx
  029de	7d 64		 jge	 SHORT $L118412
  029e0	8a 54 ef 02	 mov	 dl, BYTE PTR [edi+ebp*8+2]
  029e4	8a 86 c8 00 00
	00		 mov	 al, BYTE PTR [esi+200]
  029ea	fe ca		 dec	 dl
  029ec	22 d0		 and	 dl, al
  029ee	88 54 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], dl
  029f2	eb 50		 jmp	 SHORT $L118412
$L118409:
  029f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  029fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02a00	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02a06	83 c2 04	 add	 edx, 4
  02a09	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02a0f	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02a15	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02a1b	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02a21	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02a27	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02a2b	83 e0 7f	 and	 eax, 127		; 0000007fH
  02a2e	3a c1		 cmp	 al, cl
  02a30	7d 12		 jge	 SHORT $L118412
  02a32	8a 44 ef 02	 mov	 al, BYTE PTR [edi+ebp*8+2]
  02a36	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02a3c	fe c0		 inc	 al
  02a3e	22 c1		 and	 al, cl
  02a40	88 44 ef 02	 mov	 BYTE PTR [edi+ebp*8+2], al
$L118412:
  02a44	8a 44 ef 05	 mov	 al, BYTE PTR [edi+ebp*8+5]
  02a48	84 c0		 test	 al, al
  02a4a	8d 7c ef 05	 lea	 edi, DWORD PTR [edi+ebp*8+5]
  02a4e	7d 56		 jge	 SHORT $L118413
  02a50	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02a56	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02a5c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02a62	83 c2 04	 add	 edx, 4
  02a65	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02a6b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02a71	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02a77	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02a7d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02a83	0f be 0f	 movsx	 ecx, BYTE PTR [edi]
  02a86	f7 d9		 neg	 ecx
  02a88	83 e0 7f	 and	 eax, 127		; 0000007fH
  02a8b	3b c1		 cmp	 eax, ecx
  02a8d	0f 8d f4 05 00
	00		 jge	 $L108897
  02a93	8a 13		 mov	 dl, BYTE PTR [ebx]
  02a95	8a 86 cc 00 00
	00		 mov	 al, BYTE PTR [esi+204]
  02a9b	fe ca		 dec	 dl
  02a9d	22 c2		 and	 al, dl
  02a9f	88 03		 mov	 BYTE PTR [ebx], al
  02aa1	e9 e1 05 00 00	 jmp	 $L108897
$L118413:
  02aa6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02aac	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02ab2	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02ab8	83 c2 04	 add	 edx, 4
  02abb	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02ac1	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02ac7	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02acd	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02ad3	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02ad9	8a 0f		 mov	 cl, BYTE PTR [edi]
  02adb	83 e0 7f	 and	 eax, 127		; 0000007fH
  02ade	3a c1		 cmp	 al, cl
  02ae0	0f 8d a1 05 00
	00		 jge	 $L108897
  02ae6	8a 0b		 mov	 cl, BYTE PTR [ebx]
  02ae8	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  02aee	fe c1		 inc	 cl
  02af0	22 d1		 and	 dl, cl
  02af2	88 13		 mov	 BYTE PTR [ebx], dl

; 1964 :             }
; 1965 :             else  // Delete the spark.
; 1966 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1967 : 			break;

  02af4	e9 8e 05 00 00	 jmp	 $L108897
$L109122:

; 1968 : 
; 1969 : 
; 1970 : 		//  Cruising sparks, long-lived and sparse.
; 1971 :         case ISPARK_SpawnedSperm:
; 1972 : 			if( ( ( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout

  02af9	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02afd	fe c9		 dec	 cl
  02aff	8a c1		 mov	 al, cl
  02b01	3c ff		 cmp	 al, 255			; 000000ffH
  02b03	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  02b07	0f 83 59 05 00
	00		 jae	 $L109139

; 1973 :             {
; 1974 : 	            DWORD SparkDest = (DWORD)( ThisSpark->X + ( ThisSpark->Y << UBits ) );

  02b0d	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02b10	8d 44 ef 03	 lea	 eax, DWORD PTR [edi+ebp*8+3]
  02b14	89 44 24 14	 mov	 DWORD PTR -36+[esp+56], eax

; 1975 :                 // Set spark.
; 1976 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02b18	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  02b1b	d3 e0		 shl	 eax, cl
  02b1d	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02b23	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  02b26	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  02b2a	8d 54 ef 02	 lea	 edx, DWORD PTR [edi+ebp*8+2]
  02b2e	89 54 24 18	 mov	 DWORD PTR -32+[esp+56], edx
  02b32	0f b6 12	 movzx	 edx, BYTE PTR [edx]
  02b35	03 c3		 add	 eax, ebx
  02b37	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1977 : 
; 1978 : 				// Jiggle direction = ByteD using a zigzaggy ByteA.
; 1979 : 				BYTE SawTooth = 127 & (ThisSpark->ByteA += 7);

  02b3a	8a 54 ef 04	 mov	 dl, BYTE PTR [edi+ebp*8+4]
  02b3e	80 c2 07	 add	 dl, 7
  02b41	8a c2		 mov	 al, dl
  02b43	24 7f		 and	 al, 127			; 0000007fH
  02b45	8a c8		 mov	 cl, al

; 1980 : 				if( SawTooth>63 ) SawTooth = 127-SawTooth;

  02b47	80 f9 3f	 cmp	 cl, 63			; 0000003fH
  02b4a	88 54 ef 04	 mov	 BYTE PTR [edi+ebp*8+4], dl
  02b4e	76 06		 jbe	 SHORT $L109127
  02b50	b2 7f		 mov	 dl, 127			; 0000007fH
  02b52	2a d1		 sub	 dl, cl
  02b54	8a ca		 mov	 cl, dl
$L109127:

; 1981 : 
; 1982 :                 // Advance position, in direction of angle SawTooth+ByteD.
; 1983 : 				MoveSparkAngle(ThisSpark, 255& (SawTooth + ThisSpark->ByteD) );

  02b56	8a 44 ef 07	 mov	 al, BYTE PTR [edi+ebp*8+7]
  02b5a	02 c1		 add	 al, cl
  02b5c	33 c9		 xor	 ecx, ecx
  02b5e	8a c8		 mov	 cl, al
  02b60	04 40		 add	 al, 64			; 00000040H
  02b62	33 d2		 xor	 edx, edx
  02b64	8a d0		 mov	 dl, al
  02b66	8a 99 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[ecx]
  02b6c	80 eb 7f	 sub	 bl, 127			; 0000007fH
  02b6f	8a 82 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[edx]
  02b75	2c 7f		 sub	 al, 127			; 0000007fH
  02b77	84 db		 test	 bl, bl
  02b79	88 44 24 13	 mov	 BYTE PTR _Ydir$118454[esp+56], al
  02b7d	7d 53		 jge	 SHORT $L118455
  02b7f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02b85	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02b8b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02b91	83 c2 04	 add	 edx, 4
  02b94	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02b9a	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02ba0	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02ba6	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02bac	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02bb2	0f be cb	 movsx	 ecx, bl
  02bb5	f7 d9		 neg	 ecx
  02bb7	83 e0 7f	 and	 eax, 127		; 0000007fH
  02bba	3b c1		 cmp	 eax, ecx
  02bbc	7d 60		 jge	 SHORT $L118458
  02bbe	8b 44 24 18	 mov	 eax, DWORD PTR -32+[esp+56]
  02bc2	8a 10		 mov	 dl, BYTE PTR [eax]
  02bc4	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02bca	fe ca		 dec	 dl
  02bcc	22 d1		 and	 dl, cl
  02bce	88 10		 mov	 BYTE PTR [eax], dl
  02bd0	eb 4c		 jmp	 SHORT $L118458
$L118455:
  02bd2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02bd8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02bde	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02be4	83 c2 04	 add	 edx, 4
  02be7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02bed	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02bf3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02bf9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02bff	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02c05	83 e0 7f	 and	 eax, 127		; 0000007fH
  02c08	3a c3		 cmp	 al, bl
  02c0a	7d 12		 jge	 SHORT $L118458
  02c0c	8b 44 24 18	 mov	 eax, DWORD PTR -32+[esp+56]
  02c10	8a 08		 mov	 cl, BYTE PTR [eax]
  02c12	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  02c18	fe c1		 inc	 cl
  02c1a	22 ca		 and	 cl, dl
  02c1c	88 08		 mov	 BYTE PTR [eax], cl
$L118458:
  02c1e	8a 5c 24 13	 mov	 bl, BYTE PTR _Ydir$118454[esp+56]
  02c22	84 db		 test	 bl, bl
  02c24	7d 5a		 jge	 SHORT $L118459
  02c26	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02c2c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02c32	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02c38	83 c2 04	 add	 edx, 4
  02c3b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02c41	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02c47	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02c4d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02c53	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02c59	0f be d3	 movsx	 edx, bl
  02c5c	f7 da		 neg	 edx
  02c5e	83 e0 7f	 and	 eax, 127		; 0000007fH
  02c61	3b c2		 cmp	 eax, edx
  02c63	0f 8d 1e 04 00
	00		 jge	 $L108897
  02c69	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  02c6d	8a 08		 mov	 cl, BYTE PTR [eax]
  02c6f	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  02c75	fe c9		 dec	 cl
  02c77	22 d1		 and	 dl, cl
  02c79	88 10		 mov	 BYTE PTR [eax], dl
  02c7b	e9 07 04 00 00	 jmp	 $L108897
$L118459:
  02c80	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02c86	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02c8c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02c92	83 c2 04	 add	 edx, 4
  02c95	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02c9b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02ca1	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02ca7	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02cad	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 1984 :             }
; 1985 :             else  // Delete the spark.
; 1986 :                 *ThisSpark = Sparks(--ActiveSparkNum);
; 1987 : 			break;

  02cb3	e9 93 03 00 00	 jmp	 $L118571
$L109129:

; 1988 : 
; 1989 : 
; 1990 : 		//   Moves in semicircular motions.		
; 1991 : 		case ISPARK_SpawnedTwirl:
; 1992 :             if   ((( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout.

  02cb8	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02cbc	fe c9		 dec	 cl
  02cbe	8a c1		 mov	 al, cl
  02cc0	3c ff		 cmp	 al, 255			; 000000ffH
  02cc2	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  02cc6	0f 83 b5 01 00
	00		 jae	 $L109130

; 1993 :             {
; 1994 : 	            DWORD SparkDest = (DWORD)(ThisSpark->X + ( ThisSpark->Y << UBits ) );

  02ccc	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02ccf	8d 44 ef 03	 lea	 eax, DWORD PTR [edi+ebp*8+3]
  02cd3	89 44 24 14	 mov	 DWORD PTR -36+[esp+56], eax

; 1995 :                 // Set spark.
; 1996 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat;

  02cd7	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  02cda	d3 e0		 shl	 eax, cl
  02cdc	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02ce2	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  02ce5	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  02ce9	8d 54 ef 02	 lea	 edx, DWORD PTR [edi+ebp*8+2]
  02ced	89 54 24 18	 mov	 DWORD PTR -32+[esp+56], edx
  02cf1	0f b6 12	 movzx	 edx, BYTE PTR [edx]
  02cf4	03 c3		 add	 eax, ebx
  02cf6	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 1997 : 
; 1998 : 				//BYTE TempSpeedX   =  -128 +  (SBYTE)PhaseTable[(ThisSpark->ByteB+64 ) & 255];
; 1999 : 				//BYTE TempSpeedY   = (-128 + ((SBYTE)PhaseTable[ ThisSpark->ByteB ]) );
; 2000 : 
; 2001 : 				BYTE TempSpeedX = SignedPhaseTable[ (ThisSpark->ByteB+64 ) & 255 ];

  02cf9	0f b6 44 ef 05	 movzx	 eax, BYTE PTR [edi+ebp*8+5]

; 2002 : 				BYTE TempSpeedY = SignedPhaseTable[  ThisSpark->ByteB ];
; 2003 : 
; 2004 : 				*(_WORD*) &(ThisSpark->ByteA) +=  (_WORD) ThisSpark->ByteD << 4 ;   // Add angle delta (4:4) "fixed"-point)

  02cfe	66 0f b6 4c ef
	07		 movzx	 cx, BYTE PTR [edi+ebp*8+7]
  02d04	8d 50 40	 lea	 edx, DWORD PTR [eax+64]
  02d07	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _SignedPhaseTable[eax]
  02d0d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02d13	8a 9a 00 00 00
	00		 mov	 bl, BYTE PTR _SignedPhaseTable[edx]
  02d19	88 44 24 13	 mov	 BYTE PTR _TempSpeedY$109134[esp+56], al
  02d1d	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  02d21	c1 e1 04	 shl	 ecx, 4
  02d24	66 01 08	 add	 WORD PTR [eax], cx

; 2005 : 
; 2006 : 				// Advance position.
; 2007 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY ); 

  02d27	84 db		 test	 bl, bl
  02d29	7d 53		 jge	 SHORT $L118500
  02d2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02d31	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02d37	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02d3d	83 c2 04	 add	 edx, 4
  02d40	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02d46	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02d4c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02d52	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02d58	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02d5e	0f be d3	 movsx	 edx, bl
  02d61	f7 da		 neg	 edx
  02d63	83 e0 7f	 and	 eax, 127		; 0000007fH
  02d66	3b c2		 cmp	 eax, edx
  02d68	7d 60		 jge	 SHORT $L118503
  02d6a	8b 44 24 18	 mov	 eax, DWORD PTR -32+[esp+56]
  02d6e	8a 08		 mov	 cl, BYTE PTR [eax]
  02d70	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  02d76	fe c9		 dec	 cl
  02d78	22 ca		 and	 cl, dl
  02d7a	88 08		 mov	 BYTE PTR [eax], cl
  02d7c	eb 4c		 jmp	 SHORT $L118503
$L118500:
  02d7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02d84	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02d8a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02d90	83 c2 04	 add	 edx, 4
  02d93	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02d99	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02d9f	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02da5	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02dab	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02db1	83 e0 7f	 and	 eax, 127		; 0000007fH
  02db4	3a c3		 cmp	 al, bl
  02db6	7d 12		 jge	 SHORT $L118503
  02db8	8b 44 24 18	 mov	 eax, DWORD PTR -32+[esp+56]
  02dbc	8a 10		 mov	 dl, BYTE PTR [eax]
  02dbe	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02dc4	fe c2		 inc	 dl
  02dc6	22 d1		 and	 dl, cl
  02dc8	88 10		 mov	 BYTE PTR [eax], dl
$L118503:
  02dca	8a 5c 24 13	 mov	 bl, BYTE PTR _TempSpeedY$109134[esp+56]
  02dce	84 db		 test	 bl, bl
  02dd0	7d 5a		 jge	 SHORT $L118504
  02dd2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02dd8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02dde	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02de4	83 c2 04	 add	 edx, 4
  02de7	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02ded	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02df3	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02df9	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02dff	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02e05	0f be cb	 movsx	 ecx, bl
  02e08	f7 d9		 neg	 ecx
  02e0a	83 e0 7f	 and	 eax, 127		; 0000007fH
  02e0d	3b c1		 cmp	 eax, ecx
  02e0f	0f 8d 72 02 00
	00		 jge	 $L108897
  02e15	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  02e19	8a 10		 mov	 dl, BYTE PTR [eax]
  02e1b	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02e21	fe ca		 dec	 dl
  02e23	22 ca		 and	 cl, dl
  02e25	88 08		 mov	 BYTE PTR [eax], cl
  02e27	e9 5b 02 00 00	 jmp	 $L108897
$L118504:
  02e2c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02e32	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02e38	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02e3e	83 c2 04	 add	 edx, 4
  02e41	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02e47	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02e4d	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02e53	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02e59	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02e5f	83 e0 7f	 and	 eax, 127		; 0000007fH
  02e62	3a c3		 cmp	 al, bl
  02e64	0f 8d 1d 02 00
	00		 jge	 $L108897
  02e6a	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  02e6e	8a 10		 mov	 dl, BYTE PTR [eax]
  02e70	8a 8e cc 00 00
	00		 mov	 cl, BYTE PTR [esi+204]
  02e76	fe c2		 inc	 dl
  02e78	22 ca		 and	 cl, dl
  02e7a	88 08		 mov	 BYTE PTR [eax], cl

; 2008 :             }
; 2009 :             else // Delete the spark.

  02e7c	e9 06 02 00 00	 jmp	 $L108897
$L109130:

; 2010 :                 *ThisSpark = Sparks(--ActiveSparkNum);

  02e81	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  02e87	8b 96 fc 00 00
	00		 mov	 edx, DWORD PTR [esi+252]
  02e8d	48		 dec	 eax
  02e8e	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  02e94	8b 0c c2	 mov	 ecx, DWORD PTR [edx+eax*8]
  02e97	89 0c ef	 mov	 DWORD PTR [edi+ebp*8], ecx
  02e9a	8b 54 c2 04	 mov	 edx, DWORD PTR [edx+eax*8+4]
  02e9e	89 54 ef 04	 mov	 DWORD PTR [edi+ebp*8+4], edx

; 2011 : 			break;

  02ea2	e9 e0 01 00 00	 jmp	 $L108897
$L109138:

; 2012 : 
; 2013 : 
; 2014 : 		//   Moves in pseudoturbulent motions.		
; 2015 : 		case ISPARK_SprinklerTwirl:
; 2016 :             if   ((( ThisSpark->ByteC -= 1 ) < 255 )  )  // Timeout.

  02ea7	8a 4c ef 06	 mov	 cl, BYTE PTR [edi+ebp*8+6]
  02eab	fe c9		 dec	 cl
  02ead	8a c1		 mov	 al, cl
  02eaf	3c ff		 cmp	 al, 255			; 000000ffH
  02eb1	88 4c ef 06	 mov	 BYTE PTR [edi+ebp*8+6], cl
  02eb5	0f 83 ab 01 00
	00		 jae	 $L109139

; 2017 :             {
; 2018 : 	            DWORD SparkDest = (DWORD)(ThisSpark->X + ( ThisSpark->Y << UBits ));

  02ebb	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  02ebe	8d 44 ef 03	 lea	 eax, DWORD PTR [edi+ebp*8+3]
  02ec2	89 44 24 14	 mov	 DWORD PTR -36+[esp+56], eax

; 2019 :                 // Set spark.
; 2020 :                 Mips(0).DataArray(SparkDest) = ThisSpark->Heat; 

  02ec6	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  02ec9	d3 e0		 shl	 eax, cl
  02ecb	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  02ed1	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  02ed4	8a 4c ef 01	 mov	 cl, BYTE PTR [edi+ebp*8+1]
  02ed8	8d 54 ef 02	 lea	 edx, DWORD PTR [edi+ebp*8+2]
  02edc	89 54 24 18	 mov	 DWORD PTR -32+[esp+56], edx
  02ee0	0f b6 12	 movzx	 edx, BYTE PTR [edx]
  02ee3	03 c3		 add	 eax, ebx
  02ee5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 2021 : 				BYTE TempSpeedX   =  -128 + (SBYTE)PhaseTable[(ThisSpark->ByteA+64 ) & 255]; 

  02ee8	8a 4c ef 04	 mov	 cl, BYTE PTR [edi+ebp*8+4]
  02eec	33 d2		 xor	 edx, edx
  02eee	8d 44 ef 04	 lea	 eax, DWORD PTR [edi+ebp*8+4]
  02ef2	8a d1		 mov	 dl, cl
  02ef4	83 c2 40	 add	 edx, 64			; 00000040H
  02ef7	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  02efd	8a 9a 00 00 00
	00		 mov	 bl, BYTE PTR _PhaseTable[edx]

; 2022 : 				BYTE TempSpeedY   =  ThisSpark->ByteB; 

  02f03	8a 54 ef 05	 mov	 dl, BYTE PTR [edi+ebp*8+5]
  02f07	88 54 24 13	 mov	 BYTE PTR _TempSpeedY$109144[esp+56], dl

; 2023 : 				ThisSpark->ByteA +=  ThisSpark->ByteD; 

  02f0b	8a 54 ef 07	 mov	 dl, BYTE PTR [edi+ebp*8+7]
  02f0f	80 c3 80	 add	 bl, 128			; 00000080H
  02f12	02 d1		 add	 dl, cl

; 2024 : 				// Rotate angle.
; 2025 :                 // (BYTE) (ThisSpark->ByteC);
; 2026 :                 // Advance position.
; 2027 :                 MoveSparkXY( ThisSpark, TempSpeedX, TempSpeedY );

  02f14	84 db		 test	 bl, bl
  02f16	88 10		 mov	 BYTE PTR [eax], dl
  02f18	7d 53		 jge	 SHORT $L118544
  02f1a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02f20	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02f26	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02f2c	83 c2 04	 add	 edx, 4
  02f2f	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02f35	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02f3b	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02f41	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02f47	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02f4d	0f be cb	 movsx	 ecx, bl
  02f50	f7 d9		 neg	 ecx
  02f52	83 e0 7f	 and	 eax, 127		; 0000007fH
  02f55	3b c1		 cmp	 eax, ecx
  02f57	7d 60		 jge	 SHORT $L118547
  02f59	8b 44 24 18	 mov	 eax, DWORD PTR -32+[esp+56]
  02f5d	8a 10		 mov	 dl, BYTE PTR [eax]
  02f5f	8a 8e c8 00 00
	00		 mov	 cl, BYTE PTR [esi+200]
  02f65	fe ca		 dec	 dl
  02f67	22 d1		 and	 dl, cl
  02f69	88 10		 mov	 BYTE PTR [eax], dl
  02f6b	eb 4c		 jmp	 SHORT $L118547
$L118544:
  02f6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02f73	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02f79	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02f7f	83 c2 04	 add	 edx, 4
  02f82	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02f88	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02f8e	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02f94	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02f9a	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02fa0	83 e0 7f	 and	 eax, 127		; 0000007fH
  02fa3	3a c3		 cmp	 al, bl
  02fa5	7d 12		 jge	 SHORT $L118547
  02fa7	8b 44 24 18	 mov	 eax, DWORD PTR -32+[esp+56]
  02fab	8a 08		 mov	 cl, BYTE PTR [eax]
  02fad	8a 96 c8 00 00
	00		 mov	 dl, BYTE PTR [esi+200]
  02fb3	fe c1		 inc	 cl
  02fb5	22 ca		 and	 cl, dl
  02fb7	88 08		 mov	 BYTE PTR [eax], cl
$L118547:
  02fb9	8a 5c 24 13	 mov	 bl, BYTE PTR _TempSpeedY$109144[esp+56]
  02fbd	84 db		 test	 bl, bl
  02fbf	7d 57		 jge	 SHORT $L118548
  02fc1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  02fc7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  02fcd	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  02fd3	83 c2 04	 add	 edx, 4
  02fd6	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  02fdc	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  02fe2	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  02fe8	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  02fee	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  02ff4	0f be d3	 movsx	 edx, bl
  02ff7	f7 da		 neg	 edx
  02ff9	83 e0 7f	 and	 eax, 127		; 0000007fH
  02ffc	3b c2		 cmp	 eax, edx
  02ffe	0f 8d 83 00 00
	00		 jge	 $L108897
  03004	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  03008	8a 08		 mov	 cl, BYTE PTR [eax]
  0300a	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  03010	fe c9		 dec	 cl
  03012	22 d1		 and	 dl, cl
  03014	88 10		 mov	 BYTE PTR [eax], dl
  03016	eb 6f		 jmp	 SHORT $L108897
$L118548:
  03018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0301e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  03024	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0302a	83 c2 04	 add	 edx, 4
  0302d	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  03033	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  03039	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0303f	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  03045	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
$L118571:
  0304b	83 e0 7f	 and	 eax, 127		; 0000007fH
  0304e	3a c3		 cmp	 al, bl
  03050	7d 35		 jge	 SHORT $L108897
  03052	8b 44 24 14	 mov	 eax, DWORD PTR -36+[esp+56]
  03056	8a 08		 mov	 cl, BYTE PTR [eax]
  03058	8a 96 cc 00 00
	00		 mov	 dl, BYTE PTR [esi+204]
  0305e	fe c1		 inc	 cl
  03060	22 d1		 and	 dl, cl
  03062	88 10		 mov	 BYTE PTR [eax], dl

; 2028 :             }
; 2029 :             else // Delete the spark.

  03064	eb 21		 jmp	 SHORT $L108897
$L109139:

; 2030 :                 *ThisSpark = Sparks(--ActiveSparkNum);

  03066	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  0306c	8b 8e fc 00 00
	00		 mov	 ecx, DWORD PTR [esi+252]
  03072	48		 dec	 eax
  03073	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  03079	8b 14 c1	 mov	 edx, DWORD PTR [ecx+eax*8]
  0307c	89 14 ef	 mov	 DWORD PTR [edi+ebp*8], edx
  0307f	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  03083	89 44 ef 04	 mov	 DWORD PTR [edi+ebp*8+4], eax
$L108897:
  03087	8b 9e f8 00 00
	00		 mov	 ebx, DWORD PTR [esi+248]
  0308d	45		 inc	 ebp
  0308e	3b eb		 cmp	 ebp, ebx
  03090	0f 8c aa cf ff
	ff		 jl	 $L108896
  03096	5f		 pop	 edi
$L108898:
  03097	5e		 pop	 esi
  03098	5d		 pop	 ebp
  03099	5b		 pop	 ebx

; 2031 : 			break;
; 2032 : 
; 2033 :         } //Switch.
; 2034 : 	}
; 2035 : }

  0309a	83 c4 28	 add	 esp, 40			; 00000028H
  0309d	c3		 ret	 0
  0309e	8b ff		 npad	 2
$L118581:
  030a0	00 00 00 00	 DD	 $L108904
  030a4	00 00 00 00	 DD	 $L108907
  030a8	00 00 00 00	 DD	 $L108912
  030ac	00 00 00 00	 DD	 $L108916
  030b0	00 00 00 00	 DD	 $L108970
  030b4	00 00 00 00	 DD	 $L108973
  030b8	00 00 00 00	 DD	 $L108977
  030bc	00 00 00 00	 DD	 $L108980
  030c0	00 00 00 00	 DD	 $L108984
  030c4	00 00 00 00	 DD	 $L108922
  030c8	00 00 00 00	 DD	 $L108932
  030cc	00 00 00 00	 DD	 $L108951
  030d0	00 00 00 00	 DD	 $L108942
  030d4	00 00 00 00	 DD	 $L108988
  030d8	00 00 00 00	 DD	 $L108991
  030dc	00 00 00 00	 DD	 $L109023
  030e0	00 00 00 00	 DD	 $L109007
  030e4	00 00 00 00	 DD	 $L108994
  030e8	00 00 00 00	 DD	 $L108997
  030ec	00 00 00 00	 DD	 $L109002
  030f0	00 00 00 00	 DD	 $L109017
  030f4	00 00 00 00	 DD	 $L109020
  030f8	00 00 00 00	 DD	 $L109032
  030fc	00 00 00 00	 DD	 $L109035
  03100	00 00 00 00	 DD	 $L109042
  03104	00 00 00 00	 DD	 $L109050
  03108	00 00 00 00	 DD	 $L109026
  0310c	00 00 00 00	 DD	 $L109012
  03110	00 00 00 00	 DD	 $L109029
  03114	00 00 00 00	 DD	 $L108958
  03118	00 00 00 00	 DD	 $L108964
  0311c	00 00 00 00	 DD	 $L108897
  03120	00 00 00 00	 DD	 $L109071
  03124	00 00 00 00	 DD	 $L109076
  03128	00 00 00 00	 DD	 $L109086
  0312c	00 00 00 00	 DD	 $L109101
  03130	00 00 00 00	 DD	 $L109107
  03134	00 00 00 00	 DD	 $L109112
  03138	00 00 00 00	 DD	 $L109117
  0313c	00 00 00 00	 DD	 $L109129
  03140	00 00 00 00	 DD	 $L109138
  03144	00 00 00 00	 DD	 $L109081
  03148	00 00 00 00	 DD	 $L109093
  0314c	00 00 00 00	 DD	 $L109122
?RedrawSparks@UFireTexture@@AAEXXZ ENDP			; UFireTexture::RedrawSparks
_TEXT	ENDS
PUBLIC	?PostDrawSparks@UFireTexture@@AAEXXZ		; UFireTexture::PostDrawSparks
; Function compile flags: /Ogty
;	COMDAT ?PostDrawSparks@UFireTexture@@AAEXXZ
_TEXT	SEGMENT
?PostDrawSparks@UFireTexture@@AAEXXZ PROC NEAR		; UFireTexture::PostDrawSparks, COMDAT
; _this$ = ecx

; 2040 : {

  00000	8b d1		 mov	 edx, ecx

; 2041 :     DWORD SparkDest;
; 2042 : 
; 2043 : 	BYTE  FoundStar=0;
; 2044 : 
; 2045 : 	if( StarStatus == 0 ) return; // No stars so don't search the array.

  00002	8a 82 10 05 00
	00		 mov	 al, BYTE PTR [edx+1296]
  00008	53		 push	 ebx
  00009	32 db		 xor	 bl, bl
  0000b	84 c0		 test	 al, al
  0000d	57		 push	 edi
  0000e	74 70		 je	 SHORT $L109160

; 2046 : 		
; 2047 : 	for( INT S=0; S < ActiveSparkNum; S++ )

  00010	8b 82 f8 00 00
	00		 mov	 eax, DWORD PTR [edx+248]
  00016	33 ff		 xor	 edi, edi
  00018	85 c0		 test	 eax, eax
  0001a	7e 5d		 jle	 SHORT $L118614
  0001c	56		 push	 esi

; 2070 : }

  0001d	8d 49 00	 npad	 3
$L109153:

; 2046 : 		
; 2047 : 	for( INT S=0; S < ActiveSparkNum; S++ )

  00020	8b 82 fc 00 00
	00		 mov	 eax, DWORD PTR [edx+252]
  00026	8d 34 f8	 lea	 esi, DWORD PTR [eax+edi*8]

; 2048 : 	{
; 2049 :         if  (Sparks(S).Type == SPARK_Stars)

  00029	80 3e 16	 cmp	 BYTE PTR [esi], 22	; 00000016H
  0002c	75 3b		 jne	 SHORT $L109154

; 2050 : 		{
; 2051 : 			FoundStar = 1;
; 2052 : 			//  Fixed stars disappear depending to fire Intensity.
; 2053 : 			//  called here after the update: so restore the original star.
; 2054 : 			//  ByteA has the star itself, ByteB the saved bckgrnd
; 2055 : 
; 2056 : 			SparkDest = (DWORD)(Sparks(S).X
; 2057 : 			+ (Sparks(S).Y << UBits ) );

  0002e	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00032	8a 4a 30	 mov	 cl, BYTE PTR [edx+48]
  00035	d3 e0		 shl	 eax, cl
  00037	0f b6 4e 02	 movzx	 ecx, BYTE PTR [esi+2]
  0003b	03 c1		 add	 eax, ecx

; 2058 : 
; 2059 : 			//  Save real sky value.
; 2060 : 			BYTE DimStar = Mips(0).DataArray(SparkDest);

  0003d	8b 8a a8 00 00
	00		 mov	 ecx, DWORD PTR [edx+168]
  00043	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00046	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]

; 2061 : 			Sparks(S).ByteB = DimStar;
; 2062 : 
; 2063 : 			//  Put in the star if under cutoff.
; 2064 : 			if( DimStar < STAR_CUTOFF )

  00049	80 f9 26	 cmp	 cl, 38			; 00000026H
  0004c	b3 01		 mov	 bl, 1
  0004e	88 4e 05	 mov	 BYTE PTR [esi+5], cl
  00051	73 16		 jae	 SHORT $L109154

; 2065 : 				Mips(0).DataArray(SparkDest) = Sparks(S).ByteA;

  00053	8b 8a fc 00 00
	00		 mov	 ecx, DWORD PTR [edx+252]
  00059	8b b2 a8 00 00
	00		 mov	 esi, DWORD PTR [edx+168]
  0005f	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  00062	8a 4c f9 04	 mov	 cl, BYTE PTR [ecx+edi*8+4]
  00066	88 0c 30	 mov	 BYTE PTR [eax+esi], cl
$L109154:
  00069	8b 82 f8 00 00
	00		 mov	 eax, DWORD PTR [edx+248]
  0006f	47		 inc	 edi
  00070	3b f8		 cmp	 edi, eax
  00072	7c ac		 jl	 SHORT $L109153

; 2066 : 		}
; 2067 :     }
; 2068 : 
; 2069 : 	if( FoundStar == 0 ) StarStatus=0;

  00074	84 db		 test	 bl, bl
  00076	5e		 pop	 esi
  00077	75 07		 jne	 SHORT $L109160
$L118614:
  00079	c6 82 10 05 00
	00 00		 mov	 BYTE PTR [edx+1296], 0
$L109160:
  00080	5f		 pop	 edi
  00081	5b		 pop	 ebx

; 2070 : }

  00082	c3		 ret	 0
?PostDrawSparks@UFireTexture@@AAEXXZ ENDP		; UFireTexture::PostDrawSparks
_TEXT	ENDS
PUBLIC	?CalculateWater@UWaterTexture@@QAEXXZ		; UWaterTexture::CalculateWater
EXTRN	_CalcWaterASM:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CalculateWater@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT
?CalculateWater@UWaterTexture@@QAEXXZ PROC NEAR		; UWaterTexture::CalculateWater, COMDAT
; _this$ = ecx

; 2092 : 	WaveParity++;

  00000	8a 81 f8 12 00
	00		 mov	 al, BYTE PTR [ecx+4856]

; 2093 : 	try
; 2094 : 	{
; 2095 : 		CalcWaterASM
; 2096 : 		(
; 2097 : 			&Mips(0).DataArray(0),
; 2098 : 			SourceFields,
; 2099 : 			RenderTable,
; 2100 : 			WaveTable,
; 2101 : 			USize,
; 2102 : 			VSize,
; 2103 : 			WaveParity
; 2104 : 		);

  00006	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00009	fe c0		 inc	 al
  0000b	88 81 f8 12 00
	00		 mov	 BYTE PTR [ecx+4856], al
  00011	0f b6 c0	 movzx	 eax, al
  00014	50		 push	 eax
  00015	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	8d 91 f8 0c 00
	00		 lea	 edx, DWORD PTR [ecx+3320]
  00020	52		 push	 edx
  00021	8b 91 f0 08 00
	00		 mov	 edx, DWORD PTR [ecx+2288]
  00027	8d 81 f4 08 00
	00		 lea	 eax, DWORD PTR [ecx+2292]
  0002d	50		 push	 eax
  0002e	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  00034	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00037	52		 push	 edx
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _CalcWaterASM
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 2105 : 	}
; 2106 : 	catch( ... )
; 2107 : 	{}
; 2108 : }

  00041	c3		 ret	 0
?CalculateWater@UWaterTexture@@QAEXXZ ENDP		; UWaterTexture::CalculateWater
_TEXT	ENDS
PUBLIC	?ApplyWetTexture@UWetTexture@@AAEXXZ		; UWetTexture::ApplyWetTexture
; Function compile flags: /Ogty
;	COMDAT ?ApplyWetTexture@UWetTexture@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12
_BitMapAddr$ = -16
_SourceMapAddr$ = -8
_Xdimension$ = -20
_Ydimension$ = -36
_UMask$ = -24
_v$ = -4
_LineStart$109188 = -32
_SourceStart$109189 = -28
?ApplyWetTexture@UWetTexture@@AAEXXZ PROC NEAR		; UWetTexture::ApplyWetTexture, COMDAT
; _this$ = ecx

; 2555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 2556 :     // Apply texture: SourceTexture to
; 2557 :     // the current (output) texture,
; 2558 :     // using displacement effects.
; 2559 : 
; 2560 : 	// Any source texture selected yet ?
; 2561 :     if( SourceTexture == NULL ) return;

  00006	8b 91 00 13 00
	00		 mov	 edx, DWORD PTR [ecx+4864]
  0000c	85 d2		 test	 edx, edx
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00014	0f 84 da 00 00
	00		 je	 $L109187

; 2562 : 
; 2563 :     BYTE* BitMapAddr     = &Mips(0).DataArray(0);     // pointer

  0001a	8b 81 a8 00 00
	00		 mov	 eax, DWORD PTR [ecx+168]
  00020	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00023	89 45 f0	 mov	 DWORD PTR _BitMapAddr$[ebp], eax

; 2564 : 
; 2565 : 	BYTE* SourceMapAddr;
; 2566 : 
; 2567 : 	if( LocalSourceBitmap ) 

  00026	8b 81 08 13 00
	00		 mov	 eax, DWORD PTR [ecx+4872]
  0002c	85 c0		 test	 eax, eax

; 2568 : 		SourceMapAddr = LocalSourceBitmap;
; 2569 : 	else 

  0002e	75 09		 jne	 SHORT $L118648

; 2570 : 		SourceMapAddr = &SourceTexture->Mips(0).DataArray(0);

  00030	8b 92 a8 00 00
	00		 mov	 edx, DWORD PTR [edx+168]
  00036	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
$L118648:

; 2571 : 
; 2572 :     INT  Xdimension = USize;
; 2573 :     INT  Ydimension = VSize;

  00039	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0003c	89 45 f8	 mov	 DWORD PTR _SourceMapAddr$[ebp], eax
  0003f	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  00042	89 45 ec	 mov	 DWORD PTR _Xdimension$[ebp], eax

; 2574 : 
; 2575 : 	INT UMask = USize - 1;

  00045	48		 dec	 eax

; 2576 : 
; 2577 : #if WETASM
; 2578 : 
; 2579 :     for( INT v=0; v<Ydimension; v++ )

  00046	85 d2		 test	 edx, edx
  00048	89 55 dc	 mov	 DWORD PTR _Ydimension$[ebp], edx
  0004b	89 45 e8	 mov	 DWORD PTR _UMask$[ebp], eax
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0
  00055	0f 8e 99 00 00
	00		 jle	 $L109187
  0005b	eb 03		 jmp	 SHORT $L109185
$L118647:
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
$L109185:

; 2580 :     {
; 2581 : 		BYTE* LineStart =  BitMapAddr + (v << UBits);

  00060	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00063	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00066	d3 e0		 shl	 eax, cl
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _BitMapAddr$[ebp]
  0006b	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]

; 2582 : 		BYTE* SourceStart = SourceMapAddr + (v << UBits);

  0006e	8b 4d f8	 mov	 ecx, DWORD PTR _SourceMapAddr$[ebp]
  00071	03 c1		 add	 eax, ecx
  00073	89 55 e0	 mov	 DWORD PTR _LineStart$109188[ebp], edx
  00076	89 45 e4	 mov	 DWORD PTR _SourceStart$109189[ebp], eax

; 2585 :         {
; 2586 :             mov     esi,LineStart

  00079	8b 75 e0	 mov	 esi, DWORD PTR _LineStart$109188[ebp]

; 2587 :             mov     edi,SourceStart

  0007c	8b 7d e4	 mov	 edi, DWORD PTR _SourceStart$109189[ebp]

; 2588 : 
; 2589 :             xor     eax,eax

  0007f	33 c0		 xor	 eax, eax

; 2590 :             push    ebp

  00081	55		 push	 ebp

; 2591 : 
; 2592 :             mov     ecx,UMask

  00082	8b 4d e8	 mov	 ecx, DWORD PTR _UMask$[ebp]

; 2593 : 			mov     ebp,Xdimension

  00085	8b 6d ec	 mov	 ebp, DWORD PTR _Xdimension$[ebp]

; 2594 : 
; 2595 : 			xor     edx,edx

  00088	33 d2		 xor	 edx, edx

; 2596 :             xor     ebx,ebx

  0008a	33 db		 xor	 ebx, ebx

; 2597 : 
; 2598 : 			mov     dl,[esi+eax] // move up DL processing - skewed pipe

  0008c	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]

; 2599 : 			sub     ebp,2  // last 2 texels done separately.

  0008f	83 ed 02	 sub	 ebp, 2

; 2646 :         }
; 2647 :     }
; 2648 : 
; 2649 : #else
; 2650 : 
; 2651 :     for( INT v=0; v<Ydimension; v++ )
; 2652 :     {
; 2653 : 		BYTE* LineStart =  BitMapAddr + (v << UBits);
; 2654 : 		BYTE* SourceStart = SourceMapAddr + (v << UBits);
; 2655 : 
; 2656 : 		for( INT u=0; u<Xdimension; u += 2 )
; 2657 :         {
; 2658 : 
; 2659 : 		 // coolish effect combining half warped, half original.
; 2660 : 		 // LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 2661 : 		 INT  u2 = u+1;
; 2662 : 
; 2663 : 		 LineStart[ u] =  SourceStart[(  u + LineStart[ u]) & UMask ];
; 2664 : 		 LineStart[u2] =  SourceStart[( u2 + LineStart[u2]) & UMask ];
; 2665 : 
; 2666 :         }
; 2667 :     }
; 2668 : 
; 2669 : #endif
; 2670 : }

  00092	8d a4 24 00 00
	00 00 8d a4 24
	00 00 00 00	 npad	 14
$CopyLoop$109190:

; 2600 : 
; 2601 :             ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2602 :                                      ;;
; 2603 :             align 16                 ;;
; 2604 :             CopyLoop:                ;;
; 2605 :                                      ;;
; 2606 :             add     dl,al            ;; Linestart[u]+u

  000a0	02 d0		 add	 dl, al

; 2607 :             mov     bl,[esi+eax+1]   ;; Get linestart[u+1] (= water displ.ment)

  000a2	8a 5c 06 01	 mov	 bl, BYTE PTR [esi+eax+1]

; 2608 :                                      ;;
; 2609 :             and     dl,cl			 ;;

  000a6	22 d1		 and	 dl, cl

; 2610 : 			add     bl,al			 ;;

  000a8	02 d8		 add	 bl, al

; 2611 : 
; 2612 :             inc     bl               ;; Linestart[u+1] + u+1

  000aa	fe c3		 inc	 bl

; 2613 :             add     al,2			 ;;

  000ac	04 02		 add	 al, 2

; 2614 : 
; 2615 :             mov     dl,[edi+edx]     ;;

  000ae	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2616 :             and     bl,cl			 ;;

  000b1	22 d9		 and	 bl, cl

; 2617 : 
; 2618 :             cmp     eax,ebp          ;;

  000b3	3b c5		 cmp	 eax, ebp

; 2619 :             mov     [esi+eax-2],dl   ;;

  000b5	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 2620 : 
; 2621 :             mov     bl,[edi+ebx]     ;;

  000b9	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2622 :             mov     dl,[esi+eax]     ;; Get linestart[u] -  pixel 2

  000bc	8a 14 06	 mov	 dl, BYTE PTR [esi+eax]

; 2623 :                                      ;;
; 2624 :             mov     [esi+eax-2+1],bl ;;

  000bf	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 2625 :             jb      CopyLoop         ;;

  000c3	72 db		 jb	 SHORT $CopyLoop$109190

; 2626 :                                      ;;
; 2627 :             ;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2628 : 
; 2629 :             nop

  000c5	90		 npad	 1

; 2630 : 			mov     bl,[esi+eax+1]  ;; get pixel 2

  000c6	8a 5c 06 01	 mov	 bl, BYTE PTR [esi+eax+1]

; 2631 : 
; 2632 : 			add     dl,al

  000ca	02 d0		 add	 dl, al

; 2633 : 			add     bl,al

  000cc	02 d8		 add	 bl, al

; 2634 : 
; 2635 : 			inc     bl		// ebx	    	   ;;

  000ce	fe c3		 inc	 bl

; 2636 :             and     dl,cl	// edx,ecx         ;;

  000d0	22 d1		 and	 dl, cl

; 2637 : 
; 2638 :             pop     ebp     //

  000d2	5d		 pop	 ebp

; 2639 :             and     bl,cl	// ebx,ecx         ;;

  000d3	22 d9		 and	 bl, cl

; 2640 : 
; 2641 :             mov     dl,[edi+edx]    ;; Texel

  000d5	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2642 :             mov     bl,[edi+ebx]    ;; Texel

  000d8	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2643 : 
; 2644 :             mov     [esi+eax],dl    ;; Dest

  000db	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 2645 :             mov     [esi+eax+1],bl  ;; Dest

  000de	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 2583 : 
; 2584 :         __asm

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  000e5	8b 4d dc	 mov	 ecx, DWORD PTR _Ydimension$[ebp]
  000e8	40		 inc	 eax
  000e9	3b c1		 cmp	 eax, ecx
  000eb	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax
  000ee	0f 8c 69 ff ff
	ff		 jl	 $L118647
$L109187:

; 2646 :         }
; 2647 :     }
; 2648 : 
; 2649 : #else
; 2650 : 
; 2651 :     for( INT v=0; v<Ydimension; v++ )
; 2652 :     {
; 2653 : 		BYTE* LineStart =  BitMapAddr + (v << UBits);
; 2654 : 		BYTE* SourceStart = SourceMapAddr + (v << UBits);
; 2655 : 
; 2656 : 		for( INT u=0; u<Xdimension; u += 2 )
; 2657 :         {
; 2658 : 
; 2659 : 		 // coolish effect combining half warped, half original.
; 2660 : 		 // LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 2661 : 		 INT  u2 = u+1;
; 2662 : 
; 2663 : 		 LineStart[ u] =  SourceStart[(  u + LineStart[ u]) & UMask ];
; 2664 : 		 LineStart[u2] =  SourceStart[( u2 + LineStart[u2]) & UMask ];
; 2665 : 
; 2666 :         }
; 2667 :     }
; 2668 : 
; 2669 : #endif
; 2670 : }

  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?ApplyWetTexture@UWetTexture@@AAEXXZ ENDP		; UWetTexture::ApplyWetTexture
_TEXT	ENDS
PUBLIC	?MoveIcePosition@UIceTexture@@AAEXM@Z		; UIceTexture::MoveIcePosition
PUBLIC	__real@42f00000
PUBLIC	__real@3a9d4952
PUBLIC	__real@3a902de0
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@42f00000
; File ..\..\Core\Inc\UnVcWin32.h
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@3a9d4952
CONST	SEGMENT
__real@3a9d4952 DD 03a9d4952r			; 0.0012
CONST	ENDS
;	COMDAT __real@3a902de0
CONST	SEGMENT
__real@3a902de0 DD 03a902de0r			; 0.0011
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?MoveIcePosition@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT
_DeltaTime$ = 8
_I$118658 = -4
$T118660 = 8
_I$118669 = -4
$T118671 = 8
_I$118680 = -4
$T118682 = 8
_I$118691 = -4
$T118693 = 8
_I$118702 = -4
$T118704 = 8
_I$118713 = -4
$T118715 = 8
?MoveIcePosition@UIceTexture@@AAEXM@Z PROC NEAR		; UIceTexture::MoveIcePosition, COMDAT
; _this$ = ecx

; 2679 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2680 : 	MasterCount += DeltaTime*120.0f;  //Virtual time ticks.

  00003	d9 44 24 10	 fld	 DWORD PTR _DeltaTime$[esp+8]

; 2681 : 
; 2682 : 	UDisplace += 2.0f * DeltaTime * -((SBYTE)(HorizPanSpeed - 128));

  00007	8a 91 ea 00 00
	00		 mov	 dl, BYTE PTR [ecx+234]
  0000d	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@42f00000
  00013	80 c2 80	 add	 dl, -128		; ffffff80H
  00016	d8 81 f4 00 00
	00		 fadd	 DWORD PTR [ecx+244]
  0001c	d9 5c 24 00	 fstp	 DWORD PTR -12+[esp+12]
  00020	8b 44 24 00	 mov	 eax, DWORD PTR -12+[esp+12]
  00024	89 81 f4 00 00
	00		 mov	 DWORD PTR [ecx+244], eax
  0002a	0f be c2	 movsx	 eax, dl
  0002d	89 44 24 04	 mov	 DWORD PTR -8+[esp+12], eax

; 2683 : 	VDisplace += 2.0f * DeltaTime *  ((SBYTE)(VertPanSpeed  - 128));

  00031	8a 81 eb 00 00
	00		 mov	 al, BYTE PTR [ecx+235]
  00037	04 80		 add	 al, -128		; ffffff80H
  00039	db 44 24 04	 fild	 DWORD PTR -8+[esp+12]
  0003d	d8 4c 24 10	 fmul	 DWORD PTR _DeltaTime$[esp+8]
  00041	dc c0		 fadd	 ST(0), ST(0)
  00043	d8 a9 f8 00 00
	00		 fsubr	 DWORD PTR [ecx+248]
  00049	d9 5c 24 04	 fstp	 DWORD PTR -8+[esp+12]
  0004d	8b 54 24 04	 mov	 edx, DWORD PTR -8+[esp+12]
  00051	89 91 f8 00 00
	00		 mov	 DWORD PTR [ecx+248], edx
  00057	0f be d0	 movsx	 edx, al
  0005a	89 54 24 08	 mov	 DWORD PTR -4+[esp+12], edx
  0005e	db 44 24 08	 fild	 DWORD PTR -4+[esp+12]
  00062	d8 4c 24 10	 fmul	 DWORD PTR _DeltaTime$[esp+8]
  00066	dc c0		 fadd	 ST(0), ST(0)
  00068	d8 81 fc 00 00
	00		 fadd	 DWORD PTR [ecx+252]
  0006e	d9 5c 24 10	 fstp	 DWORD PTR 8+[esp+8]
  00072	8b 44 24 10	 mov	 eax, DWORD PTR 8+[esp+8]
  00076	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax

; 2684 : 
; 2685 : 	switch (PanningStyle)
; 2686 : 	{

  0007c	0f b6 81 e8 00
	00 00		 movzx	 eax, BYTE PTR [ecx+232]
  00083	83 f8 04	 cmp	 eax, 4
  00086	0f 87 e7 01 00
	00		 ja	 $L109198
  0008c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L118728[eax*4]
$L109201:

; 2687 : 		case SLIDE_Linear:
; 2688 : 			UPosition  = UDisplace;

  00093	8b 54 24 04	 mov	 edx, DWORD PTR -8+[esp+12]

; 2689 : 			VPosition  = VDisplace;

  00097	8b 44 24 10	 mov	 eax, DWORD PTR 8+[esp+8]
  0009b	89 91 00 01 00
	00		 mov	 DWORD PTR [ecx+256], edx
  000a1	89 81 04 01 00
	00		 mov	 DWORD PTR [ecx+260], eax

; 2710 : 		break;
; 2711 : 	}	
; 2712 : }

  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000aa	c2 04 00	 ret	 4
$L109202:

; 2690 : 		break;
; 2691 : 
; 2692 : 		case SLIDE_Circular: 
; 2693 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  000ad	0f b6 91 ec 00
	00 00		 movzx	 edx, BYTE PTR [ecx+236]
  000b4	42		 inc	 edx
  000b5	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  000b9	0f b6 81 ed 00
	00 00		 movzx	 eax, BYTE PTR [ecx+237]
  000c0	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  000c4	40		 inc	 eax

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  000c5	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  000c9	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  000cd	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  000d3	d9 fe		 fsin
  000d5	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  000d9	d9 5c 24 10	 fstp	 DWORD PTR $T118660[esp+8]

; 2690 : 		break;
; 2691 : 
; 2692 : 		case SLIDE_Circular: 
; 2693 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  000dd	d9 44 24 10	 fld	 DWORD PTR $T118660[esp+8]
  000e1	db 5c 24 08	 fistp	 DWORD PTR _I$118658[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  000e5	db 44 24 08	 fild	 DWORD PTR _I$118658[esp+12]
  000e9	0f b6 91 ec 00
	00 00		 movzx	 edx, BYTE PTR [ecx+236]
  000f0	42		 inc	 edx
  000f1	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  000f5	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  000fb	0f b6 81 ed 00
	00 00		 movzx	 eax, BYTE PTR [ecx+237]
  00102	d9 99 00 01 00
	00		 fstp	 DWORD PTR [ecx+256]
  00108	40		 inc	 eax
  00109	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  0010d	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  00111	d8 89 f4 00 00
	00		 fmul	 DWORD PTR [ecx+244]
  00117	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  0011d	d9 ff		 fcos
  0011f	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  00123	d9 5c 24 10	 fstp	 DWORD PTR $T118671[esp+8]

; 2694 : 			VPosition =  VDisplace + appRound( (FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  00127	d9 44 24 10	 fld	 DWORD PTR $T118671[esp+8]
  0012b	db 5c 24 08	 fistp	 DWORD PTR _I$118669[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  0012f	e9 2f 01 00 00	 jmp	 $L118727
$L109205:

; 2695 : 		break;
; 2696 : 
; 2697 : 		case SLIDE_Gestation: // just some out-of-phase movement.
; 2698 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  00134	0f b6 91 ec 00
	00 00		 movzx	 edx, BYTE PTR [ecx+236]
  0013b	42		 inc	 edx
  0013c	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  00140	0f b6 81 ed 00
	00 00		 movzx	 eax, BYTE PTR [ecx+237]
  00147	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  0014b	40		 inc	 eax

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  0014c	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  00150	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  00154	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  0015a	d9 fe		 fsin
  0015c	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  00160	d9 5c 24 10	 fstp	 DWORD PTR $T118682[esp+8]

; 2695 : 		break;
; 2696 : 
; 2697 : 		case SLIDE_Gestation: // just some out-of-phase movement.
; 2698 : 			UPosition =  UDisplace + appRound( (FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  00164	d9 44 24 10	 fld	 DWORD PTR $T118682[esp+8]
  00168	db 5c 24 08	 fistp	 DWORD PTR _I$118680[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  0016c	db 44 24 08	 fild	 DWORD PTR _I$118680[esp+12]
  00170	0f b6 91 ec 00
	00 00		 movzx	 edx, BYTE PTR [ecx+236]
  00177	42		 inc	 edx
  00178	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  0017c	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  00182	0f b6 81 ed 00
	00 00		 movzx	 eax, BYTE PTR [ecx+237]
  00189	d9 99 00 01 00
	00		 fstp	 DWORD PTR [ecx+256]
  0018f	40		 inc	 eax
  00190	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  00194	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  00198	d8 89 f4 00 00
	00		 fmul	 DWORD PTR [ecx+244]
  0019e	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a902de0
  001a4	d9 ff		 fcos
  001a6	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  001aa	d9 5c 24 10	 fstp	 DWORD PTR $T118693[esp+8]

; 2699 : 			VPosition =  VDisplace + appRound( (FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0011f));

  001ae	d9 44 24 10	 fld	 DWORD PTR $T118693[esp+8]
  001b2	db 5c 24 08	 fistp	 DWORD PTR _I$118691[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  001b6	e9 a8 00 00 00	 jmp	 $L118727
$L109208:

; 2700 : 		break;
; 2701 : 
; 2702 : 		case SLIDE_WavyX:  // X movement, with Y sinewave
; 2703 : 			UPosition =  UDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  001bb	0f b6 91 ec 00
	00 00		 movzx	 edx, BYTE PTR [ecx+236]
  001c2	42		 inc	 edx
  001c3	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  001c7	0f b6 81 ed 00
	00 00		 movzx	 eax, BYTE PTR [ecx+237]
  001ce	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  001d2	40		 inc	 eax

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  001d3	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  001d7	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  001db	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  001e1	d9 fe		 fsin
  001e3	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  001e7	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  001ed	d9 5c 24 10	 fstp	 DWORD PTR $T118704[esp+8]

; 2700 : 		break;
; 2701 : 
; 2702 : 		case SLIDE_WavyX:  // X movement, with Y sinewave
; 2703 : 			UPosition =  UDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appSin( MasterCount * (Frequency+1) * 0.0012f));

  001f1	d9 44 24 10	 fld	 DWORD PTR $T118704[esp+8]
  001f5	db 5c 24 08	 fistp	 DWORD PTR _I$118702[esp+12]

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  001f9	db 44 24 08	 fild	 DWORD PTR _I$118702[esp+12]
  001fd	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00203	89 91 04 01 00
	00		 mov	 DWORD PTR [ecx+260], edx
  00209	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  0020f	d9 99 00 01 00
	00		 fstp	 DWORD PTR [ecx+256]

; 2710 : 		break;
; 2711 : 	}	
; 2712 : }

  00215	83 c4 0c	 add	 esp, 12			; 0000000cH
  00218	c2 04 00	 ret	 4
$L109210:

; 2704 : 			VPosition =  VDisplace;
; 2705 : 		break;
; 2706 : 
; 2707 : 		case SLIDE_WavyY: // Y movement, with X sinewave 			
; 2708 : 			UPosition =  UDisplace;
; 2709 : 			VPosition =  VDisplace + appRound( 0.5*(FLOAT)(Amplitude+1) * appCos( MasterCount * (Frequency+1) * 0.0012f));

  0021b	0f b6 91 ec 00
	00 00		 movzx	 edx, BYTE PTR [ecx+236]
  00222	42		 inc	 edx
  00223	89 54 24 10	 mov	 DWORD PTR 8+[esp+8], edx
  00227	8b 44 24 04	 mov	 eax, DWORD PTR -8+[esp+12]
  0022b	db 44 24 10	 fild	 DWORD PTR 8+[esp+8]
  0022f	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax
  00235	0f b6 81 ed 00
	00 00		 movzx	 eax, BYTE PTR [ecx+237]
  0023c	d8 4c 24 00	 fmul	 DWORD PTR -12+[esp+12]
  00240	40		 inc	 eax
  00241	89 44 24 10	 mov	 DWORD PTR 8+[esp+8], eax
  00245	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3a9d4952
  0024b	d9 ff		 fcos
  0024d	da 4c 24 10	 fimul	 DWORD PTR 8+[esp+8]
  00251	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00257	d9 5c 24 10	 fstp	 DWORD PTR $T118715[esp+8]
  0025b	d9 44 24 10	 fld	 DWORD PTR $T118715[esp+8]
  0025f	db 5c 24 08	 fistp	 DWORD PTR _I$118713[esp+12]
$L118727:
  00263	db 44 24 08	 fild	 DWORD PTR _I$118713[esp+12]
  00267	d8 81 fc 00 00
	00		 fadd	 DWORD PTR [ecx+252]
  0026d	d9 99 04 01 00
	00		 fstp	 DWORD PTR [ecx+260]
$L109198:

; 2710 : 		break;
; 2711 : 	}	
; 2712 : }

  00273	83 c4 0c	 add	 esp, 12			; 0000000cH
  00276	c2 04 00	 ret	 4
  00279	8d 49 00	 npad	 3
$L118728:
  0027c	00 00 00 00	 DD	 $L109201
  00280	00 00 00 00	 DD	 $L109202
  00284	00 00 00 00	 DD	 $L109205
  00288	00 00 00 00	 DD	 $L109208
  0028c	00 00 00 00	 DD	 $L109210
?MoveIcePosition@UIceTexture@@AAEXM@Z ENDP		; UIceTexture::MoveIcePosition
_TEXT	ENDS
PUBLIC	?BlitTexIce@UIceTexture@@AAEXXZ			; UIceTexture::BlitTexIce
EXTRN	__imp__GIsPentiumPro:DWORD
_BSS	SEGMENT
?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; `UIceTexture::BlitTexIce'::`4'::ESPStorage
?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; `UIceTexture::BlitTexIce'::`4'::EBPStorage
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?BlitTexIce@UIceTexture@@AAEXXZ
_TEXT	SEGMENT
_this$ = -32
_TexAddr$ = -44
_GlassAddr$ = -48
_BitMapAddr$ = -40
_Xdimension$ = -16
_Ydimension$ = -52
_TempUMask$ = -20
_UDisp$ = -12
_VDisp$ = -36
_v$ = -4
_LineStart$109232 = -28
_TexStart$109233 = -24
_GlassStart$109234 = -8
_I$118758 = -24
$T118760 = -28
_I$118764 = -24
$T118766 = -28
?BlitTexIce@UIceTexture@@AAEXXZ PROC NEAR		; UIceTexture::BlitTexIce, COMDAT
; _this$ = ecx

; 2720 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	8b c1		 mov	 eax, ecx

; 2721 :     // Warning: Source/GlassTexture must have same dimensions.
; 2722 : 
; 2723 :     BYTE* TexAddr		= &SourceTexture->Mips(0).DataArray(0);
; 2724 : 	BYTE* GlassAddr		= &GlassTexture->Mips(0).DataArray(0);

  00008	8b 88 e0 00 00
	00		 mov	 ecx, DWORD PTR [eax+224]
  0000e	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00014	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 2725 :     BYTE* BitMapAddr	= &Mips(0).DataArray(0);  // Pointer.

  00017	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  0001d	89 4d d0	 mov	 DWORD PTR _GlassAddr$[ebp], ecx
  00020	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00023	53		 push	 ebx
  00024	89 4d d8	 mov	 DWORD PTR _BitMapAddr$[ebp], ecx

; 2726 : 
; 2727 : 	if( LocalSourceBitmap ) return; // Static local source, no update needed.

  00027	8b 88 1c 01 00
	00		 mov	 ecx, DWORD PTR [eax+284]
  0002d	85 c9		 test	 ecx, ecx
  0002f	56		 push	 esi
  00030	57		 push	 edi
  00031	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
  00034	0f 85 36 03 00
	00		 jne	 $L109231

; 2728 : 
; 2729 : 	TexAddr = &SourceTexture->Mips(0).DataArray(0);

  0003a	8b 90 e4 00 00
	00		 mov	 edx, DWORD PTR [eax+228]
  00040	8b 8a a8 00 00
	00		 mov	 ecx, DWORD PTR [edx+168]
  00046	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 2730 : 
; 2731 :     INT  Xdimension   = USize;  // Wrap needed for 8-bit counters.

  00049	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0004c	89 55 d4	 mov	 DWORD PTR _TexAddr$[ebp], edx

; 2732 :     INT  Ydimension   = VSize;  // 
; 2733 : 
; 2734 : #if ICEASM
; 2735 : 	INT  TempUMask    = UMask;  //

  0004f	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00055	89 4d f0	 mov	 DWORD PTR _Xdimension$[ebp], ecx
  00058	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005b	89 55 ec	 mov	 DWORD PTR _TempUMask$[ebp], edx

; 2736 : #endif
; 2737 : 
; 2738 : 	static	DWORD ESPStorage;   // Temp ESP  storage.
; 2739 : 	static	DWORD EBPStorage;   // Temp EBP  storage.
; 2740 : 
; 2741 : 	// Positionments are (signed) fixed-point 3:4
; 2742 : 	INT  UDisp =  appRound(UPosition) & UMask;

  0005e	8b 90 00 01 00
	00		 mov	 edx, DWORD PTR [eax+256]
  00064	89 4d cc	 mov	 DWORD PTR _Ydimension$[ebp], ecx
  00067	89 55 e4	 mov	 DWORD PTR $T118760[ebp], edx
  0006a	d9 45 e4	 fld	 DWORD PTR $T118760[ebp]
  0006d	db 5d e8	 fistp	 DWORD PTR _I$118758[ebp]
  00070	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00076	23 55 e8	 and	 edx, DWORD PTR _I$118758[ebp]
  00079	89 55 f4	 mov	 DWORD PTR _UDisp$[ebp], edx

; 2743 : 	INT  VDisp =  appRound(VPosition) & VMask;

  0007c	8b 90 04 01 00
	00		 mov	 edx, DWORD PTR [eax+260]
  00082	89 55 e4	 mov	 DWORD PTR $T118766[ebp], edx
  00085	d9 45 e4	 fld	 DWORD PTR $T118766[ebp]
  00088	db 5d e8	 fistp	 DWORD PTR _I$118764[ebp]
  0008b	8b b0 cc 00 00
	00		 mov	 esi, DWORD PTR [eax+204]
  00091	8b 7d e8	 mov	 edi, DWORD PTR _I$118764[ebp]
  00094	23 fe		 and	 edi, esi

; 2744 : 
; 2745 :     for( INT v=0; v<Ydimension; v++ )

  00096	33 f6		 xor	 esi, esi
  00098	85 c9		 test	 ecx, ecx
  0009a	89 7d dc	 mov	 DWORD PTR _VDisp$[ebp], edi
  0009d	89 75 fc	 mov	 DWORD PTR _v$[ebp], esi
  000a0	0f 8e ca 02 00
	00		 jle	 $L109231
  000a6	eb 09		 jmp	 SHORT $L109229
$L118770:
  000a8	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 7d dc	 mov	 edi, DWORD PTR _VDisp$[ebp]
  000ae	8b 75 fc	 mov	 esi, DWORD PTR _v$[ebp]
$L109229:

; 2746 :     {
; 2747 : 		BYTE* LineStart   = BitMapAddr +    (v << UBits);

  000b1	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  000b5	8b 5d d8	 mov	 ebx, DWORD PTR _BitMapAddr$[ebp]
  000b8	8b d6		 mov	 edx, esi
  000ba	d3 e2		 shl	 edx, cl

; 2748 : 		BYTE* TexStart    = TexAddr    +    (v << UBits);
; 2749 : 		BYTE* GlassStart  = GlassAddr  +  (((v + VDisp ) & VMask) << UBits);

  000bc	03 f7		 add	 esi, edi
  000be	03 da		 add	 ebx, edx
  000c0	89 5d e4	 mov	 DWORD PTR _LineStart$109232[ebp], ebx
  000c3	8b 5d d4	 mov	 ebx, DWORD PTR _TexAddr$[ebp]
  000c6	03 d3		 add	 edx, ebx
  000c8	8b 98 cc 00 00
	00		 mov	 ebx, DWORD PTR [eax+204]

; 2750 : 
; 2751 : #if ICEASM
; 2752 : 
; 2753 : 		if( GIsPentiumPro )

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GIsPentiumPro
  000d3	23 f3		 and	 esi, ebx
  000d5	d3 e6		 shl	 esi, cl
  000d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d9	89 55 e8	 mov	 DWORD PTR _TexStart$109233[ebp], edx
  000dc	03 75 d0	 add	 esi, DWORD PTR _GlassAddr$[ebp]
  000df	85 c9		 test	 ecx, ecx
  000e1	89 75 f8	 mov	 DWORD PTR _GlassStart$109234[ebp], esi
  000e4	0f 84 39 01 00
	00		 je	 $L109235

; 2754 : 		{  		
; 2755 : 		// Pentium PRO/II version 
; 2756 : 			__asm                        //
; 2757 : 			{                            //
; 2758 : 				mov     esi, LineStart   //

  000ea	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$109232[ebp]

; 2759 : 				mov     edi, TexStart    //

  000ed	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$109233[ebp]

; 2760 : 
; 2761 : 				mov     ecx, [TempUMask] //

  000f0	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 2762 : 				mov     ebx, Xdimension  //

  000f3	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2763 : 				xor     eax, eax         //

  000f6	33 c0		 xor	 eax, eax

; 2764 : 
; 2765 : 				mov     ebx, Xdimension  //

  000f8	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2766 : 				sub     ebx, UDisp       //

  000fb	2b 5d f4	 sub	 ebx, DWORD PTR _UDisp$[ebp]

; 2767 : 
; 2768 : 				test    ebx, ecx 	     //  zero? - no split 

  000fe	85 d9		 test	 ebx, ecx

; 2769 : 				jz      ppNoSplit          //

  00100	74 0f		 je	 SHORT $ppNoSplit$109236

; 2770 : 
; 2771 : 				cmp     ebx, 7           //  

  00102	83 fb 07	 cmp	 ebx, 7

; 2772 : 				ja      ppSkipFirstBit     //  Skip if not in first 8 pixels.

  00105	77 12		 ja	 SHORT $ppSkipFirstBit$109237

; 2773 : 
; 2774 : 				;; split is in first 8 pixels and Unaligned.
; 2775 : 
; 2776 : 				mov     edx, GlassStart  //

  00107	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2777 : 				call    ppIceMisc8Pixelz   //

  0010a	e8 d1 00 00 00	 call	 $ppIceMisc8Pixelz$109238

; 2778 : 				jmp     ppDoEndChunk       //

  0010f	eb 29		 jmp	 SHORT $ppDoEndChunk$109239
$ppNoSplit$109236:

; 2779 : 
; 2780 : 			ppNoSplit:                     //
; 2781 : 				mov     ebx, Xdimension  //

  00111	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2782 : 				mov     edx, GlassStart  //

  00114	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2783 : 				jmp     ppDoLastChunk      //

  00117	eb 35		 jmp	 SHORT $ppDoLastChunk$109240
$ppSkipFirstBit$109237:

; 2784 : 
; 2785 : 				///////////////////////////
; 2786 : 
; 2787 : 			ppSkipFirstBit:
; 2788 : 
; 2789 : 				and		ebx, 0x0FF-7;     // FF - 3     = stretch before wrapping needed

  00119	81 e3 f8 00 00
	00		 and	 ebx, 248		; 000000f8H

; 2790 : 				mov		edx, GlassStart   //

  0011f	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2791 : 				add		edx, UDisp        //

  00122	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2792 : 				call	ppIce4Npixelz       // 

  00125	e8 36 00 00 00	 call	 $ppIce4Npixelz$109241

; 2793 : 
; 2794 : 				mov     ebx, UDisp        //

  0012a	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 2795 : 				and     ebx, 7            //

  0012d	83 e3 07	 and	 ebx, 7

; 2796 : 				jz      ppDoEndChunk        // No unaligned Positionment

  00130	74 08		 je	 SHORT $ppDoEndChunk$109239

; 2797 : 
; 2798 : 				mov		edx, GlassStart   //

  00132	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2799 : 				call	ppIceMisc8Pixelz    //

  00135	e8 a6 00 00 00	 call	 $ppIceMisc8Pixelz$109238
$ppDoEndChunk$109239:

; 2800 : 
; 2801 : 			ppDoEndChunk:                   // 
; 2802 : 				cmp		eax,Xdimension    // Any pixels left to do ? 

  0013a	3b 45 f0	 cmp	 eax, DWORD PTR _Xdimension$[ebp]

; 2803 : 				je		ppEndIceRender      //

  0013d	0f 84 db 00 00
	00		 je	 $ppEndIceRender$109242

; 2804 : 
; 2805 : 				mov     ebx, Xdimension   // Da end marker

  00143	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2806 : 				mov		edx, GlassStart   //

  00146	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2807 : 				add     edx, UDisp        // Need to since we're past the skip

  00149	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2808 : 				sub     edx, ebx          //

  0014c	2b d3		 sub	 edx, ebx
$ppDoLastChunk$109240:

; 2809 : 			ppDoLastChunk:
; 2810 : 				Call    ppIce4Npixelz       //

  0014e	e8 0d 00 00 00	 call	 $ppIce4Npixelz$109241

; 2811 : 				jmp     ppEndIceRender      //

  00153	e9 c6 00 00 00	 jmp	 $ppEndIceRender$109242

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00158	8d a4 24 00 00
	00 00 90	 npad	 8
$ppIce4Npixelz$109241:

; 2812 : 
; 2813 : 				;;  esi = LineStart
; 2814 : 				;;  edi = TexStart
; 2815 : 				;;  edx = GlassStart
; 2816 : 				;;
; 2817 : 				;;  eax = (8bit) proceeding/startpoint
; 2818 : 				;;  ebx = endpoint (compared against eax)
; 2819 : 				;;  ecx = UMask
; 2820 : 
; 2821 : 			align 16
; 2822 : 			ppIce4Npixelz:
; 2823 : 				mov     ESPStorage,esp    //

  00160	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 2824 : 				mov     EBPStorage,ebp    //

  00166	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, ebp

; 2825 : 				sub     ebx,2             // do last 2 pixels separately

  0016c	83 eb 02	 sub	 ebx, 2

; 2826 : 				mov     ebp,edx           //

  0016f	8b ea		 mov	 ebp, edx

; 2827 : 
; 2828 : 				mov     esp,ebx           //

  00171	8b e3		 mov	 esp, ebx

; 2829 : 										  //
; 2830 : 				xor     edx,edx           //

  00173	33 d2		 xor	 edx, edx

; 2831 : 				xor     ebx,ebx           //

  00175	33 db		 xor	 ebx, ebx

; 2832 : 				mov     dl,[ebp+ eax]    // Preload  dl  

  00177	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  0017b	90 8d 64 24 00	 npad	 5
$ppCopyLoop$109243:

; 2833 : 
; 2834 : 			 align 16 
; 2835 : 			 ppCopyLoop:
; 2836 : 
; 2837 : 				add     dl,al             ;;  Linestart[u]+u

  00180	02 d0		 add	 dl, al

; 2838 : 				mov     bl,[ebp+eax+1]    ;;  Glass

  00182	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 2839 :                                       
; 2840 : 				and     dl,cl			  ;;

  00186	22 d1		 and	 dl, cl

; 2841 : 				add     bl,al			  ;;

  00188	02 d8		 add	 bl, al

; 2842 :                                       
; 2843 : 				inc     bl                ;;  Linestart[u+1] + u+1

  0018a	fe c3		 inc	 bl

; 2844 : 				add     eax,2			  ;;

  0018c	83 c0 02	 add	 eax, 2

; 2845 : 										  ;;
; 2846 : 				mov     dl,[edi+edx]      ;;  Texel

  0018f	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2847 : 				and     bl,cl			  ;;

  00192	22 d9		 and	 bl, cl

; 2848 : 										  ;;
; 2849 : 				cmp     esp,eax           ;;  

  00194	3b e0		 cmp	 esp, eax

; 2850 : 				mov     [esi+eax-2],dl    ;;  Store

  00196	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 2851 :                                       
; 2852 : 				mov     bl,[edi+ebx]      ;;  Texel  // non-Positiond one WILL have Pentium-clash with Glass...

  0019a	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2853 : 				mov     dl,[ebp+eax]      ;;  Glass  // (_if still horizontally aligned...) but not usually..

  0019d	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 2854 : 										  ;;
; 2855 : 				mov     [esi+eax-2+1],bl  ;;  Store

  001a1	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 2856 : 				jne     ppCopyLoop          ;;

  001a5	75 d9		 jne	 SHORT $ppCopyLoop$109243

; 2857 : 										  ;;
; 2858 : 				;;;;;;;;;;;;;;;;;;;;;;;;;;;; 8 cyc/2pix...
; 2859 : 
; 2860 : 				mov     esp,ESPStorage    ;;

  001a7	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 2861 : 				mov     bl,[ebp+eax+1]    ;; get glasspixel 2

  001ad	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 2862 : 
; 2863 : 				add     dl,al             ;;

  001b1	02 d0		 add	 dl, al

; 2864 : 				add     bl,al             ;;

  001b3	02 d8		 add	 bl, al

; 2865 : 
; 2866 : 				inc     bl	              ;;

  001b5	fe c3		 inc	 bl

; 2867 : 				and     dl,cl             ;;

  001b7	22 d1		 and	 dl, cl

; 2868 : 
; 2869 : 				mov     ebp,EBPStorage    ;;

  001b9	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 2870 : 				and     bl,cl             ;;

  001bf	22 d9		 and	 bl, cl

; 2871 : 
; 2872 : 				mov     dl,[edi+edx]      ;; Texel

  001c1	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2873 : 				mov     bl,[edi+ebx]      ;; Texel

  001c4	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 2874 : 
; 2875 : 				mov     [esi+eax],dl      ;; Dest

  001c7	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 2876 : 				mov     [esi+eax+1],bl    ;; Dest

  001ca	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 2877 : 
; 2878 : 				add     eax,2             ;;

  001ce	83 c0 02	 add	 eax, 2

; 2879 : 				retn                      ;;

  001d1	c3		 ret	 0

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  001d2	8d a4 24 00 00
	00 00 8d a4 24
	00 00 00 00	 npad	 14
$ppIceMisc8Pixelz$109238:

; 2880 : 
; 2881 : 				;;
; 2882 : 				;;  esi = LineStart
; 2883 : 				;;  edi = TexStart
; 2884 : 				;;  edx = GlassStart
; 2885 : 				;;
; 2886 : 				;;  eax = (8bit) proceeding/startpoint
; 2887 : 				;;  ecx = UMask
; 2888 : 				;;
; 2889 : 
; 2890 : 			align 16
; 2891 : 			ppIceMisc8Pixelz:
; 2892 : 				mov     ebx,[esi+eax] // First destin word - cache warming. 

  001e0	8b 1c 06	 mov	 ebx, DWORD PTR [esi+eax]

; 2893 : 				mov     ebx,UDisp

  001e3	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 2894 : 				push    ebp

  001e6	55		 push	 ebp

; 2895 : 				mov     ESPStorage, esp

  001e7	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 2896 : 
; 2897 : 				mov		ebp, eax   //

  001ed	8b e8		 mov	 ebp, eax

; 2898 : 				add     ebp, 8     // current cntr + nr of pixels to do

  001ef	83 c5 08	 add	 ebp, 8

; 2899 : 
; 2900 : 				mov     esp, edx   // GlassStart

  001f2	8b e2		 mov	 esp, edx

; 2901 : 				
; 2902 : 				add     ebx, eax

  001f4	03 d8		 add	 ebx, eax

; 2903 : 				xor     edx, edx

  001f6	33 d2		 xor	 edx, edx

; 2904 : 				and     ebx, ecx

  001f8	23 d9		 and	 ebx, ecx

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  001fa	8d 9b 00 00 00
	00		 npad	 6
$ppCopyLp$109244:

; 2905 : 
; 2906 : 			align 16
; 2907 : 			ppCopyLp:
; 2908 : 				mov     dl, [esp+ebx]   ;; GlassStart [edx]

  00200	8a 14 1c	 mov	 dl, BYTE PTR [esp+ebx]

; 2909 : 
; 2910 : 				add     dl, al		    ;;

  00203	02 d0		 add	 dl, al

; 2911 : 				inc     ebx             ;;

  00205	43		 inc	 ebx

; 2912 : 
; 2913 : 				and     dl, cl          ;;

  00206	22 d1		 and	 dl, cl

; 2914 : 
; 2915 : 				and     ebx, ecx        ;;

  00208	23 d9		 and	 ebx, ecx

; 2916 : 				mov     dl, [edi+edx]   ;; Texel

  0020a	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 2917 : 
; 2918 : 				mov     [esi+eax], dl   ;; Destin

  0020d	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 2919 : 				inc     eax      	    ;;

  00210	40		 inc	 eax

; 2920 : 
; 2921 : 				cmp     ebp, eax	    ;;

  00211	3b e8		 cmp	 ebp, eax

; 2922 : 				jne     ppCopyLp          ;;

  00213	75 eb		 jne	 SHORT $ppCopyLp$109244

; 2923 : 
; 2924 : 				mov		esp, ESPStorage ;;

  00215	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 2925 : 				nop

  0021b	90		 npad	 1

; 2926 : 				pop		ebp             ;;

  0021c	5d		 pop	 ebp

; 2927 : 				retn

  0021d	c3		 ret	 0
$ppEndIceRender$109242:

; 2928 : 
; 2929 : 			 ppEndIceRender:
; 2930 : 			}
; 2931 : 		}
; 2932 : 		else

  0021e	e9 3b 01 00 00	 jmp	 $L109230
$L109235:

; 2933 : 		{
; 2934 : 			// Regular Pentium version - using cache warming.
; 2935 : 			__asm                        //
; 2936 : 			{                            //
; 2937 : 				mov     esi, LineStart   //

  00223	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$109232[ebp]

; 2938 : 				mov     edi, TexStart    //

  00226	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$109233[ebp]

; 2939 : 
; 2940 : 				mov     ecx, [TempUMask] //

  00229	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 2941 : 				mov     ebx, Xdimension  //

  0022c	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2942 : 				xor     eax, eax         //

  0022f	33 c0		 xor	 eax, eax

; 2943 : 
; 2944 : 				mov     ebx, Xdimension  //

  00231	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2945 : 				sub     ebx, UDisp       //

  00234	2b 5d f4	 sub	 ebx, DWORD PTR _UDisp$[ebp]

; 2946 : 
; 2947 : 				test    ebx, ecx 	     //  zero? - no split 

  00237	85 d9		 test	 ebx, ecx

; 2948 : 				jz      NoSplit          //

  00239	74 0f		 je	 SHORT $NoSplit$109246

; 2949 : 
; 2950 : 				cmp     ebx, 7           //  

  0023b	83 fb 07	 cmp	 ebx, 7

; 2951 : 				ja      SkipFirstBit     //  Skip if not in first 8 pixels.

  0023e	77 12		 ja	 SHORT $SkipFirstBit$109247

; 2952 : 
; 2953 : 				;; split is in first 8 pixels and Unaligned.
; 2954 : 
; 2955 : 				mov     edx, GlassStart  //

  00240	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2956 : 				call    IceMisc8Pixelz   //

  00243	e8 d8 00 00 00	 call	 $IceMisc8Pixelz$109248

; 2957 : 				jmp     DoEndChunk       //

  00248	eb 29		 jmp	 SHORT $DoEndChunk$109249
$NoSplit$109246:

; 2958 : 
; 2959 : 			NoSplit:                     //
; 2960 : 				mov     ebx, Xdimension  //

  0024a	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2961 : 				mov     edx, GlassStart  //

  0024d	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2962 : 				jmp     DoLastChunk      //

  00250	eb 35		 jmp	 SHORT $DoLastChunk$109250
$SkipFirstBit$109247:

; 2963 : 
; 2964 : 				///////////////////////////
; 2965 : 
; 2966 : 			SkipFirstBit:
; 2967 : 
; 2968 : 				and		ebx, 0x0FF-7;     // FF - 3     = stretch before wrapping needed

  00252	81 e3 f8 00 00
	00		 and	 ebx, 248		; 000000f8H

; 2969 : 				mov		edx, GlassStart   //

  00258	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2970 : 				add		edx, UDisp        //

  0025b	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2971 : 				call	Ice4Npixelz       // 

  0025e	e8 3d 00 00 00	 call	 $Ice4Npixelz$109251

; 2972 : 
; 2973 : 				mov     ebx, UDisp        //

  00263	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 2974 : 				and     ebx, 7            //

  00266	83 e3 07	 and	 ebx, 7

; 2975 : 				jz      DoEndChunk        // No unaligned Positionment

  00269	74 08		 je	 SHORT $DoEndChunk$109249

; 2976 : 
; 2977 : 				mov		edx, GlassStart   //

  0026b	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2978 : 				call	IceMisc8Pixelz    //

  0026e	e8 ad 00 00 00	 call	 $IceMisc8Pixelz$109248
$DoEndChunk$109249:

; 2979 : 
; 2980 : 			DoEndChunk:                   // 
; 2981 : 				cmp		eax,Xdimension    // Any pixels left to do ? 

  00273	3b 45 f0	 cmp	 eax, DWORD PTR _Xdimension$[ebp]

; 2982 : 				je		EndIceRender      //

  00276	0f 84 e2 00 00
	00		 je	 $EndIceRender$109252

; 2983 : 
; 2984 : 				mov     ebx, Xdimension   // Da end marker

  0027c	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 2985 : 				mov		edx, GlassStart   //

  0027f	8b 55 f8	 mov	 edx, DWORD PTR _GlassStart$109234[ebp]

; 2986 : 				add     edx, UDisp        // Need to since we're past the skip

  00282	03 55 f4	 add	 edx, DWORD PTR _UDisp$[ebp]

; 2987 : 				sub     edx, ebx          //

  00285	2b d3		 sub	 edx, ebx
$DoLastChunk$109250:

; 2988 : 			DoLastChunk:
; 2989 : 				Call    Ice4Npixelz       //

  00287	e8 14 00 00 00	 call	 $Ice4Npixelz$109251

; 2990 : 				jmp     EndIceRender      //

  0028c	e9 cd 00 00 00	 jmp	 $EndIceRender$109252

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00291	8d a4 24 00 00
	00 00 8d a4 24
	00 00 00 00 90	 npad	 15
$Ice4Npixelz$109251:

; 2991 : 
; 2992 : 				;;  esi = LineStart
; 2993 : 				;;  edi = TexStart
; 2994 : 				;;  edx = GlassStart
; 2995 : 				;;
; 2996 : 				;;  eax = (8bit) proceeding/startpoint
; 2997 : 				;;  ebx = endpoint (compared against eax)
; 2998 : 				;;  ecx = UMask
; 2999 : 
; 3000 : 			align 16
; 3001 : 			Ice4Npixelz:
; 3002 : 				mov     ESPStorage,esp    //

  002a0	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 3003 : 				mov     EBPStorage,ebp    //

  002a6	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, ebp

; 3004 : 				sub     ebx,2             // do last 2 pixels separately

  002ac	83 eb 02	 sub	 ebx, 2

; 3005 : 				mov     ebp,edx           //

  002af	8b ea		 mov	 ebp, edx

; 3006 : 
; 3007 : 				mov     esp,ebx           //

  002b1	8b e3		 mov	 esp, ebx

; 3008 : 										  //
; 3009 : 				xor     edx,edx           //

  002b3	33 d2		 xor	 edx, edx

; 3010 : 				xor     ebx,ebx           //

  002b5	33 db		 xor	 ebx, ebx

; 3011 : 				mov     dl,[ebp+ eax]    // Preload  dl

  002b7	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  002bb	90 8d 64 24 00	 npad	 5
$CopyLoop$109253:

; 3012 : 
; 3013 : 			 align 16 
; 3014 : 			 CopyLoop:
; 3015 : 				// cache warming by loading destination to dummy (bl)
; 3016 : 				nop                       // xor ebx,ebx slightly faster on PII

  002c0	90		 npad	 1

; 3017 : 				mov     bl,[esi+eax+2]    // This'll prime the cache EVERY 2 bytes - wasteful..

  002c1	8a 5c 06 02	 mov	 bl, BYTE PTR [esi+eax+2]

; 3018 : 			
; 3019 : 				add     dl,al             ;;  Linestart[u]+u

  002c5	02 d0		 add	 dl, al

; 3020 : 				mov     bl,[ebp+eax+1]    ;;  Glass

  002c7	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3021 :                                       
; 3022 : 				and     dl,cl			  ;;

  002cb	22 d1		 and	 dl, cl

; 3023 : 				add     bl,al			  ;;

  002cd	02 d8		 add	 bl, al

; 3024 :                                       
; 3025 : 				inc     bl                ;;  Linestart[u+1] + u+1

  002cf	fe c3		 inc	 bl

; 3026 : 				add     eax,2			  ;;

  002d1	83 c0 02	 add	 eax, 2

; 3027 : 										  ;;
; 3028 : 				mov     dl,[edi+edx]      ;;  Texel

  002d4	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3029 : 				and     bl,cl			  ;;

  002d7	22 d9		 and	 bl, cl

; 3030 : 										  ;;
; 3031 : 				cmp     esp,eax           ;;  

  002d9	3b e0		 cmp	 esp, eax

; 3032 : 				mov     [esi+eax-2],dl    ;;  Store

  002db	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 3033 :                                       
; 3034 : 				mov     bl,[edi+ebx]      ;;  Texel  // non-Positiond one WILL have Pentium-clash with Glass...

  002df	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3035 : 				mov     dl,[ebp+eax]      ;;  Glass  // (_if still horizontally aligned...) but not usually..

  002e2	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3036 : 										  ;;
; 3037 : 				mov     [esi+eax-2+1],bl  ;;  Store

  002e6	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 3038 : 				jne     CopyLoop          ;;

  002ea	75 d4		 jne	 SHORT $CopyLoop$109253

; 3039 : 										  ;;
; 3040 : 				;;;;;;;;;;;;;;;;;;;;;;;;;;;; 8 cyc/2pix...
; 3041 : 
; 3042 : 				mov     esp,ESPStorage    ;;

  002ec	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 3043 : 				mov     bl,[ebp+eax+1]    ;; get glasspixel 2

  002f2	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3044 : 
; 3045 : 				add     dl,al             ;;

  002f6	02 d0		 add	 dl, al

; 3046 : 				add     bl,al             ;;

  002f8	02 d8		 add	 bl, al

; 3047 : 
; 3048 : 				inc     bl	              ;;

  002fa	fe c3		 inc	 bl

; 3049 : 				and     dl,cl             ;;

  002fc	22 d1		 and	 dl, cl

; 3050 : 
; 3051 : 				mov     ebp,EBPStorage    ;;

  002fe	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 3052 : 				and     bl,cl             ;;

  00304	22 d9		 and	 bl, cl

; 3053 : 
; 3054 : 				mov     dl,[edi+edx]      ;; Texel

  00306	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3055 : 				mov     bl,[edi+ebx]      ;; Texel

  00309	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3056 : 
; 3057 : 				mov     [esi+eax],dl      ;; Dest

  0030c	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3058 : 				mov     [esi+eax+1],bl    ;; Dest

  0030f	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 3059 : 
; 3060 : 				add     eax,2             ;;

  00313	83 c0 02	 add	 eax, 2

; 3061 : 				retn                      ;;

  00316	c3		 ret	 0

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00317	8d a4 24 00 00
	00 00 8b ff	 npad	 9
$IceMisc8Pixelz$109248:

; 3062 : 
; 3063 : 				;;
; 3064 : 				;;  esi = LineStart
; 3065 : 				;;  edi = TexStart
; 3066 : 				;;  edx = GlassStart
; 3067 : 				;;
; 3068 : 				;;  eax = (8bit) proceeding/startpoint
; 3069 : 				;;  ecx = UMask
; 3070 : 				;;
; 3071 : 
; 3072 : 			align 16
; 3073 : 			IceMisc8Pixelz:
; 3074 : 				mov     ebx,[esi+eax] // First destin word - cache warming. 

  00320	8b 1c 06	 mov	 ebx, DWORD PTR [esi+eax]

; 3075 : 				mov     ebx,UDisp

  00323	8b 5d f4	 mov	 ebx, DWORD PTR _UDisp$[ebp]

; 3076 : 				push    ebp

  00326	55		 push	 ebp

; 3077 : 				mov     ESPStorage, esp

  00327	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA, esp

; 3078 : 
; 3079 : 				mov		ebp, eax   //

  0032d	8b e8		 mov	 ebp, eax

; 3080 : 				add     ebp, 8     // current cntr + nr of pixels to do

  0032f	83 c5 08	 add	 ebp, 8

; 3081 : 
; 3082 : 				mov     esp, edx   // GlassStart

  00332	8b e2		 mov	 esp, edx

; 3083 : 				
; 3084 : 				add     ebx, eax

  00334	03 d8		 add	 ebx, eax

; 3085 : 				xor     edx, edx

  00336	33 d2		 xor	 edx, edx

; 3086 : 				and     ebx, ecx

  00338	23 d9		 and	 ebx, ecx

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  0033a	8d 9b 00 00 00
	00		 npad	 6
$CopyLp$109254:

; 3087 : 
; 3088 : 			align 16
; 3089 : 			CopyLp:
; 3090 : 				mov     dl, [esp+ebx]   ;; GlassStart [edx]

  00340	8a 14 1c	 mov	 dl, BYTE PTR [esp+ebx]

; 3091 : 
; 3092 : 				add     dl, al		    ;;

  00343	02 d0		 add	 dl, al

; 3093 : 				inc     ebx             ;;

  00345	43		 inc	 ebx

; 3094 : 
; 3095 : 				and     dl, cl          ;;

  00346	22 d1		 and	 dl, cl

; 3096 : 
; 3097 : 				and     ebx, ecx        ;;

  00348	23 d9		 and	 ebx, ecx

; 3098 : 				mov     dl, [edi+edx]   ;; Texel

  0034a	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3099 : 
; 3100 : 				mov     [esi+eax], dl   ;; Destin

  0034d	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3101 : 				inc     eax      	    ;;

  00350	40		 inc	 eax

; 3102 : 
; 3103 : 				cmp     ebp, eax	    ;;

  00351	3b e8		 cmp	 ebp, eax

; 3104 : 				jne     CopyLp          ;;

  00353	75 eb		 jne	 SHORT $CopyLp$109254

; 3105 : 
; 3106 : 				mov		esp, ESPStorage ;;

  00355	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitTexIce@UIceTexture@@AAEXXZ@4KA

; 3107 : 				nop

  0035b	90		 npad	 1

; 3108 : 				pop		ebp             ;;

  0035c	5d		 pop	 ebp

; 3109 : 				retn

  0035d	c3		 ret	 0
$EndIceRender$109252:
$L109230:

; 2744 : 
; 2745 :     for( INT v=0; v<Ydimension; v++ )

  0035e	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00361	8b 4d cc	 mov	 ecx, DWORD PTR _Ydimension$[ebp]
  00364	40		 inc	 eax
  00365	3b c1		 cmp	 eax, ecx
  00367	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax
  0036a	0f 8c 38 fd ff
	ff		 jl	 $L118770
$L109231:

; 3110 : 
; 3111 : 			 EndIceRender:
; 3112 : 			}
; 3113 : 		}
; 3114 : 
; 3115 : #else
; 3116 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3117 :         {
; 3118 : 			// Coolish effect combining half warped, half original.
; 3119 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3120 : 
; 3121 : 			INT u2 = u+1;
; 3122 : 			// Help C++ with pipelining...
; 3123 : 
; 3124 : 			LineStart[u]  =  TexStart[( u +  GlassStart[(u +UDisp) & UMask]) & UMask ] ;
; 3125 : 			LineStart[u2] =  TexStart[( u2 + GlassStart[(u2+UDisp) & UMask]) & UMask ] ;
; 3126 :         }
; 3127 : #endif
; 3128 : 
; 3129 : 	}
; 3130 : }

  00370	5f		 pop	 edi
  00371	5e		 pop	 esi
  00372	5b		 pop	 ebx
  00373	8b e5		 mov	 esp, ebp
  00375	5d		 pop	 ebp
  00376	c3		 ret	 0
?BlitTexIce@UIceTexture@@AAEXXZ ENDP			; UIceTexture::BlitTexIce
_TEXT	ENDS
PUBLIC	?BlitIceTex@UIceTexture@@AAEXXZ			; UIceTexture::BlitIceTex
_BSS	SEGMENT
?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; `UIceTexture::BlitIceTex'::`4'::ESPStorage
?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA DD 01H DUP (?) ; `UIceTexture::BlitIceTex'::`4'::EBPStorage
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?BlitIceTex@UIceTexture@@AAEXXZ
_TEXT	SEGMENT
_this$ = -32
_TexAddr$ = -44
_GlassAddr$ = -48
_BitMapAddr$ = -40
_Xdimension$ = -16
_Ydimension$ = -52
_TempUMask$ = -20
_UDisp$ = -8
_VDisp$ = -36
_v$ = -4
_LineStart$109275 = -28
_TexStart$109276 = -24
_GlassStart$109277 = -12
_I$118793 = -24
$T118795 = -28
_I$118799 = -24
$T118801 = -28
?BlitIceTex@UIceTexture@@AAEXXZ PROC NEAR		; UIceTexture::BlitIceTex, COMDAT
; _this$ = ecx

; 3138 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	8b c1		 mov	 eax, ecx

; 3139 :     // Warning: Source/GlassTexture must have same dimensions..
; 3140 : 
; 3141 :     BYTE* TexAddr		= &SourceTexture->Mips(0).DataArray(0);

  00008	8b 88 e4 00 00
	00		 mov	 ecx, DWORD PTR [eax+228]
  0000e	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  00014	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 3142 : 	BYTE* GlassAddr		= &GlassTexture->Mips(0).DataArray(0);

  00017	8b 90 e0 00 00
	00		 mov	 edx, DWORD PTR [eax+224]
  0001d	89 4d d4	 mov	 DWORD PTR _TexAddr$[ebp], ecx
  00020	8b 8a a8 00 00
	00		 mov	 ecx, DWORD PTR [edx+168]
  00026	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 3143 :     BYTE* BitMapAddr	= &Mips(0).DataArray(0);  // Pointer

  00029	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  0002f	89 55 d0	 mov	 DWORD PTR _GlassAddr$[ebp], edx
  00032	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 3144 : 
; 3145 : 	if( LocalSourceBitmap ) return; // Static local source, no update needed.

  00035	8b 88 1c 01 00
	00		 mov	 ecx, DWORD PTR [eax+284]
  0003b	85 c9		 test	 ecx, ecx
  0003d	56		 push	 esi
  0003e	57		 push	 edi
  0003f	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
  00042	89 55 d8	 mov	 DWORD PTR _BitMapAddr$[ebp], edx
  00045	0f 85 cb 01 00
	00		 jne	 $L109274

; 3146 : 
; 3147 :     INT  Xdimension   = USize;  // Wrap needed for 8-bit counters.

  0004b	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]

; 3148 :     INT  Ydimension   = VSize;  //
; 3149 : 
; 3150 : #if ICEASM
; 3151 : 	INT  TempUMask    = UMask;

  0004e	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00054	89 4d f0	 mov	 DWORD PTR _Xdimension$[ebp], ecx
  00057	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005a	89 55 ec	 mov	 DWORD PTR _TempUMask$[ebp], edx

; 3152 : #endif
; 3153 : 
; 3154 : 	static	DWORD ESPStorage;   // Temp ESP storage
; 3155 : 	static	DWORD EBPStorage;   // Temp EBP storage
; 3156 : 
; 3157 : 	// Positionments are (signed) fixed-point 3:4
; 3158 : 	INT  UDisp = appRound(UPosition) & UMask;

  0005d	8b 90 00 01 00
	00		 mov	 edx, DWORD PTR [eax+256]
  00063	89 4d cc	 mov	 DWORD PTR _Ydimension$[ebp], ecx
  00066	89 55 e4	 mov	 DWORD PTR $T118795[ebp], edx
  00069	d9 45 e4	 fld	 DWORD PTR $T118795[ebp]
  0006c	db 5d e8	 fistp	 DWORD PTR _I$118793[ebp]
  0006f	8b 90 c8 00 00
	00		 mov	 edx, DWORD PTR [eax+200]
  00075	23 55 e8	 and	 edx, DWORD PTR _I$118793[ebp]
  00078	89 55 f8	 mov	 DWORD PTR _UDisp$[ebp], edx

; 3159 : 	INT  VDisp = appRound(VPosition) & VMask;

  0007b	8b 90 04 01 00
	00		 mov	 edx, DWORD PTR [eax+260]
  00081	89 55 e4	 mov	 DWORD PTR $T118801[ebp], edx
  00084	d9 45 e4	 fld	 DWORD PTR $T118801[ebp]
  00087	db 5d e8	 fistp	 DWORD PTR _I$118799[ebp]
  0008a	8b b0 cc 00 00
	00		 mov	 esi, DWORD PTR [eax+204]
  00090	8b 7d e8	 mov	 edi, DWORD PTR _I$118799[ebp]
  00093	23 fe		 and	 edi, esi

; 3160 : 
; 3161 :     for( INT v=0; v<Ydimension; v++ )

  00095	33 f6		 xor	 esi, esi
  00097	85 c9		 test	 ecx, ecx
  00099	89 7d dc	 mov	 DWORD PTR _VDisp$[ebp], edi
  0009c	89 75 fc	 mov	 DWORD PTR _v$[ebp], esi
  0009f	0f 8e 71 01 00
	00		 jle	 $L109274
  000a5	53		 push	 ebx
  000a6	eb 09		 jmp	 SHORT $L109272
$L118805:
  000a8	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 7d dc	 mov	 edi, DWORD PTR _VDisp$[ebp]
  000ae	8b 75 fc	 mov	 esi, DWORD PTR _v$[ebp]
$L109272:

; 3162 :     {
; 3163 : 		BYTE* LineStart   = BitMapAddr +    ( v << UBits );

  000b1	0f b6 48 30	 movzx	 ecx, BYTE PTR [eax+48]
  000b5	8b 5d d8	 mov	 ebx, DWORD PTR _BitMapAddr$[ebp]
  000b8	8b d6		 mov	 edx, esi
  000ba	d3 e2		 shl	 edx, cl

; 3164 : 		BYTE* TexStart    = TexAddr    + (((v + VDisp) & VMask) << UBits);

  000bc	03 f7		 add	 esi, edi
  000be	03 da		 add	 ebx, edx
  000c0	89 5d e4	 mov	 DWORD PTR _LineStart$109275[ebp], ebx
  000c3	8b 98 cc 00 00
	00		 mov	 ebx, DWORD PTR [eax+204]

; 3165 : 		BYTE* GlassStart  = GlassAddr  +    ( v << UBits );

  000c9	8b 45 d0	 mov	 eax, DWORD PTR _GlassAddr$[ebp]
  000cc	23 f3		 and	 esi, ebx
  000ce	d3 e6		 shl	 esi, cl
  000d0	8b 4d d4	 mov	 ecx, DWORD PTR _TexAddr$[ebp]
  000d3	03 d0		 add	 edx, eax
  000d5	89 55 f4	 mov	 DWORD PTR _GlassStart$109277[ebp], edx
  000d8	03 f1		 add	 esi, ecx

; 3166 : 
; 3167 : #if ICEASM
; 3168 : 
; 3169 : 		// PPro-optimized version (no cache warming)
; 3170 : 		if( GIsPentiumPro )

  000da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp__GIsPentiumPro
  000e0	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000e3	89 75 e8	 mov	 DWORD PTR _TexStart$109276[ebp], esi
  000e6	0f 84 87 00 00
	00		 je	 $L109278

; 3171 : 		{  		
; 3172 : 			__asm                         
; 3173 : 			{                             
; 3174 : 				mov     esi, LineStart    //

  000ec	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$109275[ebp]

; 3175 : 				mov     edi, TexStart     //

  000ef	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$109276[ebp]

; 3176 : 
; 3177 : 				mov     ecx, [TempUMask]  //

  000f2	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 3178 : 
; 3179 : 				mov     ebx, Xdimension   //

  000f5	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 3180 : 				mov     edx, GlassStart   //

  000f8	8b 55 f4	 mov	 edx, DWORD PTR _GlassStart$109277[ebp]

; 3181 : 
; 3182 : 				mov     eax, UDisp        //

  000fb	8b 45 f8	 mov	 eax, DWORD PTR _UDisp$[ebp]

; 3183 : 
; 3184 : 				add		ebx,eax           //  compensate for source-texture X-bias

  000fe	03 d8		 add	 ebx, eax

; 3185 : 				sub     edx,eax           //

  00100	2b d0		 sub	 edx, eax

; 3186 : 				sub     esi,eax           //

  00102	2b f0		 sub	 esi, eax

; 3187 : 
; 3188 : 			//Ice4Npixelz:
; 3189 : 
; 3190 : 				mov     ESPStorage,esp    //

  00104	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, esp

; 3191 : 				mov     EBPStorage,ebp    //

  0010a	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, ebp

; 3192 : 
; 3193 : 				sub     ebx,2             //  Do last 2 pixels separately

  00110	83 eb 02	 sub	 ebx, 2

; 3194 : 				mov     ebp,edx           //

  00113	8b ea		 mov	 ebp, edx

; 3195 : 				mov     esp,ebx           //

  00115	8b e3		 mov	 esp, ebx

; 3196 : 
; 3197 : 				xor     edx,edx           //

  00117	33 d2		 xor	 edx, edx

; 3198 : 				xor     ebx,ebx           //

  00119	33 db		 xor	 ebx, ebx

; 3199 : 
; 3200 : 				mov     dl,[ebp+eax]      //  Preload  dl

  0011b	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3327 : 			}
; 3328 : 		}
; 3329 : #else
; 3330 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3331 :         {
; 3332 : 			// Coolish effect combining half warped, half original.
; 3333 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3334 : 
; 3335 : 			INT u2 = u+1; // Help C++ with pipelining...
; 3336 : 
; 3337 : 			LineStart[u]  =  TexStart[(  u + UDisp + GlassStart[ u]) & UMask ] ;
; 3338 : 			LineStart[u2] =  TexStart[( u2 + UDisp + GlassStart[u2]) & UMask ] ;
; 3339 :         }
; 3340 : #endif
; 3341 : 
; 3342 : 	}
; 3343 : }

  0011f	90		 npad	 1
$CopyLoop$109279:

; 3201 : 
; 3202 : 			 align 16
; 3203 : 			 CopyLoop: 
; 3204 : 				add     dl,al             //  Linestart[u]+u

  00120	02 d0		 add	 dl, al

; 3205 : 				mov     bl,[ebp+eax+1]    //  Glass

  00122	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3206 : 										  //
; 3207 : 				and     dl,cl			  //  wrap using mask

  00126	22 d1		 and	 dl, cl

; 3208 : 				add     bl,al			  //

  00128	02 d8		 add	 bl, al

; 3209 : 										  //
; 3210 : 				inc     bl                //  Linestart[u+1] + u+1

  0012a	fe c3		 inc	 bl

; 3211 : 				add     eax,2			  //  // AL not changed itself so no stall

  0012c	83 c0 02	 add	 eax, 2

; 3212 : 										  //
; 3213 : 				mov     dl,[edi+edx]      //  Texel

  0012f	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3214 : 				and     bl,cl			  //  wrap using mask

  00132	22 d9		 and	 bl, cl

; 3215 : 										  //
; 3216 : 				cmp     esp,eax           //

  00134	3b e0		 cmp	 esp, eax

; 3217 : 				mov     [esi+eax-2],dl    //  Store

  00136	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 3218 : 										  //
; 3219 : 				mov     bl,[edi+ebx]      //  Texel

  0013a	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3220 : 				mov     dl,[ebp+eax]      //  Glass

  0013d	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3221 : 										  //
; 3222 : 				mov     [esi+eax-2+1],bl  //  Store

  00141	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 3223 : 				jne     CopyLoop          //

  00145	75 d9		 jne	 SHORT $CopyLoop$109279

; 3224 : 										  //
; 3225 : 				////////////////////////////
; 3226 : 
; 3227 : 				mov     esp,ESPStorage    //

  00147	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3228 : 				mov     bl,[ebp+eax+1]    // get glasspixel 2

  0014d	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3229 : 
; 3230 : 				add     dl,al             //

  00151	02 d0		 add	 dl, al

; 3231 : 				add     bl,al             //

  00153	02 d8		 add	 bl, al

; 3232 : 
; 3233 : 				inc     bl	              // ebx	    

  00155	fe c3		 inc	 bl

; 3234 : 				and     dl,cl             // edx,ecx 

  00157	22 d1		 and	 dl, cl

; 3235 : 
; 3236 : 				mov     ebp,EBPStorage

  00159	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3237 : 				and     bl,cl             // ebx,ecx 

  0015f	22 d9		 and	 bl, cl

; 3238 : 
; 3239 : 				mov     dl,[edi+edx]      // Texel

  00161	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3240 : 				mov     bl,[edi+ebx]      // Texel

  00164	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3241 : 
; 3242 : 				mov     [esi+eax],dl      // Dest

  00167	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3243 : 				mov     [esi+eax+1],bl    // Dest

  0016a	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl

; 3244 : 
; 3245 : 			}
; 3246 : 		}		
; 3247 : 		else

  0016e	e9 90 00 00 00	 jmp	 $L109273
$L109278:

; 3248 : 
; 3249 : 		// Pentium / Pentium MMX optimized version (WITH cache warming)
; 3250 : 		{
; 3251 : 			__asm                         
; 3252 : 			{                             
; 3253 : 				mov     esi, LineStart    //

  00173	8b 75 e4	 mov	 esi, DWORD PTR _LineStart$109275[ebp]

; 3254 : 				mov     edi, TexStart     //

  00176	8b 7d e8	 mov	 edi, DWORD PTR _TexStart$109276[ebp]

; 3255 : 
; 3256 : 				mov     ecx, [TempUMask]  //

  00179	8b 4d ec	 mov	 ecx, DWORD PTR _TempUMask$[ebp]

; 3257 : 
; 3258 : 				mov     ebx, Xdimension   //

  0017c	8b 5d f0	 mov	 ebx, DWORD PTR _Xdimension$[ebp]

; 3259 : 				mov     edx, GlassStart   //

  0017f	8b 55 f4	 mov	 edx, DWORD PTR _GlassStart$109277[ebp]

; 3260 : 
; 3261 : 				mov     eax, UDisp        //

  00182	8b 45 f8	 mov	 eax, DWORD PTR _UDisp$[ebp]

; 3262 : 
; 3263 : 				add		ebx,eax           //  compensate for source-texture X-bias

  00185	03 d8		 add	 ebx, eax

; 3264 : 				sub     edx,eax           //

  00187	2b d0		 sub	 edx, eax

; 3265 : 				sub     esi,eax           //

  00189	2b f0		 sub	 esi, eax

; 3266 : 
; 3267 : 			//Ice4Npixelz:
; 3268 : 
; 3269 : 				mov     ESPStorage,esp    //

  0018b	89 25 00 00 00
	00		 mov	 DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, esp

; 3270 : 				mov     EBPStorage,ebp    //

  00191	89 2d 00 00 00
	00		 mov	 DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA, ebp

; 3271 : 
; 3272 : 				sub     ebx,2             //  Do last 2 pixels separately

  00197	83 eb 02	 sub	 ebx, 2

; 3273 : 				mov     ebp,edx           //

  0019a	8b ea		 mov	 ebp, edx

; 3274 : 				mov     esp,ebx           //

  0019c	8b e3		 mov	 esp, ebx

; 3275 : 
; 3276 : 				xor     edx,edx           //

  0019e	33 d2		 xor	 edx, edx

; 3277 : 				xor     ebx,ebx           //

  001a0	33 db		 xor	 ebx, ebx

; 3278 : 
; 3279 : 				mov     dl,[ebp+eax]      //  Preload  dl

  001a2	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3327 : 			}
; 3328 : 		}
; 3329 : #else
; 3330 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3331 :         {
; 3332 : 			// Coolish effect combining half warped, half original.
; 3333 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3334 : 
; 3335 : 			INT u2 = u+1; // Help C++ with pipelining...
; 3336 : 
; 3337 : 			LineStart[u]  =  TexStart[(  u + UDisp + GlassStart[ u]) & UMask ] ;
; 3338 : 			LineStart[u2] =  TexStart[( u2 + UDisp + GlassStart[u2]) & UMask ] ;
; 3339 :         }
; 3340 : #endif
; 3341 : 
; 3342 : 	}
; 3343 : }

  001a6	8d a4 24 00 00
	00 00 8d 49 00	 npad	 10
$CopyLoop2$109281:

; 3280 : 
; 3281 : 			 align 16
; 3282 :     		 CopyLoop2: 
; 3283 : 
; 3284 : 				nop				 		  //  

  001b0	90		 npad	 1

; 3285 : 				mov     bl,[esi+eax-2]    //  cache-warming load - per word..

  001b1	8a 5c 06 fe	 mov	 bl, BYTE PTR [esi+eax-2]

; 3286 : 
; 3287 : 				add     dl,al             //  Linestart[u]+u

  001b5	02 d0		 add	 dl, al

; 3288 : 				mov     bl,[ebp+eax+1]    //  Glass

  001b7	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3289 : 										  //
; 3290 : 				and     dl,cl			  //

  001bb	22 d1		 and	 dl, cl

; 3291 : 				add     bl,al			  //

  001bd	02 d8		 add	 bl, al

; 3292 : 										  //
; 3293 : 				inc     bl                //  Linestart[u+1] + u+1

  001bf	fe c3		 inc	 bl

; 3294 : 				add     eax,2			  //  // AL not changed itself so no stall

  001c1	83 c0 02	 add	 eax, 2

; 3295 : 										  //
; 3296 : 				mov     dl,[edi+edx]      //  Texel

  001c4	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3297 : 				and     bl,cl			  //

  001c7	22 d9		 and	 bl, cl

; 3298 : 										  //
; 3299 : 				cmp     esp,eax           //

  001c9	3b e0		 cmp	 esp, eax

; 3300 : 				mov     [esi+eax-2],dl    //  Store

  001cb	88 54 06 fe	 mov	 BYTE PTR [esi+eax-2], dl

; 3301 : 										  //
; 3302 : 				mov     bl,[edi+ebx]      //  Texel

  001cf	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3303 : 				mov     dl,[ebp+eax]      //  Glass

  001d2	8a 54 05 00	 mov	 dl, BYTE PTR [ebp+eax]

; 3304 : 										  //
; 3305 : 				mov     [esi+eax-2+1],bl  //  Store

  001d6	88 5c 06 ff	 mov	 BYTE PTR [esi+eax-1], bl

; 3306 : 				jne     CopyLoop2         //

  001da	75 d4		 jne	 SHORT $CopyLoop2$109281

; 3307 : 										  //
; 3308 : 				////////////////////////////
; 3309 : 
; 3310 : 				mov     esp,ESPStorage    //

  001dc	8b 25 00 00 00
	00		 mov	 esp, DWORD PTR ?ESPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3311 : 				mov     bl,[ebp+eax+1]    // get glasspixel 2

  001e2	8a 5c 05 01	 mov	 bl, BYTE PTR [ebp+eax+1]

; 3312 : 
; 3313 : 				add     dl,al             //

  001e6	02 d0		 add	 dl, al

; 3314 : 				add     bl,al             //

  001e8	02 d8		 add	 bl, al

; 3315 : 
; 3316 : 				inc     bl				  //

  001ea	fe c3		 inc	 bl

; 3317 : 				and     dl,cl			  //

  001ec	22 d1		 and	 dl, cl

; 3318 : 
; 3319 : 				mov     ebp,EBPStorage    //

  001ee	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR ?EBPStorage@?3??BlitIceTex@UIceTexture@@AAEXXZ@4KA

; 3320 : 				and     bl,cl		      //

  001f4	22 d9		 and	 bl, cl

; 3321 : 
; 3322 : 				mov     dl,[edi+edx]      // Texel

  001f6	8a 14 17	 mov	 dl, BYTE PTR [edi+edx]

; 3323 : 				mov     bl,[edi+ebx]      // Texel

  001f9	8a 1c 1f	 mov	 bl, BYTE PTR [edi+ebx]

; 3324 : 
; 3325 : 				mov     [esi+eax],dl      // Dest

  001fc	88 14 06	 mov	 BYTE PTR [esi+eax], dl

; 3326 : 				mov     [esi+eax+1],bl    // Dest

  001ff	88 5c 06 01	 mov	 BYTE PTR [esi+eax+1], bl
$L109273:

; 3160 : 
; 3161 :     for( INT v=0; v<Ydimension; v++ )

  00203	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]
  00206	8b 4d cc	 mov	 ecx, DWORD PTR _Ydimension$[ebp]
  00209	40		 inc	 eax
  0020a	3b c1		 cmp	 eax, ecx
  0020c	89 45 fc	 mov	 DWORD PTR _v$[ebp], eax
  0020f	0f 8c 93 fe ff
	ff		 jl	 $L118805
  00215	5b		 pop	 ebx
$L109274:
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi

; 3327 : 			}
; 3328 : 		}
; 3329 : #else
; 3330 : 		for( INT u=0; u<Xdimension; u+=2 )
; 3331 :         {
; 3332 : 			// Coolish effect combining half warped, half original.
; 3333 : 			// LineStart[u] = (  SourceStart[(u+LineStart[u]) & UMask ] + SourceStart[(u+128) & UMask]  ) >> 1;
; 3334 : 
; 3335 : 			INT u2 = u+1; // Help C++ with pipelining...
; 3336 : 
; 3337 : 			LineStart[u]  =  TexStart[(  u + UDisp + GlassStart[ u]) & UMask ] ;
; 3338 : 			LineStart[u2] =  TexStart[( u2 + UDisp + GlassStart[u2]) & UMask ] ;
; 3339 :         }
; 3340 : #endif
; 3341 : 
; 3342 : 	}
; 3343 : }

  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c3		 ret	 0
?BlitIceTex@UIceTexture@@AAEXXZ ENDP			; UIceTexture::BlitIceTex
_TEXT	ENDS
PUBLIC	?WaterRedrawDrops@UWaterTexture@@QAEXXZ		; UWaterTexture::WaterRedrawDrops
; Function compile flags: /Ogty
;	COMDAT ?WaterRedrawDrops@UWaterTexture@@QAEXXZ
_TEXT	SEGMENT
_this$ = -32
_U2Mask$ = -36
_V2Mask$ = -35
_SegSize$ = -28
_Depth$ = -34
_t$ = -24
_S$ = -8
_Xnow$109303 = -34
_Ynow$109304 = -33
_DropDest$109305 = -20
_Spray$109424 = -33
_AddDestY$109425 = -4
?WaterRedrawDrops@UWaterTexture@@QAEXXZ PROC NEAR	; UWaterTexture::WaterRedrawDrops, COMDAT
; _this$ = ecx

; 3357 : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H

; 3358 :     //
; 3359 :     // Waterdrops setting from the editable list.
; 3360 :     //
; 3361 : 	//
; 3362 :     // Warning: All code manipulating the wave source-field
; 3363 :     //          must be aware it only has 1/2 the dimension
; 3364 :     //          of the actual output bitmap.
; 3365 : 	//
; 3366 : 
; 3367 :     BYTE  U2Mask = UMask >> 1;       // warning: 1/2 of full output size

  00003	8b 81 c8 00 00
	00		 mov	 eax, DWORD PTR [ecx+200]
  00009	d1 f8		 sar	 eax, 1
  0000b	88 44 24 00	 mov	 BYTE PTR _U2Mask$[esp+36], al

; 3368 :     BYTE  V2Mask = VMask >> 1;       // 

  0000f	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  00015	d1 f8		 sar	 eax, 1
  00017	88 44 24 01	 mov	 BYTE PTR _V2Mask$[esp+36], al

; 3369 :     INT   XSize  = USize/2;          // 

  0001b	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0001e	99		 cdq
  0001f	2b c2		 sub	 eax, edx

; 3370 :     BYTE* WaveFieldA = SourceFields; //
; 3371 :     BYTE* WaveFieldB = SourceFields + XSize;
; 3372 :     INT   SegSize;
; 3373 : 	BYTE  Depth;
; 3374 : 
; 3375 :     GlobalPhase++;

  00021	8b 91 d8 00 00
	00		 mov	 edx, DWORD PTR [ecx+216]
  00027	55		 push	 ebp
  00028	8b a9 f0 08 00
	00		 mov	 ebp, DWORD PTR [ecx+2288]
  0002e	57		 push	 edi
  0002f	8b f8		 mov	 edi, eax

; 3376 : 
; 3377 : 	INT  t;
; 3378 : 
; 3379 :     for( INT S=0; S<NumDrops; S++ )

  00031	8b 81 ec 00 00
	00		 mov	 eax, DWORD PTR [ecx+236]
  00037	d1 ff		 sar	 edi, 1
  00039	03 fd		 add	 edi, ebp
  0003b	42		 inc	 edx
  0003c	85 c0		 test	 eax, eax
  0003e	89 4c 24 0c	 mov	 DWORD PTR _this$[esp+44], ecx
  00042	89 91 d8 00 00
	00		 mov	 DWORD PTR [ecx+216], edx
  00048	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _S$[esp+44], 0
  00050	0f 8e 65 09 00
	00		 jle	 $L109302
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	8d b1 f7 00 00
	00		 lea	 esi, DWORD PTR [ecx+247]
  0005e	eb 04		 jmp	 SHORT $L109300
$L118871:

; 3358 :     //
; 3359 :     // Waterdrops setting from the editable list.
; 3360 :     //
; 3361 : 	//
; 3362 :     // Warning: All code manipulating the wave source-field
; 3363 :     //          must be aware it only has 1/2 the dimension
; 3364 :     //          of the actual output bitmap.
; 3365 : 	//
; 3366 : 
; 3367 :     BYTE  U2Mask = UMask >> 1;       // warning: 1/2 of full output size

  00060	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
$L109300:

; 3380 :     {
; 3381 :         BYTE Xnow = Drops[S].X;
; 3382 :         BYTE Ynow = Drops[S].Y;

  00064	8a 46 fc	 mov	 al, BYTE PTR [esi-4]
  00067	8a 5e fb	 mov	 bl, BYTE PTR [esi-5]

; 3383 :         DWORD DropDest   = (DWORD)( ( Ynow << UBits ) + Xnow);

  0006a	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0006d	33 d2		 xor	 edx, edx
  0006f	8a d0		 mov	 dl, al
  00071	88 44 24 13	 mov	 BYTE PTR _Ynow$109304[esp+52], al
  00075	88 5c 24 12	 mov	 BYTE PTR _Xnow$109303[esp+52], bl
  00079	0f b6 db	 movzx	 ebx, bl
  0007c	8b c2		 mov	 eax, edx
  0007e	d3 e0		 shl	 eax, cl
  00080	89 54 24 30	 mov	 DWORD PTR -4+[esp+52], edx
  00084	8d 0c 03	 lea	 ecx, DWORD PTR [ebx+eax]
  00087	89 44 24 1c	 mov	 DWORD PTR -24+[esp+52], eax

; 3384 : 
; 3385 :         switch( Drops[S].Type )
; 3386 :         {

  0008b	0f b6 46 f9	 movzx	 eax, BYTE PTR [esi-7]
  0008f	83 f8 41	 cmp	 eax, 65			; 00000041H
  00092	89 4c 24 20	 mov	 DWORD PTR _DropDest$109305[esp+52], ecx
  00096	0f 87 ff 08 00
	00		 ja	 $L109301
  0009c	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $L118870[eax]
  000a3	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $L118880[eax*4]
$L109311:

; 3387 : 
; 3388 :         case DROP_FixedDepth:   // FIXEDD-depth pixy
; 3389 :             Depth = Drops[S].ByteD;

  000aa	8a 06		 mov	 al, BYTE PTR [esi]

; 3390 :             WaveFieldA[ DropDest ]  =  Depth;

  000ac	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3391 :             WaveFieldB[ DropDest ]  =  Depth;

  000af	88 04 39	 mov	 BYTE PTR [ecx+edi], al

; 3392 :             break; 

  000b2	e9 e4 08 00 00	 jmp	 $L109301
$L109312:

; 3393 : 
; 3394 : 		case DROP_PhaseSpot:   // Phased I
; 3395 : 			{
; 3396 :        	    Drops[S].Depth += Drops[S].ByteD; // update phase

  000b7	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  000ba	8a 16		 mov	 dl, BYTE PTR [esi]
  000bc	02 c2		 add	 al, dl
  000be	88 46 fa	 mov	 BYTE PTR [esi-6], al

; 3397 :             Depth = PhaseTable[ Drops[S].Depth ];

  000c1	0f b6 c0	 movzx	 eax, al
  000c4	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]

; 3398 :             WaveFieldA[ DropDest ]  =  Depth;

  000ca	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3399 :             WaveFieldB[ DropDest ]  =  Depth;

  000cd	88 04 39	 mov	 BYTE PTR [ecx+edi], al

; 3400 : 
; 3401 : 			/*
; 3402 : 			DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3403 : 				  Phase16=0xFFFF & ( Phase16 + ((DWORD)Drops[S].ByteD << 8) + (DWORD)Drops[S].ByteC );
; 3404 : 
; 3405 : 			Drops[S].ByteA =    Phase16 & 0xFF;
; 3406 : 			Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;
; 3407 : 
; 3408 : 			// Real 16-bit phase is B:A, delta= D:C
; 3409 : 			Depth = PhaseTable[ Drops[S].ByteB ];
; 3410 : 			WaveFieldA[ DropDest ]  =  Depth;
; 3411 : 			WaveFieldB[ DropDest ]  =  Depth;
; 3412 : 			*/
; 3413 : 
; 3414 : 			}
; 3415 :             break;

  000d0	e9 c6 08 00 00	 jmp	 $L109301
$L109313:

; 3416 : 
; 3417 : 		case DROP_HalfAmpl:     // half amplitude: only goes down INT  o water
; 3418 : 			Drops[S].Depth += Drops[S].ByteD; // update phase

  000d5	8a 5e fa	 mov	 bl, BYTE PTR [esi-6]
  000d8	8a 16		 mov	 dl, BYTE PTR [esi]
  000da	02 da		 add	 bl, dl

; 3419 :             Depth = PhaseTable[ Drops[S].Depth ];

  000dc	0f b6 c3	 movzx	 eax, bl
  000df	88 5e fa	 mov	 BYTE PTR [esi-6], bl
  000e2	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]

; 3420 : 			if( Depth<128 ) Depth = 128; // clamp it

  000e8	3c 80		 cmp	 al, 128			; 00000080H
  000ea	73 02		 jae	 SHORT $L109314
  000ec	b0 80		 mov	 al, 128			; 00000080H
$L109314:

; 3421 :             WaveFieldA[ DropDest ]  =  Depth;

  000ee	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3422 :             WaveFieldB[ DropDest ]  =  Depth;

  000f1	88 04 39	 mov	 BYTE PTR [ecx+edi], al

; 3423 :             break;

  000f4	e9 a2 08 00 00	 jmp	 $L109301
$L109315:

; 3424 : 
; 3425 :         case DROP_ShallowSpot: // Phased II
; 3426 :        	    Drops[S].Depth += Drops[S].ByteD; // update phase

  000f9	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  000fc	8a 16		 mov	 dl, BYTE PTR [esi]
  000fe	02 c2		 add	 al, dl
  00100	88 46 fa	 mov	 BYTE PTR [esi-6], al

; 3427 :             Depth = 64+ (PhaseTable[ Drops[S].Depth ] >> 1) ;

  00103	0f b6 c0	 movzx	 eax, al
  00106	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[eax]
  0010c	d0 e8		 shr	 al, 1
  0010e	04 40		 add	 al, 64			; 00000040H

; 3428 :             WaveFieldA[ DropDest ]  =  Depth;

  00110	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3429 :             WaveFieldB[ DropDest ]  =  Depth;

  00113	88 04 39	 mov	 BYTE PTR [ecx+edi], al

; 3430 :             break;

  00116	e9 80 08 00 00	 jmp	 $L109301
$L109316:

; 3431 : 
; 3432 :         case DROP_RandomMover: // 'movers'
; 3433 :             Drops[S].X = U2Mask & (Xnow - (SpeedRand()&3) + (SpeedRand()&3) );

  0011b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00121	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00127	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0012d	83 c2 04	 add	 edx, 4
  00130	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00136	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0013c	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00142	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00148	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0014e	8a d8		 mov	 bl, al
  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00156	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0015c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00162	83 c2 04	 add	 edx, 4
  00165	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0016b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00171	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00177	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0017d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00183	8a 54 24 10	 mov	 dl, BYTE PTR _U2Mask$[esp+52]
  00187	24 03		 and	 al, 3
  00189	80 e3 03	 and	 bl, 3
  0018c	2a c3		 sub	 al, bl
  0018e	02 44 24 12	 add	 al, BYTE PTR _Xnow$109303[esp+52]
  00192	22 c2		 and	 al, dl
  00194	88 46 fb	 mov	 BYTE PTR [esi-5], al

; 3434 :             Drops[S].Y = V2Mask & (Ynow - (SpeedRand()&3) + (SpeedRand()&3) );

  00197	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0019d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  001a3	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  001a9	83 c2 04	 add	 edx, 4
  001ac	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  001b2	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  001b8	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  001be	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  001c4	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  001ca	8a d8		 mov	 bl, al
  001cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  001d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  001d8	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  001de	83 c2 04	 add	 edx, 4
  001e1	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  001e7	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  001ed	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  001f3	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  001f9	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  001ff	8a 54 24 13	 mov	 dl, BYTE PTR _Ynow$109304[esp+52]
  00203	8a 4c 24 11	 mov	 cl, BYTE PTR _V2Mask$[esp+52]
  00207	24 03		 and	 al, 3
  00209	80 e3 03	 and	 bl, 3
  0020c	2a c3		 sub	 al, bl
  0020e	02 c2		 add	 al, dl
  00210	22 c1		 and	 al, cl
  00212	88 46 fc	 mov	 BYTE PTR [esi-4], al

; 3435 :             WaveFieldA[ DropDest ]  =  128+57;

  00215	8b 44 24 20	 mov	 eax, DWORD PTR _DropDest$109305[esp+52]
  00219	c6 04 28 b9	 mov	 BYTE PTR [eax+ebp], 185	; 000000b9H

; 3436 :             WaveFieldB[ DropDest ]  =  128-57;

  0021d	c6 04 38 47	 mov	 BYTE PTR [eax+edi], 71	; 00000047H

; 3437 :             break;

  00221	e9 75 07 00 00	 jmp	 $L109301
$L109317:

; 3438 : 
; 3439 :         case DROP_FixedRandomSpot: // 'totally random'  fixed wavesource
; 3440 :             WaveFieldA[ DropDest ]  =  SpeedRand();

  00226	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0022c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00232	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00238	83 c2 04	 add	 edx, 4
  0023b	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00241	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00247	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0024d	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00253	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00259	8b 5c 24 20	 mov	 ebx, DWORD PTR _DropDest$109305[esp+52]
  0025d	88 04 2b	 mov	 BYTE PTR [ebx+ebp], al

; 3441 :             WaveFieldB[ DropDest ]  =  SpeedRand();

  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00266	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0026c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00272	83 c2 04	 add	 edx, 4
  00275	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0027b	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00281	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00287	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0028d	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00293	88 04 3b	 mov	 BYTE PTR [ebx+edi], al

; 3442 :             break;

  00296	e9 00 07 00 00	 jmp	 $L109301
$L109318:

; 3443 : 
; 3444 : 		
; 3445 : 		case DROP_WhirlyThing: // Circular stirring.
; 3446 : 			{
; 3447 : 				DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3448 : 					  Phase16=0xFFFF & ( Phase16 + ((DWORD)Drops[S].ByteD << 8) + (DWORD)Drops[S].ByteC );

  0029b	0f b6 46 fe	 movzx	 eax, BYTE PTR [esi-2]
  0029f	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  002a2	03 c1		 add	 eax, ecx
  002a4	0f b6 4e ff	 movzx	 ecx, BYTE PTR [esi-1]
  002a8	c1 e0 08	 shl	 eax, 8
  002ab	03 c1		 add	 eax, ecx
  002ad	0f b6 4e fd	 movzx	 ecx, BYTE PTR [esi-3]
  002b1	03 c1		 add	 eax, ecx
  002b3	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 3449 : 
; 3450 : 				Drops[S].ByteA =    Phase16 & 0xFF;

  002b8	88 46 fd	 mov	 BYTE PTR [esi-3], al

; 3451 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;

  002bb	c1 e8 08	 shr	 eax, 8

; 3452 : 
; 3453 : 				// So real 16-bit phase is B:A, delta= D:C
; 3454 : 
; 3455 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB ] >>4));

  002be	33 c9		 xor	 ecx, ecx
  002c0	8a c8		 mov	 cl, al
  002c2	88 46 fe	 mov	 BYTE PTR [esi-2], al
  002c5	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _PhaseTable[ecx]
  002cc	c1 e8 04	 shr	 eax, 4
  002cf	03 c3		 add	 eax, ebx
  002d1	0f b6 5c 24 10	 movzx	 ebx, BYTE PTR _U2Mask$[esp+52]
  002d6	23 c3		 and	 eax, ebx

; 3456 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255 ]>>4)) ) << UBits;

  002d8	83 c1 40	 add	 ecx, 64			; 00000040H
  002db	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  002e1	0f b6 99 00 00
	00 00		 movzx	 ebx, BYTE PTR _PhaseTable[ecx]
  002e8	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  002ec	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  002ef	c1 eb 04	 shr	 ebx, 4
  002f2	03 da		 add	 ebx, edx
  002f4	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  002f9	23 da		 and	 ebx, edx

; 3457 : 				WaveFieldA[ AddDestX + AddDestY ] = Drops[S].Depth;

  002fb	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]
  002fe	d3 e3		 shl	 ebx, cl
  00300	03 d8		 add	 ebx, eax
  00302	88 14 2b	 mov	 BYTE PTR [ebx+ebp], dl

; 3458 : 				WaveFieldB[ AddDestX + AddDestY ] = Drops[S].Depth;

  00305	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00308	88 04 3b	 mov	 BYTE PTR [ebx+edi], al

; 3459 :             }
; 3460 : 			break;

  0030b	e9 8b 06 00 00	 jmp	 $L109301
$L109326:

; 3461 : 
; 3462 : 		case DROP_WhirlyBack: // Circular stirring.
; 3463 : 			{
; 3464 : 				DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3465 : 					  Phase16=0xFFFF & ( Phase16 - ((DWORD)Drops[S].ByteD << 8) - (DWORD)Drops[S].ByteC );

  00310	0f b6 46 fe	 movzx	 eax, BYTE PTR [esi-2]
  00314	0f b6 4e ff	 movzx	 ecx, BYTE PTR [esi-1]
  00318	c1 e0 08	 shl	 eax, 8
  0031b	2b c1		 sub	 eax, ecx
  0031d	33 c9		 xor	 ecx, ecx
  0031f	8a 2e		 mov	 ch, BYTE PTR [esi]
  00321	2b c1		 sub	 eax, ecx
  00323	0f b6 4e fd	 movzx	 ecx, BYTE PTR [esi-3]
  00327	03 c1		 add	 eax, ecx
  00329	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 3466 : 
; 3467 : 				Drops[S].ByteA =    Phase16 & 0xFF;

  0032e	88 46 fd	 mov	 BYTE PTR [esi-3], al

; 3468 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;

  00331	c1 e8 08	 shr	 eax, 8

; 3469 : 
; 3470 : 				// So real 16-bit phase is B:A, delta= D:C
; 3471 : 
; 3472 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB ] >>4));

  00334	33 c9		 xor	 ecx, ecx
  00336	8a c8		 mov	 cl, al
  00338	88 46 fe	 mov	 BYTE PTR [esi-2], al
  0033b	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _PhaseTable[ecx]
  00342	c1 e8 04	 shr	 eax, 4
  00345	03 c3		 add	 eax, ebx
  00347	0f b6 5c 24 10	 movzx	 ebx, BYTE PTR _U2Mask$[esp+52]
  0034c	23 c3		 and	 eax, ebx

; 3473 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255 ]>>4)) ) << UBits;

  0034e	83 c1 40	 add	 ecx, 64			; 00000040H
  00351	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00357	0f b6 99 00 00
	00 00		 movzx	 ebx, BYTE PTR _PhaseTable[ecx]
  0035e	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  00362	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00365	c1 eb 04	 shr	 ebx, 4
  00368	03 da		 add	 ebx, edx
  0036a	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  0036f	23 da		 and	 ebx, edx

; 3474 : 				WaveFieldA[ AddDestX + AddDestY ] = Drops[S].Depth;

  00371	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]
  00374	d3 e3		 shl	 ebx, cl
  00376	03 d8		 add	 ebx, eax
  00378	88 14 2b	 mov	 BYTE PTR [ebx+ebp], dl

; 3475 : 				WaveFieldB[ AddDestX + AddDestY ] = Drops[S].Depth;

  0037b	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  0037e	88 04 3b	 mov	 BYTE PTR [ebx+edi], al

; 3476 :             }
; 3477 : 			break;

  00381	e9 15 06 00 00	 jmp	 $L109301
$L109334:

; 3478 : 
; 3479 : 		case DROP_BigWhirly: // Simple single-direction mover.  
; 3480 : 			{
; 3481 : 				DWORD Phase16 = ( *(DWORD*)&(Drops[S].ByteA) );
; 3482 : 				      Phase16=0xFFFF & ( Phase16 + *(_WORD*)&(Drops[S].ByteC) );

  00386	8b 4e fd	 mov	 ecx, DWORD PTR [esi-3]
  00389	33 c0		 xor	 eax, eax
  0038b	66 8b 46 ff	 mov	 ax, WORD PTR [esi-1]
  0038f	03 c1		 add	 eax, ecx
  00391	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 3483 : 
; 3484 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;

  00396	8b c8		 mov	 ecx, eax
  00398	c1 e9 08	 shr	 ecx, 8
  0039b	88 4e fe	 mov	 BYTE PTR [esi-2], cl

; 3485 : 				Drops[S].ByteA =    Phase16 & 0xFF;

  0039e	88 46 fd	 mov	 BYTE PTR [esi-3], al

; 3486 : 
; 3487 : 				// So real 16-bit phase is B:A, delta= D.
; 3488 : 
; 3489 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB] >>3) ) ;

  003a1	0f b6 c9	 movzx	 ecx, cl
  003a4	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _PhaseTable[ecx]
  003ab	c1 e8 03	 shr	 eax, 3
  003ae	03 c3		 add	 eax, ebx
  003b0	0f b6 5c 24 10	 movzx	 ebx, BYTE PTR _U2Mask$[esp+52]

; 3490 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255] >>3) ) ) << UBits ;

  003b5	83 c1 40	 add	 ecx, 64			; 00000040H
  003b8	23 c3		 and	 eax, ebx
  003ba	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  003c0	0f b6 99 00 00
	00 00		 movzx	 ebx, BYTE PTR _PhaseTable[ecx]
  003c7	0f b6 4c 24 11	 movzx	 ecx, BYTE PTR _V2Mask$[esp+52]
  003cc	c1 eb 03	 shr	 ebx, 3
  003cf	03 da		 add	 ebx, edx
  003d1	8b 54 24 14	 mov	 edx, DWORD PTR _this$[esp+52]
  003d5	23 d9		 and	 ebx, ecx
  003d7	8a 4a 30	 mov	 cl, BYTE PTR [edx+48]
  003da	d3 e3		 shl	 ebx, cl

; 3491 : 				WaveFieldA[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  003dc	03 d8		 add	 ebx, eax
  003de	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  003e1	88 04 2b	 mov	 BYTE PTR [ebx+ebp], al

; 3492 : 				WaveFieldB[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  003e4	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  003e7	88 0c 3b	 mov	 BYTE PTR [ebx+edi], cl

; 3493 :             }
; 3494 : 			break;

  003ea	e9 ac 05 00 00	 jmp	 $L109301
$L109340:

; 3495 : 
; 3496 : 		case DROP_BigWhirlyBack: // Simple single-direction mover.  
; 3497 : 			{
; 3498 : 				DWORD Phase16 = ((DWORD)Drops[S].ByteB << 8) + (DWORD)Drops[S].ByteA;
; 3499 : 				      Phase16=0xFFFF & ( Phase16 - ((DWORD)Drops[S].ByteD << 8) - (DWORD)Drops[S].ByteC );

  003ef	0f b6 46 fe	 movzx	 eax, BYTE PTR [esi-2]
  003f3	0f b6 4e ff	 movzx	 ecx, BYTE PTR [esi-1]
  003f7	c1 e0 08	 shl	 eax, 8
  003fa	2b c1		 sub	 eax, ecx
  003fc	33 c9		 xor	 ecx, ecx
  003fe	8a 2e		 mov	 ch, BYTE PTR [esi]
  00400	2b c1		 sub	 eax, ecx
  00402	0f b6 4e fd	 movzx	 ecx, BYTE PTR [esi-3]
  00406	03 c1		 add	 eax, ecx
  00408	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 3500 : 
; 3501 : 				Drops[S].ByteB =  ( Phase16 >> 8 ) & 0xFF;

  0040d	8b c8		 mov	 ecx, eax
  0040f	c1 e9 08	 shr	 ecx, 8
  00412	88 4e fe	 mov	 BYTE PTR [esi-2], cl

; 3502 : 				Drops[S].ByteA =    Phase16 & 0xFF;

  00415	88 46 fd	 mov	 BYTE PTR [esi-3], al

; 3503 : 
; 3504 : 				// So real 16-bit phase is B:A, delta= D.
; 3505 : 
; 3506 : 				DWORD AddDestX =    U2Mask & (Xnow + (PhaseTable[ Drops[S].ByteB] >>3) ) ;

  00418	0f b6 c9	 movzx	 ecx, cl
  0041b	0f b6 81 00 00
	00 00		 movzx	 eax, BYTE PTR _PhaseTable[ecx]
  00422	c1 e8 03	 shr	 eax, 3
  00425	03 c3		 add	 eax, ebx
  00427	0f b6 5c 24 10	 movzx	 ebx, BYTE PTR _U2Mask$[esp+52]
  0042c	23 c3		 and	 eax, ebx

; 3507 : 				DWORD AddDestY = (  V2Mask & (Ynow + (PhaseTable[(Drops[S].ByteB+64) & 255] >>3) ) ) << UBits ;

  0042e	83 c1 40	 add	 ecx, 64			; 00000040H
  00431	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00437	0f b6 99 00 00
	00 00		 movzx	 ebx, BYTE PTR _PhaseTable[ecx]
  0043e	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  00442	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00445	c1 eb 03	 shr	 ebx, 3
  00448	03 da		 add	 ebx, edx
  0044a	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  0044f	23 da		 and	 ebx, edx

; 3508 : 				WaveFieldA[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  00451	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]
  00454	d3 e3		 shl	 ebx, cl
  00456	03 d8		 add	 ebx, eax
  00458	88 14 2b	 mov	 BYTE PTR [ebx+ebp], dl

; 3509 : 				WaveFieldB[ AddDestX + AddDestY ]  =  Drops[S].Depth;

  0045b	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  0045e	88 04 3b	 mov	 BYTE PTR [ebx+edi], al

; 3510 :             }
; 3511 : 			break;

  00461	e9 35 05 00 00	 jmp	 $L109301
$L109348:

; 3512 : 
; 3513 :         case DROP_HorizontalLine: //  Horizontal linesegment.
; 3514 : 			{
; 3515 : 				Depth = Drops[S].Depth;
; 3516 : 				SegSize = Drops[S].ByteD >> 1;

  00466	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00469	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  0046c	d1 e8		 shr	 eax, 1

; 3517 : 				DWORD DropDestX0 = (DWORD)  ( Ynow << UBits ); 
; 3518 : 				for( t=0; t<=SegSize; t++ )

  0046e	85 c0		 test	 eax, eax
  00470	0f 8c 25 05 00
	00		 jl	 $L109301
  00476	8b 54 24 1c	 mov	 edx, DWORD PTR -24+[esp+52]
  0047a	03 d5		 add	 edx, ebp
  0047c	89 54 24 28	 mov	 DWORD PTR -12+[esp+52], edx
  00480	8b 54 24 1c	 mov	 edx, DWORD PTR -24+[esp+52]
  00484	03 d7		 add	 edx, edi
  00486	40		 inc	 eax
  00487	89 54 24 24	 mov	 DWORD PTR -16+[esp+52], edx
  0048b	89 44 24 20	 mov	 DWORD PTR -20+[esp+52], eax

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  0048f	90		 npad	 1

; 3517 : 				DWORD DropDestX0 = (DWORD)  ( Ynow << UBits ); 
; 3518 : 				for( t=0; t<=SegSize; t++ )

$L109351:

; 3519 : 				{
; 3520 : 					DWORD AddDestX = (DWORD) ((t+Xnow) & U2Mask);

  00490	0f b6 44 24 10	 movzx	 eax, BYTE PTR _U2Mask$[esp+52]

; 3521 : 					WaveFieldA[ DropDestX0 + AddDestX ] = Depth;

  00495	8b 54 24 28	 mov	 edx, DWORD PTR -12+[esp+52]
  00499	23 c3		 and	 eax, ebx
  0049b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 3522 : 					WaveFieldB[ DropDestX0 + AddDestX ] = Depth;

  0049e	8b 54 24 24	 mov	 edx, DWORD PTR -16+[esp+52]
  004a2	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  004a5	8b 44 24 20	 mov	 eax, DWORD PTR -20+[esp+52]
  004a9	43		 inc	 ebx
  004aa	48		 dec	 eax
  004ab	89 44 24 20	 mov	 DWORD PTR -20+[esp+52], eax
  004af	75 df		 jne	 SHORT $L109351

; 3523 : 				}
; 3524 : 			}
; 3525 :             break;

  004b1	e9 e5 04 00 00	 jmp	 $L109301
$L109356:

; 3526 : 
; 3527 :         case DROP_VerticalLine: //  Vertical linesegment.
; 3528 :             Depth = Drops[S].Depth;
; 3529 :             SegSize = Drops[S].ByteD >> 1;

  004b6	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  004b9	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  004bc	d1 e9		 shr	 ecx, 1

; 3530 :             for( t=0; t<=SegSize; t++ )

  004be	85 c9		 test	 ecx, ecx
  004c0	89 4c 24 18	 mov	 DWORD PTR _SegSize$[esp+52], ecx
  004c4	0f 8c d1 04 00
	00		 jl	 $L109301
  004ca	8d 0c 2b	 lea	 ecx, DWORD PTR [ebx+ebp]
  004cd	03 df		 add	 ebx, edi
  004cf	89 5c 24 20	 mov	 DWORD PTR -20+[esp+52], ebx
  004d3	8b da		 mov	 ebx, edx
  004d5	8b 54 24 18	 mov	 edx, DWORD PTR _SegSize$[esp+52]
  004d9	42		 inc	 edx
  004da	89 4c 24 1c	 mov	 DWORD PTR -24+[esp+52], ecx
  004de	89 54 24 18	 mov	 DWORD PTR -28+[esp+52], edx
$L109357:

; 3531 :             {
; 3532 :                 DWORD AddDestY =  (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  004e2	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  004e7	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  004eb	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  004ee	23 d3		 and	 edx, ebx
  004f0	d3 e2		 shl	 edx, cl

; 3533 :                 WaveFieldA[Xnow + AddDestY] = Depth;

  004f2	8b 4c 24 1c	 mov	 ecx, DWORD PTR -24+[esp+52]
  004f6	43		 inc	 ebx
  004f7	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3534 :                 WaveFieldB[Xnow + AddDestY] = Depth;

  004fa	8b 4c 24 20	 mov	 ecx, DWORD PTR -20+[esp+52]
  004fe	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00501	ff 4c 24 18	 dec	 DWORD PTR -28+[esp+52]
  00505	75 db		 jne	 SHORT $L109357

; 3535 : 				
; 3536 :             }
; 3537 :             break;

  00507	e9 8f 04 00 00	 jmp	 $L109301
$L109362:

; 3538 : 
; 3539 :         case DROP_DiagonalLine1: //  diagonal (slash)
; 3540 :             Depth = Drops[S].Depth;

  0050c	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  0050f	88 44 24 12	 mov	 BYTE PTR _Depth$[esp+52], al

; 3541 :             SegSize = Drops[S].ByteD >> 1;

  00513	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  00516	d1 e8		 shr	 eax, 1

; 3542 :             for( t=0; t<=SegSize; t++ )

  00518	85 c0		 test	 eax, eax
  0051a	89 44 24 18	 mov	 DWORD PTR _SegSize$[esp+52], eax
  0051e	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _t$[esp+52], 0
  00526	0f 8c 6f 04 00
	00		 jl	 $L109301

; 3538 : 
; 3539 :         case DROP_DiagonalLine1: //  diagonal (slash)
; 3540 :             Depth = Drops[S].Depth;

  0052c	89 54 24 20	 mov	 DWORD PTR -20+[esp+52], edx
$L109363:

; 3543 :             {
; 3544 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  00530	0f b6 44 24 11	 movzx	 eax, BYTE PTR _V2Mask$[esp+52]
  00535	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  00539	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0053c	23 c2		 and	 eax, edx

; 3545 :                 DWORD AddDestX = (DWORD) (  (Xnow-t) & U2Mask);

  0053e	8b 54 24 1c	 mov	 edx, DWORD PTR _t$[esp+52]
  00542	d3 e0		 shl	 eax, cl
  00544	8b cb		 mov	 ecx, ebx
  00546	2b ca		 sub	 ecx, edx
  00548	0f b6 54 24 10	 movzx	 edx, BYTE PTR _U2Mask$[esp+52]
  0054d	23 ca		 and	 ecx, edx
  0054f	8b 54 24 20	 mov	 edx, DWORD PTR -20+[esp+52]

; 3546 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  00553	03 c1		 add	 eax, ecx
  00555	8a 4c 24 12	 mov	 cl, BYTE PTR _Depth$[esp+52]
  00559	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl

; 3547 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  0055c	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
  0055f	8b 44 24 1c	 mov	 eax, DWORD PTR _t$[esp+52]
  00563	8b 4c 24 18	 mov	 ecx, DWORD PTR _SegSize$[esp+52]
  00567	40		 inc	 eax
  00568	42		 inc	 edx
  00569	3b c1		 cmp	 eax, ecx
  0056b	89 44 24 1c	 mov	 DWORD PTR _t$[esp+52], eax
  0056f	89 54 24 20	 mov	 DWORD PTR -20+[esp+52], edx
  00573	7e bb		 jle	 SHORT $L109363

; 3548 :             }
; 3549 :             break;

  00575	e9 21 04 00 00	 jmp	 $L109301
$L109370:

; 3550 : 
; 3551 : 
; 3552 :         case DROP_DiagonalLine2: //  diagonal (backslash)
; 3553 :             Depth = Drops[S].Depth;
; 3554 :             SegSize = Drops[S].ByteD >> 1;

  0057a	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  0057d	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00580	d1 e9		 shr	 ecx, 1

; 3555 :             for( t=0; t<=SegSize; t++ )

  00582	85 c9		 test	 ecx, ecx
  00584	88 44 24 12	 mov	 BYTE PTR _Depth$[esp+52], al
  00588	0f 8c 0d 04 00
	00		 jl	 $L109301
  0058e	41		 inc	 ecx
  0058f	8b c3		 mov	 eax, ebx
  00591	8b da		 mov	 ebx, edx
  00593	89 4c 24 20	 mov	 DWORD PTR -20+[esp+52], ecx
$L109371:

; 3556 :             {
; 3557 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  00597	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  0059c	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  005a0	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  005a3	23 d3		 and	 edx, ebx
  005a5	d3 e2		 shl	 edx, cl

; 3558 :                 DWORD AddDestX = (DWORD) (  (Xnow+t) & U2Mask);

  005a7	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR _U2Mask$[esp+52]
  005ac	23 c8		 and	 ecx, eax

; 3559 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  005ae	03 d1		 add	 edx, ecx
  005b0	8a 4c 24 12	 mov	 cl, BYTE PTR _Depth$[esp+52]
  005b4	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl

; 3560 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  005b7	88 0c 3a	 mov	 BYTE PTR [edx+edi], cl
  005ba	8b 4c 24 20	 mov	 ecx, DWORD PTR -20+[esp+52]
  005be	43		 inc	 ebx
  005bf	40		 inc	 eax
  005c0	49		 dec	 ecx
  005c1	89 4c 24 20	 mov	 DWORD PTR -20+[esp+52], ecx
  005c5	75 d0		 jne	 SHORT $L109371

; 3561 :             }
; 3562 :             break;

  005c7	e9 cf 03 00 00	 jmp	 $L109301
$L109378:

; 3563 : 
; 3564 : 
; 3565 :         case DROP_HorizontalOsc: //  Horizontal linesegment.
; 3566 : 			{
; 3567 :        			Drops[S].Depth += Drops[S].ByteC; // update phase

  005cc	8a 46 ff	 mov	 al, BYTE PTR [esi-1]
  005cf	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  005d2	02 c8		 add	 cl, al
  005d4	88 4e fa	 mov	 BYTE PTR [esi-6], cl

; 3568 : 				Depth = PhaseTable[ Drops[S].Depth ];

  005d7	0f b6 c9	 movzx	 ecx, cl
  005da	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[ecx]

; 3569 : 				SegSize = Drops[S].ByteD >> 1;
; 3570 : 				DWORD DropDestX0 = (DWORD)  ( Ynow << UBits ); 

  005e0	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  005e4	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  005e7	88 44 24 12	 mov	 BYTE PTR _Depth$[esp+52], al
  005eb	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  005ee	d1 e8		 shr	 eax, 1
  005f0	d3 e2		 shl	 edx, cl

; 3571 : 				for( t=0; t<=SegSize; t++ )

  005f2	85 c0		 test	 eax, eax
  005f4	0f 8c a1 03 00
	00		 jl	 $L109301
  005fa	8d 0c 2a	 lea	 ecx, DWORD PTR [edx+ebp]
  005fd	03 d7		 add	 edx, edi
  005ff	40		 inc	 eax
  00600	89 4c 24 28	 mov	 DWORD PTR -12+[esp+52], ecx
  00604	89 54 24 24	 mov	 DWORD PTR -16+[esp+52], edx
  00608	89 44 24 20	 mov	 DWORD PTR -20+[esp+52], eax

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  0060c	8d 64 24 00	 npad	 4

; 3571 : 				for( t=0; t<=SegSize; t++ )

$L109381:

; 3572 : 				{
; 3573 : 					DWORD AddDestX = (DWORD) ((t+Xnow) & U2Mask);

  00610	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR _U2Mask$[esp+52]

; 3574 : 					WaveFieldA[ DropDestX0 + AddDestX ] = Depth;

  00615	8a 44 24 12	 mov	 al, BYTE PTR _Depth$[esp+52]
  00619	8b 54 24 28	 mov	 edx, DWORD PTR -12+[esp+52]
  0061d	23 cb		 and	 ecx, ebx
  0061f	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3575 : 					WaveFieldB[ DropDestX0 + AddDestX ] = Depth;

  00622	8b 54 24 24	 mov	 edx, DWORD PTR -16+[esp+52]
  00626	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00629	8b 44 24 20	 mov	 eax, DWORD PTR -20+[esp+52]
  0062d	43		 inc	 ebx
  0062e	48		 dec	 eax
  0062f	89 44 24 20	 mov	 DWORD PTR -20+[esp+52], eax
  00633	75 db		 jne	 SHORT $L109381

; 3576 : 				}
; 3577 : 			}
; 3578 :             break;

  00635	e9 61 03 00 00	 jmp	 $L109301
$L109386:

; 3579 : 
; 3580 : 
; 3581 :         case DROP_VerticalOsc: //  Vertical linesegment.
; 3582 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  0063a	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  0063d	8a 46 ff	 mov	 al, BYTE PTR [esi-1]
  00640	02 c8		 add	 cl, al
  00642	88 4e fa	 mov	 BYTE PTR [esi-6], cl

; 3583 :             Depth = PhaseTable[ Drops[S].Depth ];

  00645	0f b6 c9	 movzx	 ecx, cl
  00648	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[ecx]

; 3584 :             SegSize = Drops[S].ByteD >> 1;

  0064e	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  00651	d1 e9		 shr	 ecx, 1

; 3585 :             for( t=0; t<=SegSize; t++ )

  00653	85 c9		 test	 ecx, ecx
  00655	89 4c 24 18	 mov	 DWORD PTR _SegSize$[esp+52], ecx
  00659	0f 8c 3c 03 00
	00		 jl	 $L109301
  0065f	8d 0c 2b	 lea	 ecx, DWORD PTR [ebx+ebp]
  00662	03 df		 add	 ebx, edi
  00664	89 5c 24 20	 mov	 DWORD PTR -20+[esp+52], ebx
  00668	8b da		 mov	 ebx, edx
  0066a	8b 54 24 18	 mov	 edx, DWORD PTR _SegSize$[esp+52]
  0066e	42		 inc	 edx
  0066f	89 4c 24 1c	 mov	 DWORD PTR -24+[esp+52], ecx
  00673	89 54 24 18	 mov	 DWORD PTR -28+[esp+52], edx
$L109387:

; 3586 :             {
; 3587 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t)& V2Mask) << UBits );

  00677	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  0067c	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  00680	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00683	23 d3		 and	 edx, ebx
  00685	d3 e2		 shl	 edx, cl

; 3588 :                 WaveFieldA[Xnow + AddDestY] = Depth;

  00687	8b 4c 24 1c	 mov	 ecx, DWORD PTR -24+[esp+52]
  0068b	43		 inc	 ebx
  0068c	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3589 :                 WaveFieldB[Xnow + AddDestY] = Depth;

  0068f	8b 4c 24 20	 mov	 ecx, DWORD PTR -20+[esp+52]
  00693	88 04 11	 mov	 BYTE PTR [ecx+edx], al
  00696	ff 4c 24 18	 dec	 DWORD PTR -28+[esp+52]
  0069a	75 db		 jne	 SHORT $L109387

; 3590 :             }
; 3591 :             break;

  0069c	e9 fa 02 00 00	 jmp	 $L109301
$L109392:

; 3592 : 
; 3593 : 
; 3594 :         case DROP_DiagonalOsc1: //  diagonal (slash)
; 3595 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  006a1	8a 46 ff	 mov	 al, BYTE PTR [esi-1]
  006a4	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  006a7	02 c8		 add	 cl, al
  006a9	88 4e fa	 mov	 BYTE PTR [esi-6], cl

; 3596 :             Depth = PhaseTable[ Drops[S].Depth ];

  006ac	0f b6 c9	 movzx	 ecx, cl
  006af	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[ecx]
  006b5	88 44 24 12	 mov	 BYTE PTR _Depth$[esp+52], al

; 3597 :             SegSize = Drops[S].ByteD >> 1;

  006b9	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  006bc	d1 e8		 shr	 eax, 1

; 3598 :             for( t=0; t<=SegSize; t++ )

  006be	85 c0		 test	 eax, eax
  006c0	89 44 24 18	 mov	 DWORD PTR _SegSize$[esp+52], eax
  006c4	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _t$[esp+52], 0
  006cc	0f 8c c9 02 00
	00		 jl	 $L109301

; 3592 : 
; 3593 : 
; 3594 :         case DROP_DiagonalOsc1: //  diagonal (slash)
; 3595 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  006d2	89 54 24 20	 mov	 DWORD PTR -20+[esp+52], edx
$L109393:

; 3599 :             {
; 3600 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  006d6	0f b6 44 24 11	 movzx	 eax, BYTE PTR _V2Mask$[esp+52]
  006db	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  006df	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  006e2	23 c2		 and	 eax, edx

; 3601 :                 DWORD AddDestX = (DWORD) (  (Xnow-t) & U2Mask);

  006e4	8b 54 24 1c	 mov	 edx, DWORD PTR _t$[esp+52]
  006e8	d3 e0		 shl	 eax, cl
  006ea	8b cb		 mov	 ecx, ebx
  006ec	2b ca		 sub	 ecx, edx
  006ee	0f b6 54 24 10	 movzx	 edx, BYTE PTR _U2Mask$[esp+52]
  006f3	23 ca		 and	 ecx, edx
  006f5	8b 54 24 20	 mov	 edx, DWORD PTR -20+[esp+52]

; 3602 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  006f9	03 c1		 add	 eax, ecx
  006fb	8a 4c 24 12	 mov	 cl, BYTE PTR _Depth$[esp+52]
  006ff	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl

; 3603 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  00702	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
  00705	8b 44 24 1c	 mov	 eax, DWORD PTR _t$[esp+52]
  00709	8b 4c 24 18	 mov	 ecx, DWORD PTR _SegSize$[esp+52]
  0070d	40		 inc	 eax
  0070e	42		 inc	 edx
  0070f	3b c1		 cmp	 eax, ecx
  00711	89 44 24 1c	 mov	 DWORD PTR _t$[esp+52], eax
  00715	89 54 24 20	 mov	 DWORD PTR -20+[esp+52], edx
  00719	7e bb		 jle	 SHORT $L109393

; 3604 :             }
; 3605 :             break;

  0071b	e9 7b 02 00 00	 jmp	 $L109301
$L109400:

; 3606 : 
; 3607 : 
; 3608 :         case DROP_DiagonalOsc2: //  diagonal (backslash)
; 3609 :        	    Drops[S].Depth += Drops[S].ByteC; // update phase

  00720	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  00723	8a 46 ff	 mov	 al, BYTE PTR [esi-1]
  00726	02 c8		 add	 cl, al
  00728	88 4e fa	 mov	 BYTE PTR [esi-6], cl

; 3610 :             Depth = PhaseTable[ Drops[S].Depth ];

  0072b	0f b6 c9	 movzx	 ecx, cl
  0072e	8a 81 00 00 00
	00		 mov	 al, BYTE PTR _PhaseTable[ecx]

; 3611 :             SegSize = Drops[S].ByteD >> 1;

  00734	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  00737	d1 e9		 shr	 ecx, 1

; 3612 :             for( t=0; t<=SegSize; t++ )

  00739	85 c9		 test	 ecx, ecx
  0073b	88 44 24 12	 mov	 BYTE PTR _Depth$[esp+52], al
  0073f	0f 8c 56 02 00
	00		 jl	 $L109301
  00745	41		 inc	 ecx
  00746	8b c3		 mov	 eax, ebx
  00748	8b da		 mov	 ebx, edx
  0074a	89 4c 24 20	 mov	 DWORD PTR -20+[esp+52], ecx

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  0074e	8b ff		 npad	 2

; 3612 :             for( t=0; t<=SegSize; t++ )

$L109401:

; 3613 :             {
; 3614 :                 DWORD AddDestY = (DWORD) ( ((Ynow+t) & V2Mask) << UBits );

  00750	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  00755	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  00759	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0075c	23 d3		 and	 edx, ebx
  0075e	d3 e2		 shl	 edx, cl

; 3615 :                 DWORD AddDestX = (DWORD) (  (Xnow+t) & U2Mask);

  00760	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR _U2Mask$[esp+52]
  00765	23 c8		 and	 ecx, eax

; 3616 :                 WaveFieldA[ AddDestY + AddDestX] = Depth;

  00767	03 d1		 add	 edx, ecx
  00769	8a 4c 24 12	 mov	 cl, BYTE PTR _Depth$[esp+52]
  0076d	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl

; 3617 :                 WaveFieldB[ AddDestY + AddDestX] = Depth;

  00770	88 0c 3a	 mov	 BYTE PTR [edx+edi], cl
  00773	8b 4c 24 20	 mov	 ecx, DWORD PTR -20+[esp+52]
  00777	43		 inc	 ebx
  00778	40		 inc	 eax
  00779	49		 dec	 ecx
  0077a	89 4c 24 20	 mov	 DWORD PTR -20+[esp+52], ecx
  0077e	75 d0		 jne	 SHORT $L109401

; 3618 :             }
; 3619 :             break;

  00780	e9 16 02 00 00	 jmp	 $L109301
$L109408:

; 3620 : 
; 3621 :         
; 3622 : 		case DROP_AreaClamp: // Fixed-depth/adaptive-depth rect areas.
; 3623 : 			{
; 3624 : 				Depth   = Drops[S].Depth;

  00785	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00788	88 44 24 12	 mov	 BYTE PTR _Depth$[esp+52], al

; 3625 : 				SegSize = Drops[S].ByteD >> 1;

  0078c	0f b6 06	 movzx	 eax, BYTE PTR [esi]
  0078f	d1 e8		 shr	 eax, 1

; 3626 : 
; 3627 : 				DWORD DestY = (DWORD) ( ((Ynow) & V2Mask) << UBits );
; 3628 : 
; 3629 : 				for( INT v=0; v<SegSize; v++ )

  00791	85 c0		 test	 eax, eax
  00793	89 44 24 18	 mov	 DWORD PTR _SegSize$[esp+52], eax
  00797	0f 8e fe 01 00
	00		 jle	 $L109301
  0079d	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR _U2Mask$[esp+52]
  007a2	23 cb		 and	 ecx, ebx
  007a4	89 4c 24 30	 mov	 DWORD PTR -4+[esp+52], ecx
  007a8	89 54 24 20	 mov	 DWORD PTR -20+[esp+52], edx
  007ac	89 44 24 28	 mov	 DWORD PTR -12+[esp+52], eax
$L109412:

; 3630 : 				{
; 3631 : 					DestY = (DWORD) ( (( Ynow+v ) & V2Mask) << UBits );

  007b0	0f b6 54 24 11	 movzx	 edx, BYTE PTR _V2Mask$[esp+52]
  007b5	23 54 24 20	 and	 edx, DWORD PTR -20+[esp+52]
  007b9	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  007bd	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  007c0	d3 e2		 shl	 edx, cl

; 3632 : 					DWORD Dest  = DestY + ( Xnow & U2Mask );

  007c2	8b 4c 24 30	 mov	 ecx, DWORD PTR -4+[esp+52]
  007c6	03 ca		 add	 ecx, edx

; 3633 : 
; 3634 :   					for( INT u = 1; u<=SegSize; u++ )

  007c8	83 f8 01	 cmp	 eax, 1
  007cb	7c 3b		 jl	 SHORT $L109413
  007cd	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  007d0	89 44 24 1c	 mov	 DWORD PTR -24+[esp+52], eax
  007d4	8b 44 24 18	 mov	 eax, DWORD PTR _SegSize$[esp+52]
  007d8	89 44 24 24	 mov	 DWORD PTR -16+[esp+52], eax

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  007dc	8d 64 24 00	 npad	 4

; 3633 : 
; 3634 :   					for( INT u = 1; u<=SegSize; u++ )

$L109418:

; 3635 : 					{
; 3636 : 						WaveFieldA[ Dest] = Depth;

  007e0	8a 44 24 12	 mov	 al, BYTE PTR _Depth$[esp+52]
  007e4	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3637 : 						WaveFieldB[ Dest] = Depth;

  007e7	88 04 39	 mov	 BYTE PTR [ecx+edi], al

; 3638 : 						Dest = DestY + ((DWORD) (u+Xnow) & U2Mask);

  007ea	0f b6 44 24 10	 movzx	 eax, BYTE PTR _U2Mask$[esp+52]
  007ef	8b c8		 mov	 ecx, eax
  007f1	8b 44 24 1c	 mov	 eax, DWORD PTR -24+[esp+52]
  007f5	23 c8		 and	 ecx, eax
  007f7	03 ca		 add	 ecx, edx
  007f9	40		 inc	 eax
  007fa	89 44 24 1c	 mov	 DWORD PTR -24+[esp+52], eax
  007fe	ff 4c 24 24	 dec	 DWORD PTR -16+[esp+52]
  00802	75 dc		 jne	 SHORT $L109418

; 3633 : 
; 3634 :   					for( INT u = 1; u<=SegSize; u++ )

  00804	8b 44 24 18	 mov	 eax, DWORD PTR _SegSize$[esp+52]
$L109413:

; 3626 : 
; 3627 : 				DWORD DestY = (DWORD) ( ((Ynow) & V2Mask) << UBits );
; 3628 : 
; 3629 : 				for( INT v=0; v<SegSize; v++ )

  00808	8b 54 24 20	 mov	 edx, DWORD PTR -20+[esp+52]
  0080c	8b 4c 24 28	 mov	 ecx, DWORD PTR -12+[esp+52]
  00810	42		 inc	 edx
  00811	49		 dec	 ecx
  00812	89 54 24 20	 mov	 DWORD PTR -20+[esp+52], edx
  00816	89 4c 24 28	 mov	 DWORD PTR -12+[esp+52], ecx
  0081a	75 94		 jne	 SHORT $L109412

; 3639 : 					}
; 3640 : 				}
; 3641 : 			}
; 3642 : 			break; 

  0081c	e9 7a 01 00 00	 jmp	 $L109301
$L109422:

; 3643 :        
; 3644 : 
; 3645 : 		case DROP_RainDrops: //  Rain drizzle.
; 3646 : 			{
; 3647 : 				// Keep the action sparse - just draw more sparks if needed...
; 3648 : 				if( (SpeedRand()&15)==0 )

  00821	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00827	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0082d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00833	83 c2 04	 add	 edx, 4
  00836	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0083c	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00842	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00848	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  0084e	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00854	a8 0f		 test	 al, 15			; 0000000fH
  00856	0f 85 3f 01 00
	00		 jne	 $L109301

; 3649 : 				{
; 3650 : 					Depth = Drops[S].Depth;

  0085c	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]

; 3651 : 					BYTE  Spray = Drops[S].ByteD;

  0085f	8a 06		 mov	 al, BYTE PTR [esi]
  00861	88 54 24 12	 mov	 BYTE PTR _Depth$[esp+52], dl
  00865	88 44 24 13	 mov	 BYTE PTR _Spray$109424[esp+52], al

; 3652 : 					DWORD  AddDestY = (DWORD) (((Ynow+(SpeedRand()*Spray >> 8) ) & V2Mask) << UBits );

  00869	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  0086f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  00875	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  0087b	83 c2 04	 add	 edx, 4
  0087e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00884	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  0088a	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  00890	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00896	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  0089c	0f b6 4c 24 13	 movzx	 ecx, BYTE PTR _Spray$109424[esp+52]
  008a1	8b 54 24 14	 mov	 edx, DWORD PTR _this$[esp+52]
  008a5	0f b6 c0	 movzx	 eax, al
  008a8	0f af c1	 imul	 eax, ecx
  008ab	89 4c 24 28	 mov	 DWORD PTR -12+[esp+52], ecx
  008af	8b 4c 24 30	 mov	 ecx, DWORD PTR -4+[esp+52]
  008b3	c1 f8 08	 sar	 eax, 8
  008b6	03 c1		 add	 eax, ecx
  008b8	0f b6 4c 24 11	 movzx	 ecx, BYTE PTR _V2Mask$[esp+52]
  008bd	23 c1		 and	 eax, ecx
  008bf	8a 4a 30	 mov	 cl, BYTE PTR [edx+48]
  008c2	d3 e0		 shl	 eax, cl
  008c4	89 44 24 30	 mov	 DWORD PTR _AddDestY$109425[esp+52], eax

; 3653 : 					DWORD  AddDestX = (DWORD)  ((Xnow+(SpeedRand()*Spray >> 8) ) & U2Mask);

  008c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  008ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  008d4	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  008da	83 c2 04	 add	 edx, 4
  008dd	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  008e3	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  008e9	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  008ef	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  008f5	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  008fb	0f b6 4c 24 10	 movzx	 ecx, BYTE PTR _U2Mask$[esp+52]

; 3654 : 					WaveFieldA[ AddDestY + AddDestX] = Depth;

  00900	8b 54 24 30	 mov	 edx, DWORD PTR _AddDestY$109425[esp+52]
  00904	0f b6 c0	 movzx	 eax, al
  00907	0f af 44 24 28	 imul	 eax, DWORD PTR -12+[esp+52]
  0090c	c1 f8 08	 sar	 eax, 8
  0090f	03 c3		 add	 eax, ebx
  00911	23 c1		 and	 eax, ecx
  00913	8a 4c 24 12	 mov	 cl, BYTE PTR _Depth$[esp+52]
  00917	03 c2		 add	 eax, edx
  00919	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl

; 3655 : 					WaveFieldB[ AddDestY + AddDestX] = 255^Depth;

  0091c	f6 d1		 not	 cl
  0091e	88 0c 38	 mov	 BYTE PTR [eax+edi], cl

; 3656 : 				}
; 3657 : 			}
; 3658 :             break;

  00921	eb 78		 jmp	 SHORT $L109301
$L109429:

; 3659 : 
; 3660 : 
; 3661 : 		case DROP_LeakyTap: // Selfexplanatory.
; 3662 : 			{
; 3663 : 				// Keep the action sparse - just draw more sparks if needed...
; 3664 : 				if( (Drops[S].ByteA +=Drops[S].ByteD) <= Drops[S].ByteD ) 

  00923	8a 06		 mov	 al, BYTE PTR [esi]
  00925	8a 5e fd	 mov	 bl, BYTE PTR [esi-3]
  00928	02 d8		 add	 bl, al
  0092a	8a d3		 mov	 dl, bl
  0092c	3a d0		 cmp	 dl, al
  0092e	88 5e fd	 mov	 BYTE PTR [esi-3], bl
  00931	77 68		 ja	 SHORT $L109301

; 3665 : 				{
; 3666 : 					WaveFieldA[ DropDest ]  =  Drops[S].Depth;

  00933	8a 46 fa	 mov	 al, BYTE PTR [esi-6]
  00936	88 04 29	 mov	 BYTE PTR [ecx+ebp], al

; 3667 : 					WaveFieldB[ DropDest ]  =  255^Drops[S].Depth;

  00939	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]
  0093c	f6 d2		 not	 dl
  0093e	88 14 39	 mov	 BYTE PTR [ecx+edi], dl

; 3668 : 				}
; 3669 : 			}
; 3670 :             break;

  00941	eb 58		 jmp	 SHORT $L109301
$L109431:

; 3671 : 
; 3672 : 			
; 3673 : 		case DROP_DrippyTap: // Irregular Leaky Tap.
; 3674 : 			{
; 3675 : 				// Keep the action sparse - just draw more sparks if needed...
; 3676 : 				if( (Drops[S].ByteA +=Drops[S].ByteD) <= Drops[S].ByteD ) 

  00943	8a 06		 mov	 al, BYTE PTR [esi]
  00945	8a 56 fd	 mov	 dl, BYTE PTR [esi-3]
  00948	02 d0		 add	 dl, al
  0094a	8a ca		 mov	 cl, dl
  0094c	3a c8		 cmp	 cl, al
  0094e	88 56 fd	 mov	 BYTE PTR [esi-3], dl
  00951	77 48		 ja	 SHORT $L109301

; 3677 : 				{ 
; 3678 : 					Drops[S].ByteA = SpeedRand();

  00953	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00959	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0095f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00965	83 c2 04	 add	 edx, 4
  00968	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0096e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00974	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0097a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00980	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax

; 3679 : 					WaveFieldA[ DropDest ]  =  Drops[S].Depth;

  00986	8a 4e fa	 mov	 cl, BYTE PTR [esi-6]
  00989	88 46 fd	 mov	 BYTE PTR [esi-3], al
  0098c	8b 44 24 20	 mov	 eax, DWORD PTR _DropDest$109305[esp+52]
  00990	88 0c 28	 mov	 BYTE PTR [eax+ebp], cl

; 3680 : 					WaveFieldB[ DropDest ]  =  255^Drops[S].Depth;

  00993	8a 56 fa	 mov	 dl, BYTE PTR [esi-6]
  00996	f6 d2		 not	 dl
  00998	88 14 38	 mov	 BYTE PTR [eax+edi], dl
$L109301:
  0099b	8b 44 24 2c	 mov	 eax, DWORD PTR _S$[esp+52]
  0099f	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$[esp+52]
  009a3	8b 91 ec 00 00
	00		 mov	 edx, DWORD PTR [ecx+236]
  009a9	40		 inc	 eax
  009aa	83 c6 08	 add	 esi, 8
  009ad	3b c2		 cmp	 eax, edx
  009af	89 44 24 2c	 mov	 DWORD PTR _S$[esp+52], eax
  009b3	0f 8c a7 f6 ff
	ff		 jl	 $L118871
  009b9	5e		 pop	 esi
  009ba	5b		 pop	 ebx
$L109302:
  009bb	5f		 pop	 edi
  009bc	5d		 pop	 ebp

; 3681 : 				}
; 3682 : 			}
; 3683 :             break;
; 3684 :       
; 3685 :         } //switch
; 3686 : 
; 3687 :     }
; 3688 : }

  009bd	83 c4 24	 add	 esp, 36			; 00000024H
  009c0	c3		 ret	 0
  009c1	8d 49 00	 npad	 3
$L118880:
  009c4	00 00 00 00	 DD	 $L109311
  009c8	00 00 00 00	 DD	 $L109312
  009cc	00 00 00 00	 DD	 $L109315
  009d0	00 00 00 00	 DD	 $L109313
  009d4	00 00 00 00	 DD	 $L109316
  009d8	00 00 00 00	 DD	 $L109317
  009dc	00 00 00 00	 DD	 $L109318
  009e0	00 00 00 00	 DD	 $L109334
  009e4	00 00 00 00	 DD	 $L109348
  009e8	00 00 00 00	 DD	 $L109356
  009ec	00 00 00 00	 DD	 $L109362
  009f0	00 00 00 00	 DD	 $L109370
  009f4	00 00 00 00	 DD	 $L109378
  009f8	00 00 00 00	 DD	 $L109386
  009fc	00 00 00 00	 DD	 $L109392
  00a00	00 00 00 00	 DD	 $L109400
  00a04	00 00 00 00	 DD	 $L109422
  00a08	00 00 00 00	 DD	 $L109408
  00a0c	00 00 00 00	 DD	 $L109429
  00a10	00 00 00 00	 DD	 $L109431
  00a14	00 00 00 00	 DD	 $L109326
  00a18	00 00 00 00	 DD	 $L109340
  00a1c	00 00 00 00	 DD	 $L109301
$L118870:
  00a20	00		 DB	 0
  00a21	01		 DB	 1
  00a22	02		 DB	 2
  00a23	03		 DB	 3
  00a24	04		 DB	 4
  00a25	05		 DB	 5
  00a26	06		 DB	 6
  00a27	07		 DB	 7
  00a28	08		 DB	 8
  00a29	09		 DB	 9
  00a2a	0a		 DB	 10			; 0000000aH
  00a2b	0b		 DB	 11			; 0000000bH
  00a2c	0c		 DB	 12			; 0000000cH
  00a2d	0d		 DB	 13			; 0000000dH
  00a2e	0e		 DB	 14			; 0000000eH
  00a2f	0f		 DB	 15			; 0000000fH
  00a30	10		 DB	 16			; 00000010H
  00a31	11		 DB	 17			; 00000011H
  00a32	12		 DB	 18			; 00000012H
  00a33	13		 DB	 19			; 00000013H
  00a34	16		 DB	 22			; 00000016H
  00a35	16		 DB	 22			; 00000016H
  00a36	16		 DB	 22			; 00000016H
  00a37	16		 DB	 22			; 00000016H
  00a38	16		 DB	 22			; 00000016H
  00a39	16		 DB	 22			; 00000016H
  00a3a	16		 DB	 22			; 00000016H
  00a3b	16		 DB	 22			; 00000016H
  00a3c	16		 DB	 22			; 00000016H
  00a3d	16		 DB	 22			; 00000016H
  00a3e	16		 DB	 22			; 00000016H
  00a3f	16		 DB	 22			; 00000016H
  00a40	16		 DB	 22			; 00000016H
  00a41	16		 DB	 22			; 00000016H
  00a42	16		 DB	 22			; 00000016H
  00a43	16		 DB	 22			; 00000016H
  00a44	16		 DB	 22			; 00000016H
  00a45	16		 DB	 22			; 00000016H
  00a46	16		 DB	 22			; 00000016H
  00a47	16		 DB	 22			; 00000016H
  00a48	16		 DB	 22			; 00000016H
  00a49	16		 DB	 22			; 00000016H
  00a4a	16		 DB	 22			; 00000016H
  00a4b	16		 DB	 22			; 00000016H
  00a4c	16		 DB	 22			; 00000016H
  00a4d	16		 DB	 22			; 00000016H
  00a4e	16		 DB	 22			; 00000016H
  00a4f	16		 DB	 22			; 00000016H
  00a50	16		 DB	 22			; 00000016H
  00a51	16		 DB	 22			; 00000016H
  00a52	16		 DB	 22			; 00000016H
  00a53	16		 DB	 22			; 00000016H
  00a54	16		 DB	 22			; 00000016H
  00a55	16		 DB	 22			; 00000016H
  00a56	16		 DB	 22			; 00000016H
  00a57	16		 DB	 22			; 00000016H
  00a58	16		 DB	 22			; 00000016H
  00a59	16		 DB	 22			; 00000016H
  00a5a	16		 DB	 22			; 00000016H
  00a5b	16		 DB	 22			; 00000016H
  00a5c	16		 DB	 22			; 00000016H
  00a5d	16		 DB	 22			; 00000016H
  00a5e	16		 DB	 22			; 00000016H
  00a5f	16		 DB	 22			; 00000016H
  00a60	14		 DB	 20			; 00000014H
  00a61	15		 DB	 21			; 00000015H
?WaterRedrawDrops@UWaterTexture@@QAEXXZ ENDP		; UWaterTexture::WaterRedrawDrops
_TEXT	ENDS
PUBLIC	?AddDrop@UWaterTexture@@AAEXHH@Z		; UWaterTexture::AddDrop
; Function compile flags: /Ogty
;	COMDAT ?AddDrop@UWaterTexture@@AAEXHH@Z
_TEXT	SEGMENT
_DropX$ = 8
_DropY$ = 12
?AddDrop@UWaterTexture@@AAEXHH@Z PROC NEAR		; UWaterTexture::AddDrop, COMDAT
; _this$ = ecx

; 3697 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3698 :     // Return if out of bounds or out of Drops.
; 3699 :     if( DropX>=USize || DropY>=VSize || DropX<0 || DropY<0 || NumDrops>=MaxDrops )

  00003	8b 4c 24 08	 mov	 ecx, DWORD PTR _DropX$[esp]
  00007	3b 4e 34	 cmp	 ecx, DWORD PTR [esi+52]
  0000a	57		 push	 edi
  0000b	0f 8d 9c 02 00
	00		 jge	 $L109442
  00011	8b 44 24 10	 mov	 eax, DWORD PTR _DropY$[esp+4]
  00015	3b 46 38	 cmp	 eax, DWORD PTR [esi+56]
  00018	0f 8d 8f 02 00
	00		 jge	 $L109442
  0001e	33 d2		 xor	 edx, edx
  00020	3b ca		 cmp	 ecx, edx
  00022	0f 8c 85 02 00
	00		 jl	 $L109442
  00028	3b c2		 cmp	 eax, edx
  0002a	0f 8c 7d 02 00
	00		 jl	 $L109442
  00030	8b be ec 00 00
	00		 mov	 edi, DWORD PTR [esi+236]
  00036	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  0003c	0f 8d 6b 02 00
	00		 jge	 $L109442
  00042	53		 push	 ebx

; 3700 :         return;
; 3701 : 
; 3702 :     INT  S = NumDrops++;
; 3703 : 
; 3704 :     Drops[S].X = DropX >> 1;
; 3705 :     Drops[S].Y = DropY >> 1;

  00043	d1 f8		 sar	 eax, 1
  00045	8d 5f 01	 lea	 ebx, DWORD PTR [edi+1]
  00048	89 9e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ebx
  0004e	d1 f9		 sar	 ecx, 1
  00050	88 84 fe f3 00
	00 00		 mov	 BYTE PTR [esi+edi*8+243], al
  00057	88 8c fe f2 00
	00 00		 mov	 BYTE PTR [esi+edi*8+242], cl

; 3706 :     Drops[S].Type = DropType;

  0005e	8a 86 e0 00 00
	00		 mov	 al, BYTE PTR [esi+224]
  00064	88 84 fe f0 00
	00 00		 mov	 BYTE PTR [esi+edi*8+240], al

; 3707 : 
; 3708 :     DrawPhase++;

  0006b	8a 9e dc 00 00
	00		 mov	 bl, BYTE PTR [esi+220]

; 3709 : 
; 3710 :     // The rest are Drop-type specific assignments.
; 3711 : 
; 3712 : 	switch( DropType )
; 3713 :     {

  00071	0f b6 86 e0 00
	00 00		 movzx	 eax, BYTE PTR [esi+224]
  00078	fe c3		 inc	 bl
  0007a	48		 dec	 eax
  0007b	83 f8 12	 cmp	 eax, 18			; 00000012H
  0007e	88 9e dc 00 00
	00		 mov	 BYTE PTR [esi+220], bl
  00084	5b		 pop	 ebx
  00085	0f 87 22 02 00
	00		 ja	 $L109442
  0008b	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $L118888[eax]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $L118891[ecx*4]
$L109445:

; 3714 : 		// Force a certain area to FX_Depth.
; 3715 : 
; 3716 : 		case DROP_PhaseSpot:  // Align new phase in-step.
; 3717 : 		case DROP_HalfAmpl:   // 
; 3718 : 			{
; 3719 : 			Drops[S].Depth = ( GlobalPhase * ( FX_Frequency  ) + FX_Phase) & 255;

  00099	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  0009f	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  000a5	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  000ab	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3720 : 			Drops[S].ByteD = FX_Frequency;

  000b2	8a 86 e2 00 00
	00		 mov	 al, BYTE PTR [esi+226]

; 3721 : 			Drops[S].ByteA=0;

  000b8	88 94 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], dl

; 3722 : 			Drops[S].ByteB=0;

  000bf	88 94 fe f5 00
	00 00		 mov	 BYTE PTR [esi+edi*8+245], dl

; 3723 : 			Drops[S].ByteC=0;

  000c6	88 94 fe f6 00
	00 00		 mov	 BYTE PTR [esi+edi*8+246], dl

; 3807 : 			Drops[S].ByteD = (FX_Frequency ) >>2;

  000cd	88 84 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], al
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  000d6	c2 08 00	 ret	 8
$L109446:

; 3724 : 			}
; 3725 : 			break;
; 3726 : 
; 3727 : 		case DROP_ShallowSpot: // Align new phase in-step, whatever the period.
; 3728 : 			Drops[S].Depth = ( GlobalPhase * FX_Frequency + FX_Phase) & 255;

  000d9	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  000df	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  000e5	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  000eb	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3729 : 			Drops[S].ByteD = FX_Frequency;

  000f2	8a 8e e2 00 00
	00		 mov	 cl, BYTE PTR [esi+226]
  000f8	88 8c fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], cl
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00101	c2 08 00	 ret	 8
$L109448:

; 3730 : 			break;
; 3731 : 
; 3732 : 		case DROP_FixedRandomSpot: // random fixed spot
; 3733 : 			break;
; 3734 : 
; 3735 : 		// All sparks that need ParamsB as their 'depth':
; 3736 : 		case DROP_HorizontalLine:
; 3737 : 		case DROP_VerticalLine:
; 3738 : 		case DROP_DiagonalLine1:
; 3739 : 		case DROP_DiagonalLine2:
; 3740 : 		case DROP_RainDrops:
; 3741 : 			Drops[S].Depth = FX_Depth;

  00104	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  0010a	88 94 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], dl

; 3742 : 			Drops[S].ByteD = FX_Size;

  00111	8a 86 e7 00 00
	00		 mov	 al, BYTE PTR [esi+231]

; 3807 : 			Drops[S].ByteD = (FX_Frequency ) >>2;

  00117	88 84 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], al
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00120	c2 08 00	 ret	 8
$L109449:

; 3743 : 			break;
; 3744 : 
; 3745 : 		// All linesegments that need a fixed relative phase:
; 3746 : 		case DROP_HorizontalOsc:
; 3747 : 		case DROP_VerticalOsc:
; 3748 : 		case DROP_DiagonalOsc1:
; 3749 : 		case DROP_DiagonalOsc2:
; 3750 : 			Drops[S].Depth = ( GlobalPhase * FX_Frequency + FX_Phase) & 255;

  00123	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  00129	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  0012f	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  00135	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3751 : 			Drops[S].ByteC = FX_Frequency;

  0013c	8a 8e e2 00 00
	00		 mov	 cl, BYTE PTR [esi+226]
  00142	88 8c fe f6 00
	00 00		 mov	 BYTE PTR [esi+edi*8+246], cl

; 3752 : 			Drops[S].ByteD = FX_Size;

  00149	8a 96 e7 00 00
	00		 mov	 dl, BYTE PTR [esi+231]
  0014f	88 94 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], dl
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00158	c2 08 00	 ret	 8
$L109450:

; 3753 : 			break;
; 3754 : 
; 3755 : 		case DROP_AreaClamp:
; 3756 : 			Drops[S].Depth = FX_Depth;

  0015b	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  00161	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3757 : 			Drops[S].ByteD = FX_Size;

  00168	8a 8e e7 00 00
	00		 mov	 cl, BYTE PTR [esi+231]
  0016e	88 8c fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], cl
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00177	c2 08 00	 ret	 8
$L109451:

; 3758 : 			break;
; 3759 : 
; 3760 : 		case DROP_WhirlyThing:
; 3761 : 			{
; 3762 : 			Drops[S].Depth = FX_Depth;

  0017a	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  00180	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3763 : 			Drops[S].ByteA=0; // Low-byte of phase.

  00187	88 94 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], dl

; 3764 : 
; 3765 : 			INT TempFreq = FX_Frequency;

  0018e	0f b6 86 e2 00
	00 00		 movzx	 eax, BYTE PTR [esi+226]

; 3766 : 			if( TempFreq > 127 ) // negative variant

  00195	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00198	7e 3b		 jle	 SHORT $L109458

; 3767 : 				{
; 3768 : 				Drops[S].Type = DROP_WhirlyBack;

  0019a	c6 84 fe f0 00
	00 00 40	 mov	 BYTE PTR [esi+edi*8+240], 64 ; 00000040H

; 3769 : 				TempFreq = 255-TempFreq;
; 3770 : 				}
; 3771 : 
; 3772 : 			DWORD TimeDelta = 65535/( (INT)(127-TempFreq) +1); //65536
; 3773 : 			Drops[S].ByteC =  ( TimeDelta & 0x00FF );
; 3774 : 			Drops[S].ByteD =  ( TimeDelta & 0xFF00 ) >> 8;
; 3775 : 			Drops[S].ByteB = (( (GlobalPhase * ( TimeDelta )) + (FX_Phase << 8) ) >> 8 ) & 255;
; 3776 : 			}
; 3777 : 			break;

  001a2	eb 28		 jmp	 SHORT $L118890
$L109456:

; 3778 : 
; 3779 : 		case DROP_BigWhirly:
; 3780 : 			{
; 3781 : 			Drops[S].Depth = FX_Depth;

  001a4	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  001aa	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3782 : 			Drops[S].ByteA=0; // Low-byte of phase.

  001b1	88 94 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], dl

; 3783 : 
; 3784 : 			INT TempFreq = FX_Frequency;

  001b8	0f b6 86 e2 00
	00 00		 movzx	 eax, BYTE PTR [esi+226]

; 3785 : 			if( TempFreq > 127 ) // negative variant

  001bf	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  001c2	7e 11		 jle	 SHORT $L109458

; 3786 : 				{
; 3787 : 				Drops[S].Type = DROP_BigWhirlyBack;

  001c4	c6 84 fe f0 00
	00 00 41	 mov	 BYTE PTR [esi+edi*8+240], 65 ; 00000041H
$L118890:

; 3788 : 				TempFreq = 255-TempFreq;

  001cc	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  001d1	2b c8		 sub	 ecx, eax
  001d3	8b c1		 mov	 eax, ecx
$L109458:

; 3789 : 				}
; 3790 : 
; 3791 : 			DWORD TimeDelta = 65535/( (INT)(127-TempFreq) +1); //65537

  001d5	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001da	2b c8		 sub	 ecx, eax
  001dc	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001e1	99		 cdq
  001e2	f7 f9		 idiv	 ecx

; 3792 : 			Drops[S].ByteC =  ( TimeDelta & 0x00FF );
; 3793 : 			Drops[S].ByteD =  ( TimeDelta & 0xFF00 ) >> 8;

  001e4	8b d0		 mov	 edx, eax
  001e6	c1 ea 08	 shr	 edx, 8
  001e9	88 94 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], dl
  001f0	88 84 fe f6 00
	00 00		 mov	 BYTE PTR [esi+edi*8+246], al

; 3794 : 			Drops[S].ByteB = (( (GlobalPhase * ( TimeDelta )) + (FX_Phase << 8) ) >> 8 ) & 255;

  001f7	8b 96 d8 00 00
	00		 mov	 edx, DWORD PTR [esi+216]
  001fd	0f b6 8e e3 00
	00 00		 movzx	 ecx, BYTE PTR [esi+227]
  00204	0f af d0	 imul	 edx, eax
  00207	c1 e1 08	 shl	 ecx, 8
  0020a	03 ca		 add	 ecx, edx
  0020c	c1 e9 08	 shr	 ecx, 8
  0020f	88 8c fe f5 00
	00 00		 mov	 BYTE PTR [esi+edi*8+245], cl
  00216	5f		 pop	 edi
  00217	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00218	c2 08 00	 ret	 8
$L109461:

; 3795 : 			}
; 3796 : 			break;
; 3797 : 
; 3798 : 		case DROP_LeakyTap:
; 3799 : 			Drops[S].Depth = FX_Depth;

  0021b	8a 86 e8 00 00
	00		 mov	 al, BYTE PTR [esi+232]
  00221	88 84 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], al

; 3800 : 			Drops[S].ByteA = ( GlobalPhase * FX_Frequency + FX_Phase) & 255;

  00228	8a 86 d8 00 00
	00		 mov	 al, BYTE PTR [esi+216]
  0022e	f6 ae e2 00 00
	00		 imul	 BYTE PTR [esi+226]
  00234	02 86 e3 00 00
	00		 add	 al, BYTE PTR [esi+227]
  0023a	88 84 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], al

; 3801 : 			Drops[S].ByteD = ( FX_Frequency ) >>2;

  00241	8a 8e e2 00 00
	00		 mov	 cl, BYTE PTR [esi+226]
  00247	c0 e9 02	 shr	 cl, 2
  0024a	88 8c fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], cl
  00251	5f		 pop	 edi
  00252	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  00253	c2 08 00	 ret	 8
$L109462:

; 3802 : 			break;		
; 3803 : 
; 3804 : 		case DROP_DrippyTap:
; 3805 : 			Drops[S].Depth = FX_Depth;

  00256	8a 96 e8 00 00
	00		 mov	 dl, BYTE PTR [esi+232]
  0025c	88 94 fe f1 00
	00 00		 mov	 BYTE PTR [esi+edi*8+241], dl

; 3806 : 			Drops[S].ByteA = SpeedRand();

  00263	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SpeedRindex
  00269	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SpeedRindex
  0026f	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00275	83 c2 04	 add	 edx, 4
  00278	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  0027e	81 e2 fc 00 00
	00		 and	 edx, 252		; 000000fcH
  00284	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR _SpeedRandArr[ecx]
  0028a	89 15 00 00 00
	00		 mov	 DWORD PTR _SpeedRindex, edx
  00290	31 82 00 00 00
	00		 xor	 DWORD PTR _SpeedRandArr[edx], eax
  00296	88 84 fe f4 00
	00 00		 mov	 BYTE PTR [esi+edi*8+244], al

; 3807 : 			Drops[S].ByteD = (FX_Frequency ) >>2;

  0029d	8a 86 e2 00 00
	00		 mov	 al, BYTE PTR [esi+226]
  002a3	c0 e8 02	 shr	 al, 2
  002a6	88 84 fe f7 00
	00 00		 mov	 BYTE PTR [esi+edi*8+247], al
$L109442:
  002ad	5f		 pop	 edi
  002ae	5e		 pop	 esi

; 3808 : 			break;		
; 3809 : 	}
; 3810 : }

  002af	c2 08 00	 ret	 8
  002b2	8b ff		 npad	 2
$L118891:
  002b4	00 00 00 00	 DD	 $L109445
  002b8	00 00 00 00	 DD	 $L109446
  002bc	00 00 00 00	 DD	 $L109451
  002c0	00 00 00 00	 DD	 $L109456
  002c4	00 00 00 00	 DD	 $L109448
  002c8	00 00 00 00	 DD	 $L109449
  002cc	00 00 00 00	 DD	 $L109450
  002d0	00 00 00 00	 DD	 $L109461
  002d4	00 00 00 00	 DD	 $L109462
  002d8	00 00 00 00	 DD	 $L109442
$L118888:
  002dc	00		 DB	 0
  002dd	01		 DB	 1
  002de	00		 DB	 0
  002df	09		 DB	 9
  002e0	09		 DB	 9
  002e1	02		 DB	 2
  002e2	03		 DB	 3
  002e3	04		 DB	 4
  002e4	04		 DB	 4
  002e5	04		 DB	 4
  002e6	04		 DB	 4
  002e7	05		 DB	 5
  002e8	05		 DB	 5
  002e9	05		 DB	 5
  002ea	05		 DB	 5
  002eb	04		 DB	 4
  002ec	06		 DB	 6
  002ed	07		 DB	 7
  002ee	08		 DB	 8
?AddDrop@UWaterTexture@@AAEXHH@Z ENDP			; UWaterTexture::AddDrop
_TEXT	ENDS
PUBLIC	?DeleteDrops@UWaterTexture@@AAEXHHH@Z		; UWaterTexture::DeleteDrops
; Function compile flags: /Ogty
;	COMDAT ?DeleteDrops@UWaterTexture@@AAEXHHH@Z
_TEXT	SEGMENT
_DropX$ = 8
_DropY$ = 12
_AreaWidth$ = 16
?DeleteDrops@UWaterTexture@@AAEXHHH@Z PROC NEAR		; UWaterTexture::DeleteDrops, COMDAT
; _this$ = ecx

; 3815 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 3816 :     for( INT S=0; S<NumDrops; S++ )

  00002	8b b1 ec 00 00
	00		 mov	 esi, DWORD PTR [ecx+236]
  00008	33 db		 xor	 ebx, ebx
  0000a	85 f6		 test	 esi, esi
  0000c	7e 62		 jle	 SHORT $L109472
  0000e	55		 push	 ebp
  0000f	57		 push	 edi
  00010	8d 91 f3 00 00
	00		 lea	 edx, DWORD PTR [ecx+243]
$L109470:

; 3817 :     {
; 3818 :         if( AreaWidth >= ( Abs(DropX - (Drops[S].X << 1) ) +
; 3819 :                            Abs(DropY - (Drops[S].Y << 1) ) ) )

  00016	0f b6 42 ff	 movzx	 eax, BYTE PTR [edx-1]
  0001a	d1 e0		 shl	 eax, 1
  0001c	8b f8		 mov	 edi, eax
  0001e	8b 44 24 14	 mov	 eax, DWORD PTR _DropX$[esp+12]
  00022	2b c7		 sub	 eax, edi
  00024	79 02		 jns	 SHORT $L118914
  00026	f7 d8		 neg	 eax
$L118914:
  00028	8b f8		 mov	 edi, eax
  0002a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002d	d1 e0		 shl	 eax, 1
  0002f	8b e8		 mov	 ebp, eax
  00031	8b 44 24 18	 mov	 eax, DWORD PTR _DropY$[esp+12]
  00035	2b c5		 sub	 eax, ebp
  00037	79 02		 jns	 SHORT $L118908
  00039	f7 d8		 neg	 eax
$L118908:
  0003b	03 c7		 add	 eax, edi
  0003d	39 44 24 1c	 cmp	 DWORD PTR _AreaWidth$[esp+12], eax
  00041	7c 1d		 jl	 SHORT $L109471

; 3820 :         {
; 3821 :             // Delete Drop by replacing it with last one (+ delete last one).
; 3822 :             INT  LastDrop = --NumDrops;

  00043	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00046	89 81 ec 00 00
	00		 mov	 DWORD PTR [ecx+236], eax

; 3823 :             Drops[S] = Drops[LastDrop];

  0004c	8b b4 c1 f0 00
	00 00		 mov	 esi, DWORD PTR [ecx+eax*8+240]
  00053	89 72 fd	 mov	 DWORD PTR [edx-3], esi
  00056	8b 84 c1 f4 00
	00 00		 mov	 eax, DWORD PTR [ecx+eax*8+244]
  0005d	89 42 01	 mov	 DWORD PTR [edx+1], eax
$L109471:
  00060	8b b1 ec 00 00
	00		 mov	 esi, DWORD PTR [ecx+236]
  00066	43		 inc	 ebx
  00067	83 c2 08	 add	 edx, 8
  0006a	3b de		 cmp	 ebx, esi
  0006c	7c a8		 jl	 SHORT $L109470
  0006e	5f		 pop	 edi
  0006f	5d		 pop	 ebp
$L109472:
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx

; 3824 :         }
; 3825 :     }
; 3826 : }

  00072	c2 0c 00	 ret	 12			; 0000000cH
?DeleteDrops@UWaterTexture@@AAEXHHH@Z ENDP		; UWaterTexture::DeleteDrops
_TEXT	ENDS
PUBLIC	?TempDrawSpark@UFireTexture@@AAEXHHH@Z		; UFireTexture::TempDrawSpark
; Function compile flags: /Ogty
;	COMDAT ?TempDrawSpark@UFireTexture@@AAEXHHH@Z
_TEXT	SEGMENT
_PosX$ = 8
_PosY$ = 12
_Intensity$ = 16
?TempDrawSpark@UFireTexture@@AAEXHHH@Z PROC NEAR	; UFireTexture::TempDrawSpark, COMDAT
; _this$ = ecx

; 3834 : {

  00000	8b c1		 mov	 eax, ecx

; 3835 :     DWORD SparkDest;
; 3836 : 
; 3837 :     SparkDest = (DWORD)(   (UMask & PosX) +
; 3838 :                           ((VMask & PosY)<< UBits )   );

  00002	8b 90 cc 00 00
	00		 mov	 edx, DWORD PTR [eax+204]
  00008	23 54 24 08	 and	 edx, DWORD PTR _PosY$[esp-4]
  0000c	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  0000f	d3 e2		 shl	 edx, cl
  00011	8b 88 c8 00 00
	00		 mov	 ecx, DWORD PTR [eax+200]

; 3839 : 
; 3840 :     Mips(0).DataArray(SparkDest) = (BYTE) Intensity;

  00017	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [eax+168]
  0001d	23 4c 24 04	 and	 ecx, DWORD PTR _PosX$[esp-4]
  00021	03 d1		 add	 edx, ecx
  00023	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00026	8a 44 24 0c	 mov	 al, BYTE PTR _Intensity$[esp-4]
  0002a	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 3841 : }

  0002d	c2 0c 00	 ret	 12			; 0000000cH
?TempDrawSpark@UFireTexture@@AAEXHHH@Z ENDP		; UFireTexture::TempDrawSpark
_TEXT	ENDS
PUBLIC	?BlueLagunaPalette@@YAXPAVUPalette@@@Z		; BlueLagunaPalette
; Function compile flags: /Ogty
;	COMDAT ?BlueLagunaPalette@@YAXPAVUPalette@@@Z
_TEXT	SEGMENT
_TargetPal$ = 8
?BlueLagunaPalette@@YAXPAVUPalette@@@Z PROC NEAR	; BlueLagunaPalette, COMDAT

; 3849 : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H

; 3850 : 	for( INT i=0; i< 64; i++ )

  00003	33 c9		 xor	 ecx, ecx
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	8b 74 24 30	 mov	 esi, DWORD PTR _TargetPal$[esp+40]
  0000c	33 ed		 xor	 ebp, ebp
  0000e	57		 push	 edi
  0000f	89 4c 24 2c	 mov	 DWORD PTR -4+[esp+48], ecx
  00013	89 4c 24 28	 mov	 DWORD PTR -8+[esp+48], ecx
  00017	89 4c 24 24	 mov	 DWORD PTR -12+[esp+48], ecx
  0001b	89 4c 24 20	 mov	 DWORD PTR -16+[esp+48], ecx
  0001f	89 4c 24 1c	 mov	 DWORD PTR -20+[esp+48], ecx
  00023	89 4c 24 18	 mov	 DWORD PTR -24+[esp+48], ecx
  00027	89 4c 24 14	 mov	 DWORD PTR -28+[esp+48], ecx
  0002b	89 4c 24 10	 mov	 DWORD PTR -32+[esp+48], ecx
  0002f	89 4c 24 34	 mov	 DWORD PTR 8+[esp+44], ecx
  00033	33 db		 xor	 ebx, ebx
$L109494:

; 3851 : 	{
; 3852 : 		TargetPal->Colors(i).R     = Min(    0+ (i* 59)/64 ,255);

  00035	8b c3		 mov	 eax, ebx
  00037	99		 cdq
  00038	83 e2 3f	 and	 edx, 63			; 0000003fH
  0003b	03 c2		 add	 eax, edx
  0003d	c1 f8 06	 sar	 eax, 6
  00040	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00045	7e 05		 jle	 SHORT $L118932
  00047	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L118932:
  0004c	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0004f	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 3853 : 		TargetPal->Colors(i).G     = Min(    0+ (i* 67)/64 ,255);

  00052	8b 44 24 34	 mov	 eax, DWORD PTR 8+[esp+44]
  00056	99		 cdq
  00057	83 e2 3f	 and	 edx, 63			; 0000003fH
  0005a	03 c2		 add	 eax, edx
  0005c	c1 f8 06	 sar	 eax, 6
  0005f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00064	7e 05		 jle	 SHORT $L118943
  00066	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L118943:
  0006b	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0006e	88 44 11 01	 mov	 BYTE PTR [ecx+edx+1], al

; 3854 : 		TargetPal->Colors(i).B     = Min(    0+ (i*100)/64 ,255);

  00072	8b 44 24 10	 mov	 eax, DWORD PTR -32+[esp+48]
  00076	99		 cdq
  00077	83 e2 3f	 and	 edx, 63			; 0000003fH
  0007a	03 c2		 add	 eax, edx
  0007c	c1 f8 06	 sar	 eax, 6
  0007f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00084	7e 05		 jle	 SHORT $L118954
  00086	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L118954:
  0008b	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0008e	88 44 11 02	 mov	 BYTE PTR [ecx+edx+2], al

; 3855 : 
; 3856 : 		TargetPal->Colors(i+64).R  = Min(   59+ (i* 55)/64 ,255);

  00092	8b c5		 mov	 eax, ebp
  00094	99		 cdq
  00095	83 e2 3f	 and	 edx, 63			; 0000003fH
  00098	03 c2		 add	 eax, edx
  0009a	c1 f8 06	 sar	 eax, 6
  0009d	83 c0 3b	 add	 eax, 59			; 0000003bH
  000a0	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000a5	7e 05		 jle	 SHORT $L118965
  000a7	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L118965:
  000ac	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000af	88 84 11 00 01
	00 00		 mov	 BYTE PTR [ecx+edx+256], al

; 3857 : 		TargetPal->Colors(i+64).G  = Min(   67+ (i* 60)/64 ,255);

  000b6	8b 44 24 1c	 mov	 eax, DWORD PTR -20+[esp+48]
  000ba	99		 cdq
  000bb	83 e2 3f	 and	 edx, 63			; 0000003fH
  000be	03 c2		 add	 eax, edx
  000c0	8b f8		 mov	 edi, eax
  000c2	c1 ff 06	 sar	 edi, 6
  000c5	8d 47 43	 lea	 eax, DWORD PTR [edi+67]
  000c8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000cd	7e 05		 jle	 SHORT $L118976
  000cf	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L118976:
  000d4	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000d7	88 84 11 01 01
	00 00		 mov	 BYTE PTR [ecx+edx+257], al

; 3858 : 		TargetPal->Colors(i+64).B  = Min(  100+ (i* 97)/64 ,255);

  000de	8b 44 24 14	 mov	 eax, DWORD PTR -28+[esp+48]
  000e2	99		 cdq
  000e3	83 e2 3f	 and	 edx, 63			; 0000003fH
  000e6	03 c2		 add	 eax, edx
  000e8	c1 f8 06	 sar	 eax, 6
  000eb	83 c0 64	 add	 eax, 100		; 00000064H
  000ee	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f3	7e 05		 jle	 SHORT $L118987
  000f5	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L118987:
  000fa	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000fd	88 84 11 02 01
	00 00		 mov	 BYTE PTR [ecx+edx+258], al

; 3859 : 
; 3860 : 		TargetPal->Colors(i+128).R = Min(  114+ (i* 64)/64 ,255);

  00104	8b 44 24 18	 mov	 eax, DWORD PTR -24+[esp+48]
  00108	99		 cdq
  00109	83 e2 3f	 and	 edx, 63			; 0000003fH
  0010c	03 c2		 add	 eax, edx
  0010e	c1 f8 06	 sar	 eax, 6
  00111	83 c0 72	 add	 eax, 114		; 00000072H
  00114	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00119	7e 05		 jle	 SHORT $L118998
  0011b	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L118998:
  00120	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00123	88 84 11 00 02
	00 00		 mov	 BYTE PTR [ecx+edx+512], al

; 3861 : 		TargetPal->Colors(i+128).G = Min(  127+ (i* 60)/64 ,255);

  0012a	8d 47 7f	 lea	 eax, DWORD PTR [edi+127]
  0012d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00132	7e 05		 jle	 SHORT $L119009
  00134	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L119009:
  00139	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0013c	88 84 11 01 02
	00 00		 mov	 BYTE PTR [ecx+edx+513], al

; 3862 : 		TargetPal->Colors(i+128).B = Min(  197+ (i* 33)/64 ,255);

  00143	8b 44 24 20	 mov	 eax, DWORD PTR -16+[esp+48]
  00147	99		 cdq
  00148	83 e2 3f	 and	 edx, 63			; 0000003fH
  0014b	03 c2		 add	 eax, edx
  0014d	c1 f8 06	 sar	 eax, 6
  00150	05 c5 00 00 00	 add	 eax, 197		; 000000c5H
  00155	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0015a	7e 05		 jle	 SHORT $L119020
  0015c	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L119020:
  00161	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  00164	88 84 11 02 02
	00 00		 mov	 BYTE PTR [ecx+edx+514], al

; 3863 : 
; 3864 : 		TargetPal->Colors(i+192).R = Min(  178+ (i* 78)/64 ,255);

  0016b	8b 44 24 24	 mov	 eax, DWORD PTR -12+[esp+48]
  0016f	99		 cdq
  00170	83 e2 3f	 and	 edx, 63			; 0000003fH
  00173	03 c2		 add	 eax, edx
  00175	c1 f8 06	 sar	 eax, 6
  00178	05 b2 00 00 00	 add	 eax, 178		; 000000b2H
  0017d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00182	7e 05		 jle	 SHORT $L119031
  00184	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L119031:
  00189	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0018c	88 84 11 00 03
	00 00		 mov	 BYTE PTR [ecx+edx+768], al

; 3865 : 		TargetPal->Colors(i+192).G = Min(  187+ (i* 69)/64 ,255);

  00193	8b 44 24 28	 mov	 eax, DWORD PTR -8+[esp+48]
  00197	99		 cdq
  00198	83 e2 3f	 and	 edx, 63			; 0000003fH
  0019b	03 c2		 add	 eax, edx
  0019d	c1 f8 06	 sar	 eax, 6
  001a0	05 bb 00 00 00	 add	 eax, 187		; 000000bbH
  001a5	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001aa	7e 05		 jle	 SHORT $L119042
  001ac	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L119042:
  001b1	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  001b4	88 84 11 01 03
	00 00		 mov	 BYTE PTR [ecx+edx+769], al

; 3866 : 		TargetPal->Colors(i+192).B = Min(  230+ (i* 26)/64 ,255);

  001bb	8b 44 24 2c	 mov	 eax, DWORD PTR -4+[esp+48]
  001bf	99		 cdq
  001c0	83 e2 3f	 and	 edx, 63			; 0000003fH
  001c3	03 c2		 add	 eax, edx
  001c5	c1 f8 06	 sar	 eax, 6
  001c8	05 e6 00 00 00	 add	 eax, 230		; 000000e6H
  001cd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001d2	7e 05		 jle	 SHORT $L119053
  001d4	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L119053:
  001d9	8b 7c 24 34	 mov	 edi, DWORD PTR 8+[esp+44]
  001dd	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  001e0	88 84 11 02 03
	00 00		 mov	 BYTE PTR [ecx+edx+770], al
  001e7	8b 54 24 10	 mov	 edx, DWORD PTR -32+[esp+48]
  001eb	8b 44 24 1c	 mov	 eax, DWORD PTR -20+[esp+48]
  001ef	83 c7 43	 add	 edi, 67			; 00000043H
  001f2	89 7c 24 34	 mov	 DWORD PTR 8+[esp+44], edi
  001f6	8b 7c 24 14	 mov	 edi, DWORD PTR -28+[esp+48]
  001fa	83 c2 64	 add	 edx, 100		; 00000064H
  001fd	83 c7 61	 add	 edi, 97			; 00000061H
  00200	89 54 24 10	 mov	 DWORD PTR -32+[esp+48], edx
  00204	8b 54 24 18	 mov	 edx, DWORD PTR -24+[esp+48]
  00208	89 7c 24 14	 mov	 DWORD PTR -28+[esp+48], edi
  0020c	8b 7c 24 20	 mov	 edi, DWORD PTR -16+[esp+48]
  00210	83 c2 40	 add	 edx, 64			; 00000040H
  00213	83 c0 3c	 add	 eax, 60			; 0000003cH
  00216	83 c7 21	 add	 edi, 33			; 00000021H
  00219	89 54 24 18	 mov	 DWORD PTR -24+[esp+48], edx
  0021d	8b 54 24 24	 mov	 edx, DWORD PTR -12+[esp+48]
  00221	89 44 24 1c	 mov	 DWORD PTR -20+[esp+48], eax
  00225	8b 44 24 28	 mov	 eax, DWORD PTR -8+[esp+48]
  00229	89 7c 24 20	 mov	 DWORD PTR -16+[esp+48], edi
  0022d	8b 7c 24 2c	 mov	 edi, DWORD PTR -4+[esp+48]
  00231	83 c3 3b	 add	 ebx, 59			; 0000003bH
  00234	83 c2 4e	 add	 edx, 78			; 0000004eH
  00237	83 c0 45	 add	 eax, 69			; 00000045H
  0023a	83 c7 1a	 add	 edi, 26			; 0000001aH
  0023d	83 c5 37	 add	 ebp, 55			; 00000037H
  00240	83 c1 04	 add	 ecx, 4
  00243	81 fb c0 0e 00
	00		 cmp	 ebx, 3776		; 00000ec0H
  00249	89 54 24 24	 mov	 DWORD PTR -12+[esp+48], edx
  0024d	89 44 24 28	 mov	 DWORD PTR -8+[esp+48], eax
  00251	89 7c 24 2c	 mov	 DWORD PTR -4+[esp+48], edi
  00255	0f 8c da fd ff
	ff		 jl	 $L109494
  0025b	5f		 pop	 edi
  0025c	5e		 pop	 esi
  0025d	5d		 pop	 ebp
  0025e	5b		 pop	 ebx

; 3867 : 	}
; 3868 : };

  0025f	83 c4 20	 add	 esp, 32			; 00000020H
  00262	c3		 ret	 0
?BlueLagunaPalette@@YAXPAVUPalette@@@Z ENDP		; BlueLagunaPalette
_TEXT	ENDS
PUBLIC	??0UFractalTexture@@QAE@XZ			; UFractalTexture::UFractalTexture
PUBLIC	?PostLoad@UFractalTexture@@UAEXXZ		; UFractalTexture::PostLoad
PUBLIC	?PostEditChange@UFractalTexture@@UAEXXZ		; UFractalTexture::PostEditChange
PUBLIC	?Init@UFractalTexture@@UAEXHH@Z			; UFractalTexture::Init
PUBLIC	?TouchTexture@UFractalTexture@@UAEXHHM@Z	; UFractalTexture::TouchTexture
PUBLIC	??_7UFractalTexture@@6B@			; UFractalTexture::`vftable'
PUBLIC	??_EUFractalTexture@@UAEPAXI@Z			; UFractalTexture::`vector deleting destructor'
EXTRN	__imp_??0UTexture@@QAE@XZ:NEAR
EXTRN	?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z:NEAR	; UTexture::GetMip
EXTRN	?MousePosition@UTexture@@UAEXKMM@Z:NEAR		; UTexture::MousePosition
EXTRN	?Click@UTexture@@UAEXKMM@Z:NEAR			; UTexture::Click
EXTRN	?Serialize@UTexture@@UAEXAAVFArchive@@@Z:NEAR	; UTexture::Serialize
EXTRN	?Destroy@UTexture@@UAEXXZ:NEAR			; UTexture::Destroy
EXTRN	?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z:NEAR ; UTexture::Lock
EXTRN	?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z:NEAR	; UTexture::Unlock
EXTRN	?Clear@UTexture@@UAEXK@Z:NEAR			; UTexture::Clear
EXTRN	?Tick@UTexture@@UAIXM@Z:NEAR			; UTexture::Tick
EXTRN	?ConstantTimeTick@UTexture@@UAEXXZ:NEAR		; UTexture::ConstantTimeTick
EXTRN	?Update@UTexture@@UAEXN@Z:NEAR			; UTexture::Update
EXTRN	?IsPendingKill@UObject@@UAEHXZ:NEAR		; UObject::IsPendingKill
EXTRN	?GetName@UObject@@UBEPBGXZ:NEAR			; UObject::GetName
EXTRN	?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z:NEAR ; UObject::ProcessEvent
EXTRN	?ProcessState@UObject@@UAEXM@Z:NEAR		; UObject::ProcessState
EXTRN	?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z:NEAR ; UObject::ProcessRemoteFunction
EXTRN	?Modify@UObject@@UAEXXZ:NEAR			; UObject::Modify
EXTRN	?GotoLabel@UObject@@UAEHVFName@@@Z:NEAR		; UObject::GotoLabel
EXTRN	?InitExecution@UObject@@UAEXXZ:NEAR		; UObject::InitExecution
EXTRN	?ShutdownAfterError@UObject@@UAEXXZ:NEAR	; UObject::ShutdownAfterError
EXTRN	?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z:NEAR ; UObject::CallFunction
EXTRN	?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z:NEAR ; UObject::ScriptConsoleExec
EXTRN	?Register@UObject@@UAEXXZ:NEAR			; UObject::Register
EXTRN	?LanguageChange@UObject@@UAEXXZ:NEAR		; UObject::LanguageChange
;	COMDAT ??_7UFractalTexture@@6B@
CONST	SEGMENT
??_7UFractalTexture@@6B@ DD FLAT:??_EUFractalTexture@@UAEPAXI@Z ; UFractalTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UFractalTexture@@UAEXXZ
	DD	FLAT:?Destroy@UTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UTexture@@UAEXK@Z
	DD	FLAT:?Init@UFractalTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UFractalTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0UFractalTexture@@QAE@XZ
_TEXT	SEGMENT
??0UFractalTexture@@QAE@XZ PROC NEAR			; UFractalTexture::UFractalTexture, COMDAT
; _this$ = ecx

; 3876 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ

; 3877 : 	// Mark the texture as parametric (so bitmap is not saved).
; 3878 : 	// Mark the texture as realtime   (so it is regenerated each tick).
; 3879 : 	bParametric = 1;
; 3880 : 	bRealtime   = 1;

  00009	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0000f	83 c8 0c	 or	 eax, 12			; 0000000cH
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00018	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax

; 3881 : 
; 3882 : 	InitTables(); // Global LUTS, checks itself to see if already initzed.

  0001e	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables

; 3883 : 
; 3884 : 	DrawPhase  =0;

  00023	33 c0		 xor	 eax, eax
  00025	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al

; 3885 : 	AuxPhase   =0;

  0002b	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al

; 3886 :     GlobalPhase=0;

  00031	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax

; 3887 : }

  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi
  0003a	c3		 ret	 0
??0UFractalTexture@@QAE@XZ ENDP				; UFractalTexture::UFractalTexture
_TEXT	ENDS
PUBLIC	??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
PUBLIC	??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ ; `string'
PUBLIC	??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
EXTRN	__imp_?Init@UTexture@@UAEXHH@Z:NEAR
EXTRN	__imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z:NEAR
EXTRN	__imp_?appStricmp@@YAHPBG0@Z:NEAR
EXTRN	__imp_?PrivateStaticClass@UClass@@0V1@A:BYTE
EXTRN	__imp_?Logf@FOutputDevice@@QAAXPBGZZ:NEAR
EXTRN	__imp_?PrivateStaticClass@UProperty@@0VUClass@@A:BYTE
EXTRN	__imp_?GError@@3PAVFOutputDeviceError@@A:DWORD
EXTRN	__imp_?appFailAssert@@YAXPBD0H@Z:NEAR
;	COMDAT ??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnClass.h
_DATA	SEGMENT
??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'r', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'a', 00H, 'l', 00H
	DB	'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@
_DATA	SEGMENT
??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ DB 'U', 00H, 'M', 00H, 'a'
	DB	00H, 's', 00H, 'k', 00H, 00H, 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@
_DATA	SEGMENT
??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ DB 'C'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'b', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'm', 00H, ':'
	DB	00H, ' ', 00H, 'S', 00H, 'c', 00H, 'r', 00H, 'i', 00H, 'p', 00H
	DB	't', 00H, '=', 00H, '%', 00H, 'i', 00H, ' ', 00H, 'C', 00H, '+'
	DB	00H, '+', 00H, '=', 00H, '%', 00H, 'i', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@
_DATA	SEGMENT
??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ DB 'D:\DEV\DNF200'
	DB	'1\Stable\Fire\Src\UnFractal.cpp', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT
??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@ DB '(I'
	DB	'nUSize&(InUSize-1))==0', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@
_DATA	SEGMENT
??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@ DB '(I'
	DB	'nVSize&(InVSize-1))==0', 00H		; `string'
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?Init@UFractalTexture@@UAEXHH@Z
_TEXT	SEGMENT
_InUSize$ = 8
_InVSize$ = 12
_this$ = -4
?Init@UFractalTexture@@UAEXHH@Z PROC NEAR		; UFractalTexture::Init, COMDAT
; _this$ = ecx

; 3891 : {

  00000	51		 push	 ecx

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

  00001	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UFractalTexture@@0VUClass@@A+24
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	6a 00		 push	 0
  0000b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00016	50		 push	 eax
  00017	89 4c 24 1c	 mov	 DWORD PTR _this$[esp+32], ecx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  00021	8b f8		 mov	 edi, eax
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	85 ff		 test	 edi, edi
  00028	74 05		 je	 SHORT $L119122
  0002a	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  0002d	eb 02		 jmp	 SHORT $L119123
$L119122:
  0002f	33 f6		 xor	 esi, esi
$L119123:
  00031	85 ff		 test	 edi, edi
  00033	74 41		 je	 SHORT $L119215
$L119135:
  00035	85 f6		 test	 esi, esi
  00037	74 2b		 je	 SHORT $L119138
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 3900 : }

  0003f	90		 npad	 1

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L119137:
  00040	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00043	85 c0		 test	 eax, eax
  00045	74 0b		 je	 SHORT $L119131
$L119129:
  00047	3b c1		 cmp	 eax, ecx
  00049	74 2b		 je	 SHORT $L119215
  0004b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0004e	85 c0		 test	 eax, eax
  00050	75 f5		 jne	 SHORT $L119129
$L119131:
  00052	33 c0		 xor	 eax, eax
  00054	85 c9		 test	 ecx, ecx
  00056	0f 94 c0	 sete	 al
  00059	85 c0		 test	 eax, eax
  0005b	75 19		 jne	 SHORT $L119215
  0005d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00060	85 f6		 test	 esi, esi
  00062	75 dc		 jne	 SHORT $L119137
$L119138:
  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	8b cf		 mov	 ecx, edi
  00068	ff 52 5c	 call	 DWORD PTR [edx+92]
  0006b	8b f8		 mov	 edi, eax
  0006d	85 ff		 test	 edi, edi
  0006f	74 05		 je	 SHORT $L119215
  00071	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00074	eb bf		 jmp	 SHORT $L119135
$L119215:
  00076	85 f6		 test	 esi, esi
  00078	0f 84 b1 00 00
	00		 je	 $L109565
  0007e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
  00084	55		 push	 ebp
  00085	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?appStricmp@@YAHPBG0@Z

; 3900 : }

  0008b	90 8d 64 24 00	 npad	 5

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L119192:
  00090	8b 06		 mov	 eax, DWORD PTR [esi]
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
  00097	8b ce		 mov	 ecx, esi
  00099	ff 50 44	 call	 DWORD PTR [eax+68]
  0009c	50		 push	 eax
  0009d	ff d5		 call	 ebp
  0009f	83 c4 08	 add	 esp, 8
  000a2	85 c0		 test	 eax, eax
  000a4	75 2d		 jne	 SHORT $L109564
  000a6	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000a9	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  000ae	74 23		 je	 SHORT $L109564
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b8	68 c8 00 00 00	 push	 200			; 000000c8H
  000bd	50		 push	 eax
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@BHOC@?$AAU?$AAM?$AAa?$AAs?$AAk?$AA?$AA@ ; `string'
  000c3	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BO@JBP@?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000cd	52		 push	 edx
  000ce	ff d3		 call	 ebx
  000d0	83 c4 18	 add	 esp, 24			; 00000018H
$L109564:
  000d3	85 ff		 test	 edi, edi
  000d5	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000d8	74 4c		 je	 SHORT $L119217

; 3900 : }

  000da	8d 9b 00 00 00
	00		 npad	 6

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L119186:
  000e0	85 f6		 test	 esi, esi
  000e2	74 30		 je	 SHORT $L119189
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 3900 : }

  000ea	8d 9b 00 00 00
	00		 npad	 6

; 3892 : 	VERIFY_CLASS_OFFSET(U,FractalTexture,UMask); // verifies correct mirroring..

$L119188:
  000f0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000f3	85 c0		 test	 eax, eax
  000f5	74 0b		 je	 SHORT $L119182
$L119180:
  000f7	3b c1		 cmp	 eax, ecx
  000f9	74 2b		 je	 SHORT $L119217
  000fb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000fe	85 c0		 test	 eax, eax
  00100	75 f5		 jne	 SHORT $L119180
$L119182:
  00102	33 c0		 xor	 eax, eax
  00104	85 c9		 test	 ecx, ecx
  00106	0f 94 c0	 sete	 al
  00109	85 c0		 test	 eax, eax
  0010b	75 19		 jne	 SHORT $L119217
  0010d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00110	85 f6		 test	 esi, esi
  00112	75 dc		 jne	 SHORT $L119188
$L119189:
  00114	8b 07		 mov	 eax, DWORD PTR [edi]
  00116	8b cf		 mov	 ecx, edi
  00118	ff 50 5c	 call	 DWORD PTR [eax+92]
  0011b	8b f8		 mov	 edi, eax
  0011d	85 ff		 test	 edi, edi
  0011f	74 05		 je	 SHORT $L119217
  00121	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00124	eb ba		 jmp	 SHORT $L119186
$L119217:
  00126	85 f6		 test	 esi, esi
  00128	0f 85 62 ff ff
	ff		 jne	 $L119192
  0012e	5d		 pop	 ebp
$L109565:

; 3893 : 
; 3894 : 	// Proper-powers-of-two verification.
; 3895 : 	check((InUSize&(InUSize-1))==0); 

  0012f	8b 74 24 14	 mov	 esi, DWORD PTR _InUSize$[esp+12]
  00133	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00139	8d 4e ff	 lea	 ecx, DWORD PTR [esi-1]
  0013c	85 ce		 test	 ecx, esi
  0013e	74 14		 je	 SHORT $L109574
  00140	68 37 0f 00 00	 push	 3895			; 00000f37H
  00145	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ ; `string'
  0014a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@LFBK@?$CIInUSize?$CG?$CIInUSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
  0014f	ff d3		 call	 ebx
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH
$L109574:

; 3896 : 	check((InVSize&(InVSize-1))==0);

  00154	8b 7c 24 18	 mov	 edi, DWORD PTR _InVSize$[esp+12]
  00158	8d 57 ff	 lea	 edx, DWORD PTR [edi-1]
  0015b	85 d7		 test	 edx, edi
  0015d	74 14		 je	 SHORT $L109577
  0015f	68 38 0f 00 00	 push	 3896			; 00000f38H
  00164	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ ; `string'
  00169	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BJ@LDOB@?$CIInVSize?$CG?$CIInVSize?91?$CJ?$CJ?$DN?$DN0?$AA@ ; `string'
  0016e	ff d3		 call	 ebx
  00170	83 c4 0c	 add	 esp, 12			; 0000000cH
$L109577:

; 3897 : 
; 3898 : 	// Init base class.
; 3899 : 	UTexture::Init( InUSize, InVSize );

  00173	8b 4c 24 0c	 mov	 ecx, DWORD PTR _this$[esp+16]
  00177	57		 push	 edi
  00178	56		 push	 esi
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Init@UTexture@@UAEXHH@Z
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx

; 3900 : }

  00182	59		 pop	 ecx
  00183	c2 08 00	 ret	 8
?Init@UFractalTexture@@UAEXHH@Z ENDP			; UFractalTexture::Init
_TEXT	ENDS
EXTRN	__imp_?PostLoad@UTexture@@UAEXXZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ?PostLoad@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT
?PostLoad@UFractalTexture@@UAEXXZ PROC NEAR		; UFractalTexture::PostLoad, COMDAT
; _this$ = ecx

; 3904 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 3905 : 	Super::PostLoad();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ

; 3906 : 
; 3907 : 	UMask = USize - 1;

  00009	8b 46 34	 mov	 eax, DWORD PTR [esi+52]

; 3908 : 	VMask = VSize - 1;

  0000c	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0000f	48		 dec	 eax
  00010	49		 dec	 ecx
  00011	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00017	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  0001d	5e		 pop	 esi

; 3909 : }

  0001e	c3		 ret	 0
?PostLoad@UFractalTexture@@UAEXXZ ENDP			; UFractalTexture::PostLoad
_TEXT	ENDS
PUBLIC	??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
EXTRN	__imp_?StaticConstructor@UObject@@QAEXXZ:NEAR
EXTRN	_atexit:NEAR
EXTRN	__imp_?PrivateStaticClass@UObject@@0VUClass@@A:BYTE
EXTRN	__imp_?PrivateStaticClass@UProceduralTexture@@0VUClass@@A:BYTE
EXTRN	__imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z:NEAR
EXTRN	__imp_?InternalConstructor@UTexture@@SAXPAX@Z:NEAR
;	COMDAT ??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@
_DATA	SEGMENT
??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ DB 'S', 00H, 'y', 00H
	DB	's', 00H, 't', 00H, 'e', 00H, 'm', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'F', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E188
_TEXT	SEGMENT
_$E188	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	89 45 00	 mov	 DWORD PTR [ebp], eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?InternalConstructor@UTexture@@SAXPAX@Z
  00016	50		 push	 eax
  00017	68 04 40 08 04	 push	 67649540		; 04084004H
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  00021	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00026	33 c9		 xor	 ecx, ecx
  00028	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002b	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1CA@OMBM@?$AAU?$AAF?$AAr?$AAa?$AAc?$AAt?$AAa?$AAl?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  00030	83 ec 10	 sub	 esp, 16			; 00000010H
  00033	8b cc		 mov	 ecx, esp
  00035	33 d2		 xor	 edx, edx
  00037	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 ff		 xor	 edi, edi
  00047	89 39		 mov	 DWORD PTR [ecx], edi
  00049	33 db		 xor	 ebx, ebx
  0004b	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  0004e	33 c0		 xor	 eax, eax
  00050	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00053	52		 push	 edx
  00054	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UProceduralTexture@@0VUClass@@A
  0005c	50		 push	 eax
  0005d	6a 01		 push	 1
  0005f	68 e0 00 00 00	 push	 224			; 000000e0H
  00064	53		 push	 ebx
  00065	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  00070	68 00 00 00 00	 push	 OFFSET FLAT:_$E185
  00075	e8 00 00 00 00	 call	 _atexit
  0007a	83 c4 04	 add	 esp, 4
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5d		 pop	 ebp
  00080	5b		 pop	 ebx
  00081	c3		 ret	 0
_$E188	ENDP
_TEXT	ENDS
EXTRN	__imp_??1UClass@@UAE@XZ:NEAR
_BSS	SEGMENT
_$S186	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E185
_TEXT	SEGMENT
_$E185	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S186
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L109594
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S186, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L109594:
  0001f	c3		 ret	 0
_$E185	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E191
_TEXT	SEGMENT
_$E191	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUFractalTexture, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E191	ENDP
_TEXT	ENDS
PUBLIC	??0UFireTexture@@QAE@XZ				; UFireTexture::UFireTexture
PUBLIC	?PostLoad@UFireTexture@@UAEXXZ			; UFireTexture::PostLoad
PUBLIC	?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z	; UFireTexture::Serialize
PUBLIC	?Init@UFireTexture@@UAEXHH@Z			; UFireTexture::Init
PUBLIC	?Clear@UFireTexture@@UAEXK@Z			; UFireTexture::Clear
PUBLIC	?ConstantTimeTick@UFireTexture@@UAEXXZ		; UFireTexture::ConstantTimeTick
PUBLIC	?MousePosition@UFireTexture@@UAEXKMM@Z		; UFireTexture::MousePosition
PUBLIC	?Click@UFireTexture@@UAEXKMM@Z			; UFireTexture::Click
PUBLIC	?TouchTexture@UFireTexture@@UAEXHHM@Z		; UFireTexture::TouchTexture
PUBLIC	??_7UFireTexture@@6B@				; UFireTexture::`vftable'
PUBLIC	??_EUFireTexture@@UAEPAXI@Z			; UFireTexture::`vector deleting destructor'
;	COMDAT ??_7UFireTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UFireTexture@@6B@ DD FLAT:??_EUFireTexture@@UAEPAXI@Z ; UFireTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UFireTexture@@UAEXXZ
	DD	FLAT:?Destroy@UTexture@@UAEXXZ
	DD	FLAT:?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UFireTexture@@UAEXK@Z
	DD	FLAT:?Init@UFireTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UFireTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UFireTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UFireTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UFireTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UFireTexture@@QAE@XZ
_TEXT	SEGMENT
??0UFireTexture@@QAE@XZ PROC NEAR			; UFireTexture::UFireTexture, COMDAT
; _this$ = ecx

; 3921 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  00009	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0000f	83 c8 0c	 or	 eax, 12			; 0000000cH
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00018	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0001e	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00023	33 c0		 xor	 eax, eax
  00025	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  0002b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00031	89 86 fc 00 00
	00		 mov	 DWORD PTR [esi+252], eax
  00037	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  0003d	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax

; 3922 :     // Init all non-serialized variables. 
; 3923 : 
; 3924 : 	OldRenderHeat  =  -1; 
; 3925 : 	AuxPhase       =   0;

  00043	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  00049	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFireTexture@@6B@ ; UFireTexture::`vftable'
  0004f	c7 86 08 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+264], -1

; 3926 : 	StarStatus	   =   1; // Assume some stars until, we find otherwise.

  00059	c6 86 10 05 00
	00 01		 mov	 BYTE PTR [esi+1296], 1

; 3927 : 
; 3928 : 	// initialize the routines we should call for rising/nonrising fire;
; 3929 : 	// one for Pentium/MMX es and one for Ppro/PII's
; 3930 : 
; 3931 : 	//void (*MergePass)( INT Y, INT X, INT InnerX );
; 3932 : 
; 3933 : }

  00060	8b c6		 mov	 eax, esi
  00062	5e		 pop	 esi
  00063	c3		 ret	 0
??0UFireTexture@@QAE@XZ ENDP				; UFireTexture::UFireTexture
_TEXT	ENDS
PUBLIC	??_SUPalette@@6B@				; UPalette::`local vftable'
PUBLIC	??_GUPalette@@UAEPAXI@Z				; UPalette::`scalar deleting destructor'
PUBLIC	??_EUPalette@@UAEPAXI@Z				; UPalette::`vector deleting destructor'
PUBLIC	??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
EXTRN	__imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z:NEAR
EXTRN	?Serialize@UPalette@@UAEXAAVFArchive@@@Z:NEAR	; UPalette::Serialize
EXTRN	__imp_?GetOuter@UObject@@QBEPAV1@XZ:NEAR
EXTRN	__imp_?Realloc@FArray@@IAEXH@Z:NEAR
EXTRN	__imp_?PrivateStaticClass@UPalette@@0VUClass@@A:BYTE
EXTRN	__imp_??0UPalette@@QAE@XZ:NEAR
EXTRN	__imp_??0FName@@QAE@W4EName@@@Z:NEAR
EXTRN	?PostLoad@UObject@@UAEXXZ:NEAR			; UObject::PostLoad
EXTRN	?Destroy@UObject@@UAEXXZ:NEAR			; UObject::Destroy
EXTRN	?PostEditChange@UObject@@UAEXXZ:NEAR		; UObject::PostEditChange
;	COMDAT ??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnFile.h
_DATA	SEGMENT
??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'F'
	DB	00H, 'i', 00H, 'r', 00H, 'e', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'S'
	DB	00H, 'p', 00H, 'a', 00H, 'r', 00H, 'k', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H			; `string'
_DATA	ENDS
;	COMDAT ??_SUPalette@@6B@
CONST	SEGMENT
??_SUPalette@@6B@ DD FLAT:??_EUPalette@@UAEPAXI@Z	; UPalette::`local vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UObject@@UAEXXZ
	DD	FLAT:?Destroy@UObject@@UAEXXZ
	DD	FLAT:?Serialize@UPalette@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UObject@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?Init@UFireTexture@@UAEXHH@Z
_TEXT	SEGMENT
$T119452 = 12
_InUSize$ = 8
_InVSize$ = 12
_this$ = -4
?Init@UFireTexture@@UAEXHH@Z PROC NEAR			; UFireTexture::Init, COMDAT
; _this$ = ecx

; 3940 : {

  00000	51		 push	 ecx

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

  00001	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UFireTexture@@0VUClass@@A+24
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  00011	50		 push	 eax
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00017	8b f9		 mov	 edi, ecx
  00019	50		 push	 eax
  0001a	89 7c 24 20	 mov	 DWORD PTR _this$[esp+36], edi
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  00024	8b d8		 mov	 ebx, eax
  00026	83 c4 10	 add	 esp, 16			; 00000010H
  00029	85 db		 test	 ebx, ebx
  0002b	74 05		 je	 SHORT $L119358
  0002d	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00030	eb 02		 jmp	 SHORT $L119359
$L119358:
  00032	33 f6		 xor	 esi, esi
$L119359:
  00034	85 db		 test	 ebx, ebx
  00036	74 47		 je	 SHORT $L119520
$L119371:
  00038	85 f6		 test	 esi, esi
  0003a	74 31		 je	 SHORT $L119374
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A
$L119373:
  00042	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00045	85 c0		 test	 eax, eax
  00047	74 12		 je	 SHORT $L119367

; 3969 : }

  00049	8d a4 24 00 00
	00 00		 npad	 7

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

$L119365:
  00050	3b c1		 cmp	 eax, ecx
  00052	74 2b		 je	 SHORT $L119520
  00054	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00057	85 c0		 test	 eax, eax
  00059	75 f5		 jne	 SHORT $L119365
$L119367:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c9		 test	 ecx, ecx
  0005f	0f 94 c0	 sete	 al
  00062	85 c0		 test	 eax, eax
  00064	75 19		 jne	 SHORT $L119520
  00066	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00069	85 f6		 test	 esi, esi
  0006b	75 d5		 jne	 SHORT $L119373
$L119374:
  0006d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0006f	8b cb		 mov	 ecx, ebx
  00071	ff 52 5c	 call	 DWORD PTR [edx+92]
  00074	8b d8		 mov	 ebx, eax
  00076	85 db		 test	 ebx, ebx
  00078	74 05		 je	 SHORT $L119520
  0007a	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  0007d	eb b9		 jmp	 SHORT $L119371
$L119520:
  0007f	85 f6		 test	 esi, esi
  00081	0f 84 ab 00 00
	00		 je	 $L109628
  00087	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?appStricmp@@YAHPBG0@Z
  0008d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
$L119428:
  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  0009a	8b ce		 mov	 ecx, esi
  0009c	ff 50 44	 call	 DWORD PTR [eax+68]
  0009f	50		 push	 eax
  000a0	ff d7		 call	 edi
  000a2	83 c4 08	 add	 esp, 8
  000a5	85 c0		 test	 eax, eax
  000a7	75 2d		 jne	 SHORT $L109627
  000a9	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000ac	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  000b1	74 23		 je	 SHORT $L109627
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	68 e0 00 00 00	 push	 224			; 000000e0H
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BE@GEFN@?$AAS?$AAp?$AAa?$AAr?$AAk?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  000c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@MMMC@?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000d0	52		 push	 edx
  000d1	ff d5		 call	 ebp
  000d3	83 c4 18	 add	 esp, 24			; 00000018H
$L109627:
  000d6	85 db		 test	 ebx, ebx
  000d8	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000db	74 49		 je	 SHORT $L119522

; 3969 : }

  000dd	8d 49 00	 npad	 3

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

$L119422:
  000e0	85 f6		 test	 esi, esi
  000e2	74 30		 je	 SHORT $L119425
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 3969 : }

  000ea	8d 9b 00 00 00
	00		 npad	 6

; 3941 : 	VERIFY_CLASS_OFFSET(U,FireTexture,SparkType);

$L119424:
  000f0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000f3	85 c0		 test	 eax, eax
  000f5	74 0b		 je	 SHORT $L119418
$L119416:
  000f7	3b c1		 cmp	 eax, ecx
  000f9	74 2b		 je	 SHORT $L119522
  000fb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000fe	85 c0		 test	 eax, eax
  00100	75 f5		 jne	 SHORT $L119416
$L119418:
  00102	33 c0		 xor	 eax, eax
  00104	85 c9		 test	 ecx, ecx
  00106	0f 94 c0	 sete	 al
  00109	85 c0		 test	 eax, eax
  0010b	75 19		 jne	 SHORT $L119522
  0010d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00110	85 f6		 test	 esi, esi
  00112	75 dc		 jne	 SHORT $L119424
$L119425:
  00114	8b 03		 mov	 eax, DWORD PTR [ebx]
  00116	8b cb		 mov	 ecx, ebx
  00118	ff 50 5c	 call	 DWORD PTR [eax+92]
  0011b	8b d8		 mov	 ebx, eax
  0011d	85 db		 test	 ebx, ebx
  0011f	74 05		 je	 SHORT $L119522
  00121	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00124	eb ba		 jmp	 SHORT $L119422
$L119522:
  00126	85 f6		 test	 esi, esi
  00128	0f 85 65 ff ff
	ff		 jne	 $L119428
  0012e	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
$L109628:

; 3942 : 
; 3943 : 	// Init base class.
; 3944 : 	UFractalTexture::Init( InUSize, InVSize );

  00132	8b 4c 24 1c	 mov	 ecx, DWORD PTR _InVSize$[esp+16]
  00136	8b 54 24 18	 mov	 edx, DWORD PTR _InUSize$[esp+16]
  0013a	51		 push	 ecx
  0013b	52		 push	 edx
  0013c	8b cf		 mov	 ecx, edi
  0013e	e8 00 00 00 00	 call	 ?Init@UFractalTexture@@UAEXHH@Z ; UFractalTexture::Init

; 3945 : 
; 3946 : 	// Create a custom palette.
; 3947 : 	Palette = new( GetOuter() )UPalette;

  00143	6a 00		 push	 0
  00145	8d 4c 24 20	 lea	 ecx, DWORD PTR $T119452[esp+20]
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  0014f	8b cf		 mov	 ecx, edi
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  0015d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015f	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T119452[esp+16]
  00163	6a 00		 push	 0
  00165	52		 push	 edx
  00166	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  0016c	6a 00		 push	 0
  0016e	6a 00		 push	 0
  00170	51		 push	 ecx
  00171	50		 push	 eax
  00172	52		 push	 edx
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00179	8b f0		 mov	 esi, eax
  0017b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0017e	85 f6		 test	 esi, esi
  00180	74 10		 je	 SHORT $L119304
  00182	8b ce		 mov	 ecx, esi
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  0018a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  00190	eb 02		 jmp	 SHORT $L119305
$L119304:
  00192	33 f6		 xor	 esi, esi
$L119305:

; 3948 : 	for( INT i=0; i<256; i++ )

  00194	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  0019a	89 77 2c	 mov	 DWORD PTR [edi+44], esi
  0019d	33 db		 xor	 ebx, ebx

; 3969 : }

  0019f	90		 npad	 1

; 3948 : 	for( INT i=0; i<256; i++ )

$L109644:

; 3949 : 		new(Palette->Colors)FColor(i,i,0);

  001a0	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  001a3	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  001a6	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001a9	83 c6 28	 add	 esi, 40			; 00000028H
  001ac	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  001af	3b c8		 cmp	 ecx, eax
  001b1	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  001b4	7e 19		 jle	 SHORT $L119469
  001b6	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  001b9	99		 cdq
  001ba	83 e2 07	 and	 edx, 7
  001bd	03 c2		 add	 eax, edx
  001bf	c1 f8 03	 sar	 eax, 3
  001c2	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  001c6	6a 04		 push	 4
  001c8	8b ce		 mov	 ecx, esi
  001ca	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001cd	ff d5		 call	 ebp
$L119469:
  001cf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001d1	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]
  001d4	85 c0		 test	 eax, eax
  001d6	74 09		 je	 SHORT $L109645
  001d8	88 18		 mov	 BYTE PTR [eax], bl
  001da	88 58 01	 mov	 BYTE PTR [eax+1], bl
  001dd	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$L109645:

; 3950 : 	BlueLagunaPalette(Palette);

  001e1	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
  001e5	43		 inc	 ebx
  001e6	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  001ec	7c b2		 jl	 SHORT $L109644
  001ee	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  001f1	52		 push	 edx
  001f2	e8 00 00 00 00	 call	 ?BlueLagunaPalette@@YAXPAVUPalette@@@Z ; BlueLagunaPalette

; 3951 : 	MipZero    = Palette->Colors(128);

  001f7	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  001fa	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001fd	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]

; 3952 : 
; 3953 : 	// initialize all to-be-serialized variables
; 3954 :     RenderHeat  = 220;
; 3955 : 	ActiveSparkNum   =   0;
; 3956 :     SparkType   = SPARK_Blaze;
; 3957 : 	SparksLimit = MAXSPARKSINIT; // inital maximum

  00203	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H
  00208	89 57 44	 mov	 DWORD PTR [edi+68], edx

; 3958 : 
; 3959 : 	//Allocate SparksLimit sparks:
; 3960 : 	Sparks.Add(SparksLimit);

  0020b	8d 8f fc 00 00
	00		 lea	 ecx, DWORD PTR [edi+252]
  00211	c6 87 e1 00 00
	00 dc		 mov	 BYTE PTR [edi+225], 220	; 000000dcH
  00218	c7 87 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edi+248], 0
  00222	c6 87 e0 00 00
	00 04		 mov	 BYTE PTR [edi+224], 4
  00229	89 87 f4 00 00
	00		 mov	 DWORD PTR [edi+244], eax
  0022f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00232	03 d0		 add	 edx, eax
  00234	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00237	8b f2		 mov	 esi, edx
  00239	83 c4 04	 add	 esp, 4
  0023c	3b f0		 cmp	 esi, eax
  0023e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00241	7e 17		 jle	 SHORT $L119504
  00243	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00246	99		 cdq
  00247	83 e2 07	 and	 edx, 7
  0024a	03 c2		 add	 eax, edx
  0024c	c1 f8 03	 sar	 eax, 3
  0024f	8d 44 30 20	 lea	 eax, DWORD PTR [eax+esi+32]
  00253	6a 08		 push	 8
  00255	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00258	ff d5		 call	 ebp
$L119504:

; 3961 : 
; 3962 : 	FX_Frequency  =  16;

  0025a	b0 10		 mov	 al, 16			; 00000010H
  0025c	88 87 ec 00 00
	00		 mov	 BYTE PTR [edi+236], al

; 3963 : 	FX_Phase	  =  16;

  00262	88 87 ed 00 00
	00		 mov	 BYTE PTR [edi+237], al

; 3964 : 	FX_Heat		  = 255;

  00268	c6 87 e8 00 00
	00 ff		 mov	 BYTE PTR [edi+232], 255	; 000000ffH

; 3965 : 	FX_Size		  =  96;

  0026f	c6 87 e9 00 00
	00 60		 mov	 BYTE PTR [edi+233], 96	; 00000060H

; 3966 : 	FX_Area		  =  24;

  00276	c6 87 eb 00 00
	00 18		 mov	 BYTE PTR [edi+235], 24	; 00000018H

; 3967 : 	FX_HorizSpeed = 130;

  0027d	c6 87 ee 00 00
	00 82		 mov	 BYTE PTR [edi+238], 130	; 00000082H

; 3968 : 	FX_VertSpeed  = 142;

  00284	c6 87 ef 00 00
	00 8e		 mov	 BYTE PTR [edi+239], 142	; 0000008eH
  0028b	5f		 pop	 edi
  0028c	5e		 pop	 esi
  0028d	5d		 pop	 ebp
  0028e	5b		 pop	 ebx

; 3969 : }

  0028f	59		 pop	 ecx
  00290	c2 08 00	 ret	 8
?Init@UFireTexture@@UAEXHH@Z ENDP			; UFireTexture::Init
_TEXT	ENDS
EXTRN	__imp_?Clear@UTexture@@UAEXK@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Clear@UFireTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UFireTexture@@UAEXK@Z PROC NEAR			; UFireTexture::Clear, COMDAT
; _this$ = ecx

; 3972 : {

  00000	53		 push	 ebx

; 3973 : 	// Init to zero.
; 3974 : 	UFractalTexture::Clear( ClearFlags );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _ClearFlags$[esp]
  00005	56		 push	 esi
  00006	53		 push	 ebx
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z

; 3975 : 
; 3976 : 	// Clear sparks.
; 3977 : 	if( ClearFlags & TCLEAR_Temporal )

  0000f	f6 c3 01	 test	 bl, 1
  00012	74 0e		 je	 SHORT $L109660

; 3978 : 	{
; 3979 : 		ActiveSparkNum=0;

  00014	33 c0		 xor	 eax, eax
  00016	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax

; 3980 : 		StarStatus=0;

  0001c	88 86 10 05 00
	00		 mov	 BYTE PTR [esi+1296], al
$L109660:
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx

; 3981 : 	}
; 3982 : }

  00024	c2 04 00	 ret	 4
?Clear@UFireTexture@@UAEXK@Z ENDP			; UFireTexture::Clear
_TEXT	ENDS
PUBLIC	??_C@_08GCAE@Index?$DO?$DN0?$AA@		; `string'
PUBLIC	??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@	; `string'
PUBLIC	??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
PUBLIC	??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fb0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@ ; `string'
PUBLIC	??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@ ; `string'
PUBLIC	??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@ ; `string'
PUBLIC	??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@ ; `string'
EXTRN	__imp_?Flush@FMemCache@@QAEX_KKH@Z:NEAR
EXTRN	__imp_?GCache@@3VFMemCache@@A:BYTE
EXTRN	__imp_?Remove@FArray@@QAEXHHH@Z:NEAR
EXTRN	__imp_?ReplaceWithExisting@UPalette@@QAEPAV1@XZ:NEAR
EXTRN	__imp_??0FName@@QAE@PBGW4EFindName@@@Z:NEAR
EXTRN	__ftol:NEAR
;	COMDAT ??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@
; File ..\..\Core\Inc\UnFile.h
_DATA	SEGMENT
??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@ DB 'sizeof(U'
	DB	'FireTexture)==UFireTexture::StaticClass()->GetPropertiesSize('
	DB	')', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@
_DATA	SEGMENT
??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@ DB 'sizeof(U'
	DB	'WetTexture)==UWetTexture::StaticClass()->GetPropertiesSize()', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@
_DATA	SEGMENT
??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@ DB 'sizeof(U'
	DB	'WaveTexture)==UWaveTexture::StaticClass()->GetPropertiesSize('
	DB	')', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@
_DATA	SEGMENT
??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@ DB 'sizeof(U'
	DB	'FractalTexture)==UFractalTexture::StaticClass()->GetPropertie'
	DB	'sSize()', 00H				; `string'
_DATA	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fb0000000000000
CONST	SEGMENT
__real@3fb0000000000000 DQ 03fb0000000000000r	; 0.0625
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT ??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@
_DATA	SEGMENT
??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ DB '..\..\Core\I'
	DB	'nc\UnTemplate.h', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GCAE@Index?$DO?$DN0?$AA@
_DATA	SEGMENT
??_C@_08GCAE@Index?$DO?$DN0?$AA@ DB 'Index>=0', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT
??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ DB 'Index<=ArrayNum', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@
_DATA	SEGMENT
??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ DB 'Index+Count<=Array'
	DB	'Num', 00H					; `string'
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?PostLoad@UFireTexture@@UAEXXZ
_TEXT	SEGMENT
$T119576 = -4
_NewPalette$109677 = -8
_T$109698 = -8
?PostLoad@UFireTexture@@UAEXXZ PROC NEAR		; UFireTexture::PostLoad, COMDAT
; _this$ = ecx

; 3986 : 	VERIFY_CLASS_SIZE(UFireTexture);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UFireTexture@@0VUClass@@A
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  00013	ff 50 58	 call	 DWORD PTR [eax+88]
  00016	3d 14 05 00 00	 cmp	 eax, 1300		; 00000514H
  0001b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00021	74 14		 je	 SHORT $L109665
  00023	68 92 0f 00 00	 push	 3986			; 00000f92H
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ ; `string'
  0002d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@ILJB@sizeof?$CIUFireTexture?$CJ?$DN?$DNUFireTextu@ ; `string'
  00032	ff d7		 call	 edi
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
$L109665:

; 3987 : 	VERIFY_CLASS_SIZE(UWetTexture);

  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PrivateStaticClass@UWetTexture@@0VUClass@@A
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  00042	ff 52 58	 call	 DWORD PTR [edx+88]
  00045	3d 0c 13 00 00	 cmp	 eax, 4876		; 0000130cH
  0004a	74 14		 je	 SHORT $L109668
  0004c	68 93 0f 00 00	 push	 3987			; 00000f93H
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ ; `string'
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EF@LBFJ@sizeof?$CIUWetTexture?$CJ?$DN?$DNUWetTexture@ ; `string'
  0005b	ff d7		 call	 edi
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$L109668:

; 3988 : 	VERIFY_CLASS_SIZE(UWaveTexture);

  00060	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UWaveTexture@@0VUClass@@A
  00065	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  0006a	ff 50 58	 call	 DWORD PTR [eax+88]
  0006d	3d 04 13 00 00	 cmp	 eax, 4868		; 00001304H
  00072	74 14		 je	 SHORT $L109671
  00074	68 94 0f 00 00	 push	 3988			; 00000f94H
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ ; `string'
  0007e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EH@HCKF@sizeof?$CIUWaveTexture?$CJ?$DN?$DNUWaveTextu@ ; `string'
  00083	ff d7		 call	 edi
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
$L109671:

; 3989 : 	VERIFY_CLASS_SIZE(UFractalTexture);

  00088	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?PrivateStaticClass@UFractalTexture@@0VUClass@@A
  0008e	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00093	ff 52 58	 call	 DWORD PTR [edx+88]
  00096	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  0009b	74 14		 je	 SHORT $L109674
  0009d	68 95 0f 00 00	 push	 3989			; 00000f95H
  000a2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CN@CLAL@D?3?2DEV?2DNF2001?2Stable?2Fire?2Src?2U@ ; `string'
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0EN@CEKJ@sizeof?$CIUFractalTexture?$CJ?$DN?$DNUFracta@ ; `string'
  000ac	ff d7		 call	 edi
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$L109674:

; 3990 : 
; 3991 : 	// Call base class.
; 3992 : 	Super::PostLoad();

  000b1	8b ce		 mov	 ecx, esi
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  000b9	8b 46 34	 mov	 eax, DWORD PTR [esi+52]

; 3993 : 	PolyFlags &= ~PF_Masked;

  000bc	8b 96 84 00 00
	00		 mov	 edx, DWORD PTR [esi+132]
  000c2	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000c5	48		 dec	 eax
  000c6	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax

; 3994 : 
; 3995 : 	// Make sure the texture has its _own_ copy of the palette.
; 3996 : #if COPYPALETTE
; 3997 : 	if( ( Palette!=NULL ) && ( GetOuter()!=Palette->GetOuter() ) )

  000cc	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000cf	49		 dec	 ecx
  000d0	83 e2 fd	 and	 edx, -3			; fffffffdH
  000d3	33 ed		 xor	 ebp, ebp
  000d5	3b c5		 cmp	 eax, ebp
  000d7	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  000dd	89 96 84 00 00
	00		 mov	 DWORD PTR [esi+132], edx
  000e3	0f 84 e8 00 00
	00		 je	 $L109676
  000e9	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  000ec	3b 50 18	 cmp	 edx, DWORD PTR [eax+24]
  000ef	0f 84 dc 00 00
	00		 je	 $L109676

; 3998 : 	{
; 3999 : 		UPalette* NewPalette = new( GetOuter(), GetName() )UPalette;

  000f5	8b 06		 mov	 eax, DWORD PTR [esi]
  000f7	6a 01		 push	 1
  000f9	8b ce		 mov	 ecx, esi
  000fb	ff 50 44	 call	 DWORD PTR [eax+68]
  000fe	50		 push	 eax
  000ff	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T119576[esp+32]
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@PBGW4EFindName@@@Z
  00109	8b ce		 mov	 ecx, esi
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00117	8b 11		 mov	 edx, DWORD PTR [ecx]
  00119	8b 4c 24 14	 mov	 ecx, DWORD PTR $T119576[esp+24]
  0011d	55		 push	 ebp
  0011e	52		 push	 edx
  0011f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00125	55		 push	 ebp
  00126	55		 push	 ebp
  00127	51		 push	 ecx
  00128	50		 push	 eax
  00129	52		 push	 edx
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00130	8b f8		 mov	 edi, eax
  00132	83 c4 1c	 add	 esp, 28			; 0000001cH
  00135	3b fd		 cmp	 edi, ebp
  00137	74 14		 je	 SHORT $L119540
  00139	8b cf		 mov	 ecx, edi
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  00141	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  00147	89 7c 24 10	 mov	 DWORD PTR _NewPalette$109677[esp+24], edi
  0014b	eb 04		 jmp	 SHORT $L119541
$L119540:
  0014d	89 6c 24 10	 mov	 DWORD PTR _NewPalette$109677[esp+24], ebp
$L119541:
  00151	8b 44 24 10	 mov	 eax, DWORD PTR _NewPalette$109677[esp+24]
  00155	8d 78 28	 lea	 edi, DWORD PTR [eax+40]
$L109686:

; 4000 : 		//NewPalette->Colors = Palette->Colors;
; 4001 : 		for( INT i=0; i<256; i++ )
; 4002 : 			new(NewPalette->Colors)FColor( Palette->Colors(i) );

  00158	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0015b	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0015e	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00161	3b c8		 cmp	 ecx, eax
  00163	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00166	7e 1d		 jle	 SHORT $L119592
  00168	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0016b	99		 cdq
  0016c	83 e2 07	 and	 edx, 7
  0016f	03 c2		 add	 eax, edx
  00171	c1 f8 03	 sar	 eax, 3
  00174	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00178	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0017b	6a 04		 push	 4
  0017d	8b cf		 mov	 ecx, edi
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L119592:
  00185	8b 17		 mov	 edx, DWORD PTR [edi]
  00187	8d 04 9a	 lea	 eax, DWORD PTR [edx+ebx*4]
  0018a	85 c0		 test	 eax, eax
  0018c	74 0b		 je	 SHORT $L109687
  0018e	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00191	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00194	8b 0c 2a	 mov	 ecx, DWORD PTR [edx+ebp]
  00197	89 08		 mov	 DWORD PTR [eax], ecx
$L109687:
  00199	83 c5 04	 add	 ebp, 4
  0019c	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  001a2	7c b4		 jl	 SHORT $L109686

; 4003 : 		Palette = NewPalette->ReplaceWithExisting();

  001a4	8b 4c 24 10	 mov	 ecx, DWORD PTR _NewPalette$109677[esp+24]
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReplaceWithExisting@UPalette@@QAEPAV1@XZ
  001ae	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 4004 : 		MipZero = Palette->Colors(128);

  001b1	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  001b4	8b 82 00 02 00
	00		 mov	 eax, DWORD PTR [edx+512]

; 4005 : 		GCache.Flush();

  001ba	6a 00		 push	 0
  001bc	6a ff		 push	 -1
  001be	6a 00		 push	 0
  001c0	89 46 44	 mov	 DWORD PTR [esi+68], eax
  001c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
  001c9	6a 00		 push	 0
  001cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Flush@FMemCache@@QAEX_KKH@Z
$L109676:

; 4006 : 	}
; 4007 : #endif
; 4008 : 
; 4009 : 	// Fill the fire table.
; 4010 : 	if( OldRenderHeat != RenderHeat )

  001d1	0f b6 8e e1 00
	00 00		 movzx	 ecx, BYTE PTR [esi+225]
  001d8	39 8e 08 01 00
	00		 cmp	 DWORD PTR [esi+264], ecx
  001de	0f 84 8c 00 00
	00		 je	 $L109697

; 4011 : 	{
; 4012 : 		for( INT T=0; T<1024; T++ )

  001e4	33 ff		 xor	 edi, edi
  001e6	89 7c 24 10	 mov	 DWORD PTR _T$109698[esp+24], edi

; 4055 : 		}
; 4056 : 		//Sparks.Debug(); 
; 4057 : 	}
; 4058 : }

  001ea	8d 9b 00 00 00
	00		 npad	 6

; 4011 : 	{
; 4012 : 		for( INT T=0; T<1024; T++ )

$L109699:

; 4013 : 			RenderTable[T] = (BYTE) Clamp( T/4.0 + 1.0 - (255-RenderHeat)/16.0, 0.0, 255.0 );

  001f0	db 44 24 10	 fild	 DWORD PTR _T$109698[esp+24]
  001f4	0f b6 96 e1 00
	00 00		 movzx	 edx, BYTE PTR [esi+225]
  001fb	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00200	2b c2		 sub	 eax, edx
  00202	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fd0000000000000
  00208	89 44 24 14	 mov	 DWORD PTR -4+[esp+24], eax
  0020c	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00212	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  00216	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fb0000000000000
  0021c	de e9		 fsubp	 ST(1), ST(0)
  0021e	dc 15 00 00 00
	00		 fcom	 QWORD PTR __real@0000000000000000
  00224	df e0		 fnstsw	 ax
  00226	f6 c4 05	 test	 ah, 5
  00229	7a 0a		 jp	 SHORT $L119612
  0022b	dd d8		 fstp	 ST(0)
  0022d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@0000000000000000
  00233	eb 15		 jmp	 SHORT $L119611
$L119612:
  00235	dc 15 00 00 00
	00		 fcom	 QWORD PTR __real@406fe00000000000
  0023b	df e0		 fnstsw	 ax
  0023d	f6 c4 05	 test	 ah, 5
  00240	7b 08		 jnp	 SHORT $L119611
  00242	dd d8		 fstp	 ST(0)
  00244	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@406fe00000000000
$L119611:
  0024a	e8 00 00 00 00	 call	 __ftol
  0024f	88 84 3e 0c 01
	00 00		 mov	 BYTE PTR [esi+edi+268], al
  00256	47		 inc	 edi
  00257	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  0025d	89 7c 24 10	 mov	 DWORD PTR _T$109698[esp+24], edi
  00261	7c 8d		 jl	 SHORT $L109699

; 4014 : 		OldRenderHeat = RenderHeat;

  00263	0f b6 8e e1 00
	00 00		 movzx	 ecx, BYTE PTR [esi+225]
  0026a	89 8e 08 01 00
	00		 mov	 DWORD PTR [esi+264], ecx
$L109697:

; 4015 : 	}
; 4016 : 
; 4017 : 	// Expand/shrink the dynamic array to become
; 4018 : 	// exactly SparksLimit elements.
; 4019 : 	// Acts both at load time and edit time.
; 4020 : 	
; 4021 : 	if( Sparks.Num() != SparksLimit )

  00270	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  00276	8b 86 f4 00 00
	00		 mov	 eax, DWORD PTR [esi+244]
  0027c	3b d0		 cmp	 edx, eax
  0027e	0f 84 36 01 00
	00		 je	 $L119692

; 4022 : 	{
; 4023 : 		// Make sure not TOO big...
; 4024 : 		if( SparksLimit > MAXSPARKSLIMIT )

  00284	3d 00 20 00 00	 cmp	 eax, 8192		; 00002000H
  00289	7e 0c		 jle	 SHORT $L109709

; 4025 : 			SparksLimit = MAXSPARKSLIMIT;

  0028b	c7 86 f4 00 00
	00 00 20 00 00	 mov	 DWORD PTR [esi+244], 8192 ; 00002000H

; 4026 : 		else

  00295	eb 0f		 jmp	 SHORT $L109711
$L109709:

; 4027 : 		if( SparksLimit < MINSPARKSLIMIT )

  00297	83 f8 04	 cmp	 eax, 4
  0029a	7d 0a		 jge	 SHORT $L109711

; 4028 : 			SparksLimit = MINSPARKSLIMIT;

  0029c	c7 86 f4 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+244], 4
$L109711:

; 4029 : 
; 4030 : 		// New SparksLimit; current size is too big. 
; 4031 : 		if( Sparks.Num() > SparksLimit )

  002a6	8b 86 f4 00 00
	00		 mov	 eax, DWORD PTR [esi+244]
  002ac	3b d0		 cmp	 edx, eax
  002ae	0f 8e d2 00 00
	00		 jle	 $L109712

; 4032 : 		{
; 4033 : 			// Try culling some transients if needed.
; 4034 : 			if  (ActiveSparkNum > SparksLimit)

  002b4	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  002ba	3b c8		 cmp	 ecx, eax
  002bc	7e 39		 jle	 SHORT $L119705

; 4035 : 				for( INT t = (ActiveSparkNum-1); t>=0; t-- )

  002be	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  002c1	85 d2		 test	 edx, edx
  002c3	7c 32		 jl	 SHORT $L119705
$L109715:

; 4036 : 				{		
; 4037 : 					if( Sparks(t).Type >= ISPARK_TRANSIENTS ) 

  002c5	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  002cb	80 3c d0 1f	 cmp	 BYTE PTR [eax+edx*8], 31 ; 0000001fH
  002cf	72 23		 jb	 SHORT $L109716

; 4038 : 					{
; 4039 : 						Sparks(t) = Sparks(--ActiveSparkNum);	

  002d1	49		 dec	 ecx
  002d2	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  002d8	8b 3c c8	 mov	 edi, DWORD PTR [eax+ecx*8]
  002db	89 3c d0	 mov	 DWORD PTR [eax+edx*8], edi
  002de	8b 4c c8 04	 mov	 ecx, DWORD PTR [eax+ecx*8+4]
  002e2	89 4c d0 04	 mov	 DWORD PTR [eax+edx*8+4], ecx

; 4040 : 						// culled enough ?
; 4041 : 						if( ActiveSparkNum<= SparksLimit ) break;

  002e6	8b 8e f8 00 00
	00		 mov	 ecx, DWORD PTR [esi+248]
  002ec	3b 8e f4 00 00
	00		 cmp	 ecx, DWORD PTR [esi+244]
  002f2	7e 03		 jle	 SHORT $L119705
$L109716:

; 4035 : 				for( INT t = (ActiveSparkNum-1); t>=0; t-- )

  002f4	4a		 dec	 edx
  002f5	79 ce		 jns	 SHORT $L109715
$L119705:

; 4042 : 					}			 
; 4043 : 				}
; 4044 : 
; 4045 : 			// Adjust active sparks the crude way:
; 4046 : 			ActiveSparkNum = Min( ActiveSparkNum, SparksLimit );

  002f7	8b be f4 00 00
	00		 mov	 edi, DWORD PTR [esi+244]
  002fd	8b 86 f8 00 00
	00		 mov	 eax, DWORD PTR [esi+248]
  00303	3b c7		 cmp	 eax, edi
  00305	7e 02		 jle	 SHORT $L119638
  00307	8b c7		 mov	 eax, edi
$L119638:

; 4047 : 			// Now delete the empty tail. 
; 4048 : 			Sparks.Remove( SparksLimit, Sparks.Num()-SparksLimit); 

  00309	8b 9e 00 01 00
	00		 mov	 ebx, DWORD PTR [esi+256]
  0030f	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00315	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  0031b	2b df		 sub	 ebx, edi
  0031d	81 c6 fc 00 00
	00		 add	 esi, 252		; 000000fcH
  00323	85 ff		 test	 edi, edi
  00325	7d 14		 jge	 SHORT $L119650
  00327	68 fc 01 00 00	 push	 508			; 000001fcH
  0032c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00331	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  00336	ff d5		 call	 ebp
  00338	83 c4 0c	 add	 esp, 12			; 0000000cH
$L119650:
  0033b	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0033e	7e 14		 jle	 SHORT $L119651
  00340	68 fd 01 00 00	 push	 509			; 000001fdH
  00345	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0034a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0034f	ff d5		 call	 ebp
  00351	83 c4 0c	 add	 esp, 12			; 0000000cH
$L119651:
  00354	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00357	8d 14 1f	 lea	 edx, DWORD PTR [edi+ebx]
  0035a	3b d0		 cmp	 edx, eax
  0035c	7e 14		 jle	 SHORT $L119652
  0035e	68 fe 01 00 00	 push	 510			; 000001feH
  00363	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00368	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0036d	ff d5		 call	 ebp
  0036f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L119652:
  00372	6a 08		 push	 8
  00374	53		 push	 ebx
  00375	57		 push	 edi
  00376	8b ce		 mov	 ecx, esi
  00378	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  0037e	5f		 pop	 edi
  0037f	5e		 pop	 esi
  00380	5d		 pop	 ebp
  00381	5b		 pop	 ebx

; 4055 : 		}
; 4056 : 		//Sparks.Debug(); 
; 4057 : 	}
; 4058 : }

  00382	83 c4 08	 add	 esp, 8
  00385	c3		 ret	 0
$L109712:

; 4049 : 
; 4050 : 		}
; 4051 : 		else 
; 4052 : 		// Too small: just expand the array.
; 4053 : 		{
; 4054 : 			Sparks.Add( SparksLimit - Sparks.Num() );

  00386	8d 8e fc 00 00
	00		 lea	 ecx, DWORD PTR [esi+252]
  0038c	2b c2		 sub	 eax, edx
  0038e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00391	03 d0		 add	 edx, eax
  00393	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00396	8b f2		 mov	 esi, edx
  00398	3b f0		 cmp	 esi, eax
  0039a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0039d	7e 1b		 jle	 SHORT $L119692
  0039f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  003a2	99		 cdq
  003a3	83 e2 07	 and	 edx, 7
  003a6	03 c2		 add	 eax, edx
  003a8	c1 f8 03	 sar	 eax, 3
  003ab	8d 44 30 20	 lea	 eax, DWORD PTR [eax+esi+32]
  003af	6a 08		 push	 8
  003b1	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  003b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L119692:
  003ba	5f		 pop	 edi
  003bb	5e		 pop	 esi
  003bc	5d		 pop	 ebp
  003bd	5b		 pop	 ebx

; 4055 : 		}
; 4056 : 		//Sparks.Debug(); 
; 4057 : 	}
; 4058 : }

  003be	83 c4 08	 add	 esp, 8
  003c1	c3		 ret	 0
?PostLoad@UFireTexture@@UAEXXZ ENDP			; UFireTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFireTexture@@UAEXHHM@Z
_TEXT	SEGMENT
_UPos$ = 8
_VPos$ = 12
_Magnitude$ = 16
?TouchTexture@UFireTexture@@UAEXHHM@Z PROC NEAR		; UFireTexture::TouchTexture, COMDAT
; _this$ = ecx

; 4064 :     DWORD SparkDest = (DWORD)(UPos + (VPos << UBits) );
; 4065 :     Mips(0).DataArray(SparkDest) = (BYTE) Magnitude;

  00000	d9 44 24 0c	 fld	 DWORD PTR _Magnitude$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	e8 00 00 00 00	 call	 __ftol
  0000c	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0000f	8b 54 24 0c	 mov	 edx, DWORD PTR _VPos$[esp]
  00013	d3 e2		 shl	 edx, cl
  00015	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  0001b	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  0001e	8b 4c 24 08	 mov	 ecx, DWORD PTR _UPos$[esp]
  00022	03 d6		 add	 edx, esi
  00024	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  00027	5e		 pop	 esi

; 4066 : }

  00028	c2 0c 00	 ret	 12			; 0000000cH
?TouchTexture@UFireTexture@@UAEXHHM@Z ENDP		; UFireTexture::TouchTexture
_TEXT	ENDS
EXTRN	_CalcWrapFire:NEAR
EXTRN	_CalcSlowFire:NEAR
EXTRN	_CalcWrapFireP2:NEAR
EXTRN	_CalcSlowFireP2:NEAR
; Function compile flags: /Ogty
;	COMDAT ?ConstantTimeTick@UFireTexture@@UAEXXZ
_TEXT	SEGMENT
?ConstantTimeTick@UFireTexture@@UAEXXZ PROC NEAR	; UFireTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4070 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4071 : 	if( (USize>=8) && (VSize>=8) ) // safe sizes ?

  00003	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00006	b8 08 00 00 00	 mov	 eax, 8
  0000b	3b c8		 cmp	 ecx, eax
  0000d	0f 8c cc 00 00
	00		 jl	 $L109737
  00013	39 46 38	 cmp	 DWORD PTR [esi+56], eax
  00016	0f 8c c3 00 00
	00		 jl	 $L109737

; 4072 : 	{
; 4073 : 		// Call FireEngine update.
; 4074 : 
; 4075 : 		RedrawSparks();

  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?RedrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::RedrawSparks

; 4076 : 
; 4077 : #if FIREASM
; 4078 : 		if( GIsPentiumPro )

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GIsPentiumPro
  00028	83 38 00	 cmp	 DWORD PTR [eax], 0

; 4079 : 		{
; 4080 : 			if( bRising ) CalcWrapFireP2( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  0002b	8a 86 e4 00 00
	00		 mov	 al, BYTE PTR [esi+228]
  00031	74 56		 je	 SHORT $L109738
  00033	a8 01		 test	 al, 1
  00035	74 29		 je	 SHORT $L109739
  00037	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  0003a	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  0003d	51		 push	 ecx
  0003e	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  00044	52		 push	 edx
  00045	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00048	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  0004e	50		 push	 eax
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _CalcWrapFireP2

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  00058	8b ce		 mov	 ecx, esi
  0005a	5e		 pop	 esi
  0005b	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L109739:

; 4081 : 				else      CalcSlowFireP2( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  00060	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00063	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00066	50		 push	 eax
  00067	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  0006d	51		 push	 ecx
  0006e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00071	8d 96 0c 01 00
	00		 lea	 edx, DWORD PTR [esi+268]
  00077	52		 push	 edx
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _CalcSlowFireP2

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  00081	8b ce		 mov	 ecx, esi
  00083	5e		 pop	 esi
  00084	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L109738:

; 4082 : 		}
; 4083 : 		else
; 4084 : 		{
; 4085 : 			if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  00089	a8 01		 test	 al, 1
  0008b	74 29		 je	 SHORT $L109742
  0008d	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  00090	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00093	52		 push	 edx
  00094	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  0009a	50		 push	 eax
  0009b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0009e	8d 8e 0c 01 00
	00		 lea	 ecx, DWORD PTR [esi+268]
  000a4	51		 push	 ecx
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _CalcWrapFire

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  000ab	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  000ae	8b ce		 mov	 ecx, esi
  000b0	5e		 pop	 esi
  000b1	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L109742:

; 4086 : 				else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );

  000b6	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  000b9	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  000bc	51		 push	 ecx
  000bd	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  000c3	52		 push	 edx
  000c4	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000c7	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  000cd	50		 push	 eax
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _CalcSlowFire
  000d4	83 c4 10	 add	 esp, 16			; 00000010H

; 4087 : 		}
; 4088 : #else
; 4089 : 		if( bRising ) CalcWrapFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4090 : 		else      CalcSlowFire( &Mips(0).DataArray(0), RenderTable, USize, VSize );
; 4091 : #endif
; 4092 : 
; 4093 : 		PostDrawSparks();

  000d7	8b ce		 mov	 ecx, esi
  000d9	5e		 pop	 esi
  000da	e9 00 00 00 00	 jmp	 ?PostDrawSparks@UFireTexture@@AAEXXZ ; UFireTexture::PostDrawSparks
$L109737:
  000df	5e		 pop	 esi

; 4094 : 	}
; 4095 : }

  000e0	c3		 ret	 0
?ConstantTimeTick@UFireTexture@@UAEXXZ ENDP		; UFireTexture::ConstantTimeTick
_TEXT	ENDS
PUBLIC	__real@3f800000
;	COMDAT __real@3f800000
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?MousePosition@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
_I$119766 = -8
_I$119771 = -4
?MousePosition@UFireTexture@@UAEXKMM@Z PROC NEAR	; UFireTexture::MousePosition, COMDAT
; _this$ = ecx

; 4100 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f1		 mov	 esi, ecx

; 4101 : 	// Call FireEngine update. (adds or removes sparks in spark array)
; 4102 : 	FirePaint( appRound(X), appRound(Y), Buttons );

  00008	d9 44 24 20	 fld	 DWORD PTR _Y$[esp+16]
  0000c	db 5c 24 0c	 fistp	 DWORD PTR _I$119766[esp+20]
  00010	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  00014	db 5c 24 10	 fistp	 DWORD PTR _I$119771[esp+20]
  00018	8b 44 24 18	 mov	 eax, DWORD PTR _Buttons$[esp+16]
  0001c	8b 4c 24 0c	 mov	 ecx, DWORD PTR _I$119766[esp+20]
  00020	8b 54 24 10	 mov	 edx, DWORD PTR _I$119771[esp+20]
  00024	50		 push	 eax
  00025	51		 push	 ecx
  00026	52		 push	 edx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?FirePaint@UFireTexture@@AAEXHHK@Z ; UFireTexture::FirePaint

; 4103 : 
; 4104 : 	// Mouse 'torch' animation. Won't work on still cursor.
; 4105 : 	if( 1 )
; 4106 : 	{
; 4107 : 		TempDrawSpark(X  ,Y,255);
; 4108 : 		TempDrawSpark(X+1,Y,255);
; 4109 : 		TempDrawSpark(X-1,Y,255);

  0002e	d9 44 24 20	 fld	 DWORD PTR _Y$[esp+16]
  00032	e8 00 00 00 00	 call	 __ftol
  00037	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  0003b	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0003e	8b f8		 mov	 edi, eax
  00040	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  00046	8b df		 mov	 ebx, edi
  00048	23 d8		 and	 ebx, eax
  0004a	d3 e3		 shl	 ebx, cl
  0004c	e8 00 00 00 00	 call	 __ftol
  00051	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  00055	8b 8e c8 00 00
	00		 mov	 ecx, DWORD PTR [esi+200]
  0005b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@3f800000
  00061	23 c1		 and	 eax, ecx
  00063	03 d8		 add	 ebx, eax
  00065	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  0006b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0006e	c6 04 0b ff	 mov	 BYTE PTR [ebx+ecx], 255	; 000000ffH
  00072	8b 8e cc 00 00
	00		 mov	 ecx, DWORD PTR [esi+204]
  00078	8b df		 mov	 ebx, edi
  0007a	23 d9		 and	 ebx, ecx
  0007c	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  0007f	d3 e3		 shl	 ebx, cl
  00081	e8 00 00 00 00	 call	 __ftol
  00086	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  0008a	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  00090	d8 25 00 00 00
	00		 fsub	 DWORD PTR __real@3f800000
  00096	23 c2		 and	 eax, edx
  00098	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [esi+168]
  0009e	03 d8		 add	 ebx, eax
  000a0	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000a3	c6 04 03 ff	 mov	 BYTE PTR [ebx+eax], 255	; 000000ffH
  000a7	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  000ad	8a 4e 30	 mov	 cl, BYTE PTR [esi+48]
  000b0	23 f8		 and	 edi, eax
  000b2	d3 e7		 shl	 edi, cl
  000b4	e8 00 00 00 00	 call	 __ftol
  000b9	8b 96 c8 00 00
	00		 mov	 edx, DWORD PTR [esi+200]
  000bf	8b 8e a8 00 00
	00		 mov	 ecx, DWORD PTR [esi+168]
  000c5	23 c2		 and	 eax, edx
  000c7	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000ca	03 f8		 add	 edi, eax
  000cc	c6 04 17 ff	 mov	 BYTE PTR [edi+edx], 255	; 000000ffH
  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx

; 4110 : 	}
; 4111 :     else
; 4112 :     {
; 4113 :     }
; 4114 : }

  000d3	83 c4 08	 add	 esp, 8
  000d6	c2 0c 00	 ret	 12			; 0000000cH
?MousePosition@UFireTexture@@UAEXKMM@Z ENDP		; UFireTexture::MousePosition
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Click@UFireTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
_I$119826 = -8
_I$119831 = -4
?Click@UFireTexture@@UAEXKMM@Z PROC NEAR		; UFireTexture::Click, COMDAT
; _this$ = ecx

; 4119 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 4120 : 	// Call FireEngine update.
; 4121 : 	FirePaint( appRound(X), appRound(Y), Buttons );

  00007	d9 44 24 1c	 fld	 DWORD PTR _Y$[esp+12]
  0000b	db 5c 24 08	 fistp	 DWORD PTR _I$119826[esp+16]
  0000f	d9 44 24 18	 fld	 DWORD PTR _X$[esp+12]
  00013	db 5c 24 0c	 fistp	 DWORD PTR _I$119831[esp+16]
  00017	8b 44 24 14	 mov	 eax, DWORD PTR _Buttons$[esp+12]
  0001b	8b 4c 24 08	 mov	 ecx, DWORD PTR _I$119826[esp+16]
  0001f	8b 54 24 0c	 mov	 edx, DWORD PTR _I$119831[esp+16]
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	52		 push	 edx
  00026	8b ce		 mov	 ecx, esi
  00028	e8 00 00 00 00	 call	 ?FirePaint@UFireTexture@@AAEXHHK@Z ; UFireTexture::FirePaint

; 4122 : 
; 4123 : 	// Mouse 'torch' animation.
; 4124 : 	if( 1 )
; 4125 : 	{
; 4126 : 		Mips(0).DataArray((INT)X + (INT)Y * USize) = 255;

  0002d	d9 44 24 1c	 fld	 DWORD PTR _Y$[esp+12]
  00031	e8 00 00 00 00	 call	 __ftol
  00036	d9 44 24 18	 fld	 DWORD PTR _X$[esp+12]
  0003a	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  0003d	0f af f8	 imul	 edi, eax
  00040	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  00046	03 78 1c	 add	 edi, DWORD PTR [eax+28]
  00049	e8 00 00 00 00	 call	 __ftol
  0004e	c6 04 07 ff	 mov	 BYTE PTR [edi+eax], 255	; 000000ffH
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 4127 : 	}
; 4128 :     else
; 4129 :     {
; 4130 :         //SparkType = TouchType;
; 4131 :         //AddSpark( X, Y);
; 4132 :     }
; 4133 : }

  00054	83 c4 08	 add	 esp, 8
  00057	c2 0c 00	 ret	 12			; 0000000cH
?Click@UFireTexture@@UAEXKMM@Z ENDP			; UFireTexture::Click
_TEXT	ENDS
PUBLIC	??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z		; operator<<
EXTRN	__imp_?Serialize@UTexture@@UAEXAAVFArchive@@@Z:NEAR
EXTRN	__imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z:NEAR
EXTRN	__imp_?Add@FArray@@QAEHHH@Z:NEAR
EXTRN	__imp_?Empty@FArray@@QAEXHH@Z:NEAR
EXTRN	__imp_?CountBytes@FArray@@QAEXAAVFArchive@@H@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z
_TEXT	SEGMENT
_Ar$ = 8
_NewNum$119958 = 8
$T119882 = 8
?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z PROC NEAR	; UFireTexture::Serialize, COMDAT
; _this$ = ecx

; 4136 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 4137 : 	Super::Serialize( Ar );

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _Ar$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	55		 push	 ebp
  00009	8b f9		 mov	 edi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Serialize@UTexture@@UAEXAAVFArchive@@@Z

; 4138 : 
; 4139 :     // Clean up & minimize our spark array for saving to disk:
; 4140 : 	if( Ar.IsSaving() ) 

  00011	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00014	85 c0		 test	 eax, eax
  00016	0f 84 bc 00 00
	00		 je	 $L119868

; 4141 : 	{
; 4142 : 		// Delete the transients, compact the spark array.
; 4143 : 		for( INT t=ActiveSparkNum-1; t>=0; t-- )

  0001c	8b 8f f8 00 00
	00		 mov	 ecx, DWORD PTR [edi+248]
  00022	49		 dec	 ecx
  00023	78 2a		 js	 SHORT $L109770
$L109768:

; 4144 : 			if( Sparks(t).Type >= ISPARK_TRANSIENTS ) 

  00025	8b 87 fc 00 00
	00		 mov	 eax, DWORD PTR [edi+252]
  0002b	80 3c c8 1f	 cmp	 BYTE PTR [eax+ecx*8], 31 ; 0000001fH
  0002f	72 1b		 jb	 SHORT $L109769

; 4145 : 				Sparks(t) = Sparks(--ActiveSparkNum);	

  00031	8b 97 f8 00 00
	00		 mov	 edx, DWORD PTR [edi+248]
  00037	4a		 dec	 edx
  00038	89 97 f8 00 00
	00		 mov	 DWORD PTR [edi+248], edx
  0003e	8b 34 d0	 mov	 esi, DWORD PTR [eax+edx*8]
  00041	89 34 c8	 mov	 DWORD PTR [eax+ecx*8], esi
  00044	8b 54 d0 04	 mov	 edx, DWORD PTR [eax+edx*8+4]
  00048	89 54 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], edx
$L109769:

; 4141 : 	{
; 4142 : 		// Delete the transients, compact the spark array.
; 4143 : 		for( INT t=ActiveSparkNum-1; t>=0; t-- )

  0004c	49		 dec	 ecx
  0004d	79 d6		 jns	 SHORT $L109768
$L109770:

; 4146 : 
; 4147 : 		// Deflate the empty tail.
; 4148 : 		if( ActiveSparkNum < Sparks.Num() )

  0004f	8b 87 00 01 00
	00		 mov	 eax, DWORD PTR [edi+256]
  00055	8b b7 f8 00 00
	00		 mov	 esi, DWORD PTR [edi+248]
  0005b	3b f0		 cmp	 esi, eax
  0005d	7d 79		 jge	 SHORT $L119868

; 4149 : 			Sparks.Remove( ActiveSparkNum, Sparks.Num()-ActiveSparkNum ); 

  0005f	2b c6		 sub	 eax, esi
  00061	85 f6		 test	 esi, esi
  00063	89 44 24 14	 mov	 DWORD PTR $T119882[esp+12], eax
  00067	8d 9f fc 00 00
	00		 lea	 ebx, DWORD PTR [edi+252]
  0006d	7d 18		 jge	 SHORT $L119869
  0006f	68 fc 01 00 00	 push	 508			; 000001fcH
  00074	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00079	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
$L119869:
  00087	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
  0008a	7e 18		 jle	 SHORT $L119870
  0008c	68 fd 01 00 00	 push	 509			; 000001fdH
  00091	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00096	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L119870:
  000a4	8b 44 24 14	 mov	 eax, DWORD PTR $T119882[esp+12]
  000a8	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  000ab	3b 4b 04	 cmp	 ecx, DWORD PTR [ebx+4]
  000ae	7e 18		 jle	 SHORT $L119871
  000b0	68 fe 01 00 00	 push	 510			; 000001feH
  000b5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000ba	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH
$L119871:
  000c8	8b 54 24 14	 mov	 edx, DWORD PTR $T119882[esp+12]
  000cc	6a 08		 push	 8
  000ce	52		 push	 edx
  000cf	56		 push	 esi
  000d0	8b cb		 mov	 ecx, ebx
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
$L119868:

; 4150 : 	}
; 4151 : 	Ar << Sparks;

  000d8	6a 08		 push	 8
  000da	8d b7 fc 00 00
	00		 lea	 esi, DWORD PTR [edi+252]
  000e0	55		 push	 ebp
  000e1	8b ce		 mov	 ecx, esi
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?CountBytes@FArray@@QAEXAAVFArchive@@H@Z
  000e9	8b 45 14	 mov	 eax, DWORD PTR [ebp+20]
  000ec	85 c0		 test	 eax, eax
  000ee	74 4e		 je	 SHORT $L119957
  000f0	8d 44 24 14	 lea	 eax, DWORD PTR _NewNum$119958[esp+12]
  000f4	50		 push	 eax
  000f5	55		 push	 ebp
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z
  000fc	8b 4c 24 1c	 mov	 ecx, DWORD PTR _NewNum$119958[esp+20]
  00100	83 c4 08	 add	 esp, 8
  00103	51		 push	 ecx
  00104	6a 08		 push	 8
  00106	8b ce		 mov	 ecx, esi
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Empty@FArray@@QAEXHH@Z
  0010e	8b 44 24 14	 mov	 eax, DWORD PTR _NewNum$119958[esp+12]
  00112	33 db		 xor	 ebx, ebx
  00114	85 c0		 test	 eax, eax
  00116	7e 54		 jle	 SHORT $L119967
$L119960:
  00118	6a 08		 push	 8
  0011a	6a 01		 push	 1
  0011c	8b ce		 mov	 ecx, esi
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Add@FArray@@QAEHHH@Z
  00124	8b 16		 mov	 edx, DWORD PTR [esi]
  00126	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  00129	50		 push	 eax
  0012a	55		 push	 ebp
  0012b	e8 00 00 00 00	 call	 ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z ; operator<<
  00130	8b 44 24 1c	 mov	 eax, DWORD PTR _NewNum$119958[esp+20]
  00134	83 c4 08	 add	 esp, 8
  00137	43		 inc	 ebx
  00138	3b d8		 cmp	 ebx, eax
  0013a	7c dc		 jl	 SHORT $L119960
  0013c	eb 2e		 jmp	 SHORT $L119967
$L119957:
  0013e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00141	50		 push	 eax
  00142	55		 push	 ebp
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z
  00149	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0014c	83 c4 08	 add	 esp, 8
  0014f	33 db		 xor	 ebx, ebx
  00151	85 c0		 test	 eax, eax
  00153	7e 17		 jle	 SHORT $L119967
$L119965:
  00155	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00157	8d 14 d9	 lea	 edx, DWORD PTR [ecx+ebx*8]
  0015a	52		 push	 edx
  0015b	55		 push	 ebp
  0015c	e8 00 00 00 00	 call	 ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z ; operator<<
  00161	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00164	83 c4 08	 add	 esp, 8
  00167	43		 inc	 ebx
  00168	3b d8		 cmp	 ebx, eax
  0016a	7c e9		 jl	 SHORT $L119965
$L119967:

; 4152 : 
; 4153 : 	// Expand the compacted array again. Sparks.Num() should always be equal to SparksLimit !
; 4154 : 	if( Sparks.Num() < SparksLimit )

  0016c	8b 87 00 01 00
	00		 mov	 eax, DWORD PTR [edi+256]
  00172	8b bf f4 00 00
	00		 mov	 edi, DWORD PTR [edi+244]
  00178	3b c7		 cmp	 eax, edi
  0017a	7d 2e		 jge	 SHORT $L119999

; 4155 : 		Sparks.Add( SparksLimit - Sparks.Num() );

  0017c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0017f	2b f8		 sub	 edi, eax
  00181	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00184	03 cf		 add	 ecx, edi
  00186	3b c8		 cmp	 ecx, eax
  00188	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0018b	7e 1d		 jle	 SHORT $L119999
  0018d	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00190	99		 cdq
  00191	83 e2 07	 and	 edx, 7
  00194	03 c2		 add	 eax, edx
  00196	c1 f8 03	 sar	 eax, 3
  00199	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  0019d	6a 08		 push	 8
  0019f	8b ce		 mov	 ecx, esi
  001a1	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L119999:
  001aa	5f		 pop	 edi
  001ab	5e		 pop	 esi
  001ac	5d		 pop	 ebp
  001ad	5b		 pop	 ebx

; 4156 : }

  001ae	c2 04 00	 ret	 4
?Serialize@UFireTexture@@UAEXAAVFArchive@@@Z ENDP	; UFireTexture::Serialize
_TEXT	ENDS
PUBLIC	??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UFireTexture@@SAXPAX@Z	; UFireTexture::InternalConstructor
;	COMDAT ??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'F', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'T', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E197
_TEXT	SEGMENT
_$E197	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UFireTexture@@SAXPAX@Z ; UFireTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@KFIN@?$AAU?$AAF?$AAi?$AAr?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 14 05 00 00	 push	 1300			; 00000514H
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E194
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E197	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S195	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E194
_TEXT	SEGMENT
_$E194	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S195
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L109786
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S195, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L109786:
  0001f	c3		 ret	 0
_$E194	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E200
_TEXT	SEGMENT
_$E200	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUFireTexture, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E200	ENDP
_TEXT	ENDS
PUBLIC	??0UWaterTexture@@QAE@XZ			; UWaterTexture::UWaterTexture
PUBLIC	?PostLoad@UWaterTexture@@UAEXXZ			; UWaterTexture::PostLoad
PUBLIC	?Destroy@UWaterTexture@@UAEXXZ			; UWaterTexture::Destroy
PUBLIC	?Init@UWaterTexture@@UAEXHH@Z			; UWaterTexture::Init
PUBLIC	?Clear@UWaterTexture@@UAEXK@Z			; UWaterTexture::Clear
PUBLIC	?MousePosition@UWaterTexture@@UAEXKMM@Z		; UWaterTexture::MousePosition
PUBLIC	?Click@UWaterTexture@@UAEXKMM@Z			; UWaterTexture::Click
PUBLIC	?TouchTexture@UWaterTexture@@UAEXHHM@Z		; UWaterTexture::TouchTexture
PUBLIC	??_7UWaterTexture@@6B@				; UWaterTexture::`vftable'
PUBLIC	??_EUWaterTexture@@UAEPAXI@Z			; UWaterTexture::`vector deleting destructor'
;	COMDAT ??_7UWaterTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UWaterTexture@@6B@ DD FLAT:??_EUWaterTexture@@UAEPAXI@Z ; UWaterTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UWaterTexture@@UAEXXZ
	DD	FLAT:?Destroy@UWaterTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UWaterTexture@@UAEXK@Z
	DD	FLAT:?Init@UWaterTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UWaterTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UWaterTexture@@QAE@XZ
_TEXT	SEGMENT
??0UWaterTexture@@QAE@XZ PROC NEAR			; UWaterTexture::UWaterTexture, COMDAT
; _this$ = ecx

; 4167 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  0000c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00012	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0001b	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00021	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00026	33 c0		 xor	 eax, eax

; 4168 : 	// Fill the algorithm lookup table.
; 4169 :     for( INT t=0; t<(1024+512); t++ )

  00028	b9 08 f1 ff ff	 mov	 ecx, -3832		; fffff108H
  0002d	33 ff		 xor	 edi, edi
  0002f	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  00035	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0003b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00041	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00047	8d ae f8 0c 00
	00		 lea	 ebp, DWORD PTR [esi+3320]
  0004d	2b ce		 sub	 ecx, esi

; 4175 : }

  0004f	90		 npad	 1

; 4168 : 	// Fill the algorithm lookup table.
; 4169 :     for( INT t=0; t<(1024+512); t++ )

$L109802:

; 4170 : 		WaveTable[t] = Clamp( (t/2 - 256) + ( (t-512)< 256), 0, 255 );

  00050	33 db		 xor	 ebx, ebx
  00052	8d 04 29	 lea	 eax, DWORD PTR [ecx+ebp]
  00055	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0005a	0f 9c c3	 setl	 bl
  0005d	8b c7		 mov	 eax, edi
  0005f	99		 cdq
  00060	2b c2		 sub	 eax, edx
  00062	d1 f8		 sar	 eax, 1
  00064	8d 84 03 00 ff
	ff ff		 lea	 eax, DWORD PTR [ebx+eax-256]
  0006b	85 c0		 test	 eax, eax
  0006d	7d 04		 jge	 SHORT $L120095
  0006f	33 c0		 xor	 eax, eax
  00071	eb 0c		 jmp	 SHORT $L120094
$L120095:
  00073	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00078	7c 05		 jl	 SHORT $L120094
  0007a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L120094:
  0007f	47		 inc	 edi
  00080	88 45 00	 mov	 BYTE PTR [ebp], al
  00083	45		 inc	 ebp
  00084	81 ff 00 06 00
	00		 cmp	 edi, 1536		; 00000600H
  0008a	7c c4		 jl	 SHORT $L109802
  0008c	5f		 pop	 edi

; 4171 : 
; 4172 : 	// Init most non-serialized vars.
; 4173 : 	OldWaveAmp     = -1; 

  0008d	c7 86 fc 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4860], -1

; 4174 : 	WaveParity     =  0;

  00097	c6 86 f8 12 00
	00 00		 mov	 BYTE PTR [esi+4856], 0

; 4175 : }

  0009e	8b c6		 mov	 eax, esi
  000a0	5e		 pop	 esi
  000a1	5d		 pop	 ebp
  000a2	5b		 pop	 ebx
  000a3	c3		 ret	 0
??0UWaterTexture@@QAE@XZ ENDP				; UWaterTexture::UWaterTexture
_TEXT	ENDS
PUBLIC	??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnClass.h
_DATA	SEGMENT
??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'T', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ DB 'D', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?Init@UWaterTexture@@UAEXHH@Z
_TEXT	SEGMENT
_InUSize$ = 8
_InVSize$ = 12
?Init@UWaterTexture@@UAEXHH@Z PROC NEAR			; UWaterTexture::Init, COMDAT
; _this$ = ecx

; 4182 : 	VERIFY_CLASS_OFFSET(U,WaterTexture,DropType);

  00000	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UWaterTexture@@0VUClass@@A+24
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  0000f	50		 push	 eax
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00015	50		 push	 eax
  00016	8b d9		 mov	 ebx, ecx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  0001e	8b f8		 mov	 edi, eax
  00020	83 c4 10	 add	 esp, 16			; 00000010H
  00023	85 ff		 test	 edi, edi
  00025	74 05		 je	 SHORT $L120153
  00027	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  0002a	eb 02		 jmp	 SHORT $L120154
$L120153:
  0002c	33 f6		 xor	 esi, esi
$L120154:
  0002e	85 ff		 test	 edi, edi
  00030	74 44		 je	 SHORT $L120246
$L120166:
  00032	85 f6		 test	 esi, esi
  00034	74 2e		 je	 SHORT $L120169
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 4201 : }

  0003c	8d 64 24 00	 npad	 4

; 4182 : 	VERIFY_CLASS_OFFSET(U,WaterTexture,DropType);

$L120168:
  00040	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00043	85 c0		 test	 eax, eax
  00045	74 0b		 je	 SHORT $L120162
$L120160:
  00047	3b c1		 cmp	 eax, ecx
  00049	74 2b		 je	 SHORT $L120246
  0004b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0004e	85 c0		 test	 eax, eax
  00050	75 f5		 jne	 SHORT $L120160
$L120162:
  00052	33 c0		 xor	 eax, eax
  00054	85 c9		 test	 ecx, ecx
  00056	0f 94 c0	 sete	 al
  00059	85 c0		 test	 eax, eax
  0005b	75 19		 jne	 SHORT $L120246
  0005d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00060	85 f6		 test	 esi, esi
  00062	75 dc		 jne	 SHORT $L120168
$L120169:
  00064	8b 17		 mov	 edx, DWORD PTR [edi]
  00066	8b cf		 mov	 ecx, edi
  00068	ff 52 5c	 call	 DWORD PTR [edx+92]
  0006b	8b f8		 mov	 edi, eax
  0006d	85 ff		 test	 edi, edi
  0006f	74 05		 je	 SHORT $L120246
  00071	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00074	eb bc		 jmp	 SHORT $L120166
$L120246:
  00076	85 f6		 test	 esi, esi
  00078	0f 84 a1 00 00
	00		 je	 $L109824
  0007e	55		 push	 ebp
  0007f	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
$L120223:
  00085	8b 06		 mov	 eax, DWORD PTR [esi]
  00087	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  0008c	8b ce		 mov	 ecx, esi
  0008e	ff 50 44	 call	 DWORD PTR [eax+68]
  00091	50		 push	 eax
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appStricmp@@YAHPBG0@Z
  00098	83 c4 08	 add	 esp, 8
  0009b	85 c0		 test	 eax, eax
  0009d	75 2d		 jne	 SHORT $L109823
  0009f	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000a2	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  000a7	74 23		 je	 SHORT $L109823
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000af	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b1	68 e0 00 00 00	 push	 224			; 000000e0H
  000b6	50		 push	 eax
  000b7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BC@DDHO@?$AAD?$AAr?$AAo?$AAp?$AAT?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
  000bc	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@KFM@?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000c6	52		 push	 edx
  000c7	ff d5		 call	 ebp
  000c9	83 c4 18	 add	 esp, 24			; 00000018H
$L109823:
  000cc	85 ff		 test	 edi, edi
  000ce	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000d1	74 43		 je	 SHORT $L120248
$L120217:
  000d3	85 f6		 test	 esi, esi
  000d5	74 2d		 je	 SHORT $L120220
  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 4201 : }

  000dd	8d 49 00	 npad	 3

; 4182 : 	VERIFY_CLASS_OFFSET(U,WaterTexture,DropType);

$L120219:
  000e0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000e3	85 c0		 test	 eax, eax
  000e5	74 0b		 je	 SHORT $L120213
$L120211:
  000e7	3b c1		 cmp	 eax, ecx
  000e9	74 2b		 je	 SHORT $L120248
  000eb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000ee	85 c0		 test	 eax, eax
  000f0	75 f5		 jne	 SHORT $L120211
$L120213:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c9		 test	 ecx, ecx
  000f6	0f 94 c0	 sete	 al
  000f9	85 c0		 test	 eax, eax
  000fb	75 19		 jne	 SHORT $L120248
  000fd	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00100	85 f6		 test	 esi, esi
  00102	75 dc		 jne	 SHORT $L120219
$L120220:
  00104	8b 07		 mov	 eax, DWORD PTR [edi]
  00106	8b cf		 mov	 ecx, edi
  00108	ff 50 5c	 call	 DWORD PTR [eax+92]
  0010b	8b f8		 mov	 edi, eax
  0010d	85 ff		 test	 edi, edi
  0010f	74 05		 je	 SHORT $L120248
  00111	8b 77 40	 mov	 esi, DWORD PTR [edi+64]
  00114	eb bd		 jmp	 SHORT $L120217
$L120248:
  00116	85 f6		 test	 esi, esi
  00118	0f 85 67 ff ff
	ff		 jne	 $L120223
  0011e	5d		 pop	 ebp
$L109824:

; 4183 : 
; 4184 : 	// Init base class.
; 4185 : 	UFractalTexture::Init( InUSize, InVSize );

  0011f	8b 4c 24 14	 mov	 ecx, DWORD PTR _InVSize$[esp+8]
  00123	8b 54 24 10	 mov	 edx, DWORD PTR _InUSize$[esp+8]
  00127	51		 push	 ecx
  00128	52		 push	 edx
  00129	8b cb		 mov	 ecx, ebx
  0012b	e8 00 00 00 00	 call	 ?Init@UFractalTexture@@UAEXHH@Z ; UFractalTexture::Init

; 4186 : 
; 4187 : 	// One-time initialization of *serialized* parameters.
; 4188 :     NumDrops =   0;
; 4189 :     DropType =   1;        
; 4190 : 	WaveAmp  = 128;

  00130	b1 80		 mov	 cl, 128			; 00000080H

; 4191 : 
; 4192 : 	// FX specifics
; 4193 : 	FX_Frequency	= 010;

  00132	b0 08		 mov	 al, 8
  00134	88 8b e1 00 00
	00		 mov	 BYTE PTR [ebx+225], cl
  0013a	88 83 e2 00 00
	00		 mov	 BYTE PTR [ebx+226], al

; 4194 : 	FX_Phase		= 010;

  00140	88 83 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], al

; 4195 : 	FX_Amplitude	= 255;

  00146	b0 ff		 mov	 al, 255			; 000000ffH

; 4196 : 	FX_Speed		= 255;
; 4197 : 	FX_Radius		= 128;

  00148	88 8b e6 00 00
	00		 mov	 BYTE PTR [ebx+230], cl
  0014e	5f		 pop	 edi

; 4198 : 	FX_Size			= 30;

  0014f	b1 1e		 mov	 cl, 30			; 0000001eH
  00151	5e		 pop	 esi
  00152	c7 83 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+236], 0
  0015c	c6 83 e0 00 00
	00 01		 mov	 BYTE PTR [ebx+224], 1
  00163	88 83 e4 00 00
	00		 mov	 BYTE PTR [ebx+228], al
  00169	88 83 e5 00 00
	00		 mov	 BYTE PTR [ebx+229], al
  0016f	88 8b e7 00 00
	00		 mov	 BYTE PTR [ebx+231], cl

; 4199 : 	FX_Depth		= 255;

  00175	88 83 e8 00 00
	00		 mov	 BYTE PTR [ebx+232], al

; 4200 : 	FX_Time         = 30;

  0017b	88 8b e9 00 00
	00		 mov	 BYTE PTR [ebx+233], cl
  00181	5b		 pop	 ebx

; 4201 : }

  00182	c2 08 00	 ret	 8
?Init@UWaterTexture@@UAEXHH@Z ENDP			; UWaterTexture::Init
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?PostLoad@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT
?PostLoad@UWaterTexture@@UAEXXZ PROC NEAR		; UWaterTexture::PostLoad, COMDAT
; _this$ = ecx

; 4205 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4206 : 	Super::PostLoad();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  00009	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0000c	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0000f	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00015	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00018	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0001b	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx

; 4207 : 
; 4208 : 	if( SourceFields == NULL )

  00021	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  00027	85 d2		 test	 edx, edx
  00029	75 50		 jne	 SHORT $L109841

; 4209 : 	{
; 4210 : 		// Allocate the two wave height fields.
; 4211 : 		SourceFields = new BYTE[ USize * VSize / 2 ]; 

  0002b	0f af c1	 imul	 eax, ecx
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00034	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00036	99		 cdq
  00037	2b c2		 sub	 eax, edx
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	d1 f8		 sar	 eax, 1
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00042	50		 push	 eax
  00043	ff 12		 call	 DWORD PTR [edx]
  00045	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax

; 4212 : 		// initialize water to average height.
; 4213 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  0004b	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0004e	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00052	99		 cdq
  00053	2b c2		 sub	 eax, edx
  00055	d1 f8		 sar	 eax, 1
  00057	33 c9		 xor	 ecx, ecx
  00059	85 c0		 test	 eax, eax
  0005b	7e 1e		 jle	 SHORT $L109841

; 4215 : 	}
; 4216 : }

  0005d	8d 49 00	 npad	 3
$L109839:

; 4214 : 			SourceFields[i] = 128;

  00060	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00066	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0006a	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0006d	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00071	99		 cdq
  00072	2b c2		 sub	 eax, edx
  00074	41		 inc	 ecx
  00075	d1 f8		 sar	 eax, 1
  00077	3b c8		 cmp	 ecx, eax
  00079	7c e5		 jl	 SHORT $L109839
$L109841:
  0007b	5e		 pop	 esi

; 4215 : 	}
; 4216 : }

  0007c	c3		 ret	 0
?PostLoad@UWaterTexture@@UAEXXZ ENDP			; UWaterTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?TouchTexture@UWaterTexture@@UAEXHHM@Z
_TEXT	SEGMENT
_UPos$ = 8
_VPos$ = 12
_Magnitude$ = 16
?TouchTexture@UWaterTexture@@UAEXHHM@Z PROC NEAR	; UWaterTexture::TouchTexture, COMDAT
; _this$ = ecx

; 4222 : 	BYTE* WaveFieldA = SourceFields;
; 4223 :     BYTE* WaveFieldB = SourceFields + USize;
; 4224 : 
; 4225 :     DWORD DropDest   = (DWORD)( ( VPos << UBits ) + UPos);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _UPos$[esp-4]

; 4226 : 
; 4227 :     // Depress a circular gradual area, radius = Magnitude.
; 4228 : 
; 4229 : 	BYTE Depth = (BYTE) Magnitude;       

  00004	d9 44 24 0c	 fld	 DWORD PTR _Magnitude$[esp-4]
  00008	53		 push	 ebx
  00009	8b 99 f0 08 00
	00		 mov	 ebx, DWORD PTR [ecx+2288]
  0000f	56		 push	 esi
  00010	8b 74 24 10	 mov	 esi, DWORD PTR _VPos$[esp+4]
  00014	57		 push	 edi
  00015	8b 79 34	 mov	 edi, DWORD PTR [ecx+52]
  00018	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  0001b	d3 e6		 shl	 esi, cl
  0001d	03 fb		 add	 edi, ebx
  0001f	03 f0		 add	 esi, eax
  00021	e8 00 00 00 00	 call	 __ftol

; 4230 : 
; 4231 :     WaveFieldA[ DropDest ]  =  Depth;

  00026	88 04 33	 mov	 BYTE PTR [ebx+esi], al

; 4232 :     WaveFieldB[ DropDest ]  =  Depth;

  00029	88 04 3e	 mov	 BYTE PTR [esi+edi], al
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx

; 4233 : }

  0002f	c2 0c 00	 ret	 12			; 0000000cH
?TouchTexture@UWaterTexture@@UAEXHHM@Z ENDP		; UWaterTexture::TouchTexture
_TEXT	ENDS
EXTRN	__imp_?Destroy@UTexture@@UAEXXZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Destroy@UWaterTexture@@UAEXXZ
_TEXT	SEGMENT
?Destroy@UWaterTexture@@UAEXXZ PROC NEAR		; UWaterTexture::Destroy, COMDAT
; _this$ = ecx

; 4239 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4240 : 	// Free memory.
; 4241 : 	if( SourceFields )

  00003	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00009	85 c0		 test	 eax, eax
  0000b	74 0e		 je	 SHORT $L120277

; 4242 : 		delete SourceFields;

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00013	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	50		 push	 eax
  00018	ff 52 08	 call	 DWORD PTR [edx+8]
$L120277:

; 4243 : 
; 4244 : 	Super::Destroy(); // must call base class' destroy.

  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Destroy@UTexture@@UAEXXZ
?Destroy@UWaterTexture@@UAEXXZ ENDP			; UWaterTexture::Destroy
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UWaterTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UWaterTexture@@UAEXK@Z PROC NEAR			; UWaterTexture::Clear, COMDAT
; _this$ = ecx

; 4249 : {

  00000	53		 push	 ebx

; 4250 : 	// Init to zero.
; 4251 : 	UFractalTexture::Clear( ClearFlags );

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _ClearFlags$[esp]
  00005	56		 push	 esi
  00006	53		 push	 ebx
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z

; 4252 : 
; 4253 : 	// Clear fields.
; 4254 : 	if( ClearFlags & TCLEAR_Bitmap )

  0000f	f6 c3 02	 test	 bl, 2
  00012	74 2d		 je	 SHORT $L109867

; 4255 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  00014	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00017	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  0001b	99		 cdq
  0001c	2b c2		 sub	 eax, edx
  0001e	d1 f8		 sar	 eax, 1
  00020	33 c9		 xor	 ecx, ecx
  00022	85 c0		 test	 eax, eax
  00024	7e 1b		 jle	 SHORT $L109867
$L109865:

; 4256 : 			SourceFields[i] = 128;

  00026	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  0002c	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  00030	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00033	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00037	99		 cdq
  00038	2b c2		 sub	 eax, edx
  0003a	41		 inc	 ecx
  0003b	d1 f8		 sar	 eax, 1
  0003d	3b c8		 cmp	 ecx, eax
  0003f	7c e5		 jl	 SHORT $L109865
$L109867:

; 4257 : 
; 4258 : 	// Clear drops.
; 4259 : 	if( ClearFlags & TCLEAR_Temporal )

  00041	f6 c3 01	 test	 bl, 1
  00044	74 0a		 je	 SHORT $L109868

; 4260 : 		NumDrops=0;

  00046	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L109868:
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 4261 : }

  00052	c2 04 00	 ret	 4
?Clear@UWaterTexture@@UAEXK@Z ENDP			; UWaterTexture::Clear
_TEXT	ENDS
PUBLIC	?WaterPaint@UWaterTexture@@AAEXHHK@Z		; UWaterTexture::WaterPaint
; Function compile flags: /Ogty
;	COMDAT ?WaterPaint@UWaterTexture@@AAEXHHK@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Buttons$ = 16
?WaterPaint@UWaterTexture@@AAEXHHK@Z PROC NEAR		; UWaterTexture::WaterPaint, COMDAT
; _this$ = ecx

; 4266 : 	INT MouseX=X, MouseY=Y;
; 4267 : 
; 4268 : 	// Water drawing
; 4269 : 	
; 4270 : 	UBOOL  LeftButton = (Buttons & MOUSE_Left);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _Buttons$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp

; 4271 : 
; 4272 : 	// Perform painting.
; 4273 :     static INT  LastMouseX=0, LastMouseY=0, LastLeftButton=0, LastRightButton=0;
; 4274 : 
; 4275 :     UBOOL  PosChanged   =  ((LastMouseX != MouseX) || (LastMouseY != MouseY));

  00006	8b 6c 24 0c	 mov	 ebp, DWORD PTR _X$[esp+4]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastMouseX@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00013	83 e0 01	 and	 eax, 1
  00016	3b cd		 cmp	 ecx, ebp
  00018	57		 push	 edi
  00019	75 10		 jne	 SHORT $L120287
  0001b	8b 4c 24 18	 mov	 ecx, DWORD PTR _Y$[esp+12]
  0001f	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?LastMouseY@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA, ecx
  00025	75 04		 jne	 SHORT $L120287
  00027	33 db		 xor	 ebx, ebx
  00029	eb 05		 jmp	 SHORT $L120288
$L120287:
  0002b	bb 01 00 00 00	 mov	 ebx, 1
$L120288:

; 4276 :     UBOOL  LeftChanged  =   (LastLeftButton  != LeftButton );

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastLeftButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00036	33 d2		 xor	 edx, edx
  00038	3b c8		 cmp	 ecx, eax

; 4277 : 
; 4278 : 	UBOOL Continuous = true; 
; 4279 : 
; 4280 : 	// Check types that don't require continuous drawing
; 4281 : 	switch (DropType)
; 4282 : 	{

  0003a	8a 8e e0 00 00
	00		 mov	 cl, BYTE PTR [esi+224]
  00040	0f 95 c2	 setne	 dl
  00043	80 f9 08	 cmp	 cl, 8
  00046	8b fa		 mov	 edi, edx
  00048	ba 01 00 00 00	 mov	 edx, 1
  0004d	72 0c		 jb	 SHORT $L109890
  0004f	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  00052	76 05		 jbe	 SHORT $L109893
  00054	80 f9 11	 cmp	 cl, 17			; 00000011H
  00057	75 02		 jne	 SHORT $L109890
$L109893:

; 4283 : 		case DROP_HorizontalLine:
; 4284 : 		case DROP_VerticalLine:
; 4285 : 		case DROP_DiagonalLine1:
; 4286 : 		case DROP_DiagonalLine2:
; 4287 : 		case DROP_HorizontalOsc:
; 4288 : 		case DROP_VerticalOsc:
; 4289 : 		case DROP_DiagonalOsc1:
; 4290 : 		case DROP_DiagonalOsc2:
; 4291 : 		case DROP_AreaClamp:
; 4292 : 			Continuous = false;

  00059	33 d2		 xor	 edx, edx
$L109890:

; 4293 : 		break;
; 4294 : 	};
; 4295 : 
; 4296 : 	// Paint on the water.
; 4297 :     if( (Buttons & MOUSE_Left) && ( Continuous && (PosChanged  || LeftChanged ) ) )

  0005b	85 c0		 test	 eax, eax
  0005d	74 19		 je	 SHORT $L109894
  0005f	85 d2		 test	 edx, edx
  00061	74 15		 je	 SHORT $L109894
  00063	85 db		 test	 ebx, ebx
  00065	75 04		 jne	 SHORT $L109895
  00067	85 ff		 test	 edi, edi
  00069	74 0d		 je	 SHORT $L109894
$L109895:

; 4298 :         AddDrop( MouseX, MouseY);

  0006b	8b 44 24 18	 mov	 eax, DWORD PTR _Y$[esp+12]
  0006f	50		 push	 eax
  00070	55		 push	 ebp
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?AddDrop@UWaterTexture@@AAEXHH@Z ; UWaterTexture::AddDrop
$L109894:

; 4299 : 
; 4300 :     if( Buttons & MOUSE_Right )

  00078	f6 44 24 1c 02	 test	 BYTE PTR _Buttons$[esp+12], 2
  0007d	74 6d		 je	 SHORT $L120319

; 4301 :         DeleteDrops( MouseX, MouseY, DEL_RANGE);

  0007f	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  00085	33 db		 xor	 ebx, ebx
  00087	85 d2		 test	 edx, edx
  00089	7e 61		 jle	 SHORT $L120319
  0008b	8d 8e f3 00 00
	00		 lea	 ecx, DWORD PTR [esi+243]
  00091	eb 04		 jmp	 SHORT $L120317
$L120324:
  00093	8b 6c 24 14	 mov	 ebp, DWORD PTR _X$[esp+12]
$L120317:
  00097	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  0009b	d1 e0		 shl	 eax, 1
  0009d	8b f8		 mov	 edi, eax
  0009f	8b c5		 mov	 eax, ebp
  000a1	2b c7		 sub	 eax, edi
  000a3	79 02		 jns	 SHORT $L120327
  000a5	f7 d8		 neg	 eax
$L120327:
  000a7	8b f8		 mov	 edi, eax
  000a9	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  000ac	d1 e0		 shl	 eax, 1
  000ae	8b e8		 mov	 ebp, eax
  000b0	8b 44 24 18	 mov	 eax, DWORD PTR _Y$[esp+12]
  000b4	2b c5		 sub	 eax, ebp
  000b6	79 02		 jns	 SHORT $L120314
  000b8	f7 d8		 neg	 eax
$L120314:
  000ba	03 c7		 add	 eax, edi
  000bc	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000bf	7f 1d		 jg	 SHORT $L120318
  000c1	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000c4	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  000ca	8b 94 c6 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+240]
  000d1	89 51 fd	 mov	 DWORD PTR [ecx-3], edx
  000d4	8b 84 c6 f4 00
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+244]
  000db	89 41 01	 mov	 DWORD PTR [ecx+1], eax
$L120318:
  000de	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  000e4	43		 inc	 ebx
  000e5	83 c1 08	 add	 ecx, 8
  000e8	3b da		 cmp	 ebx, edx
  000ea	7c a7		 jl	 SHORT $L120324
$L120319:
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5d		 pop	 ebp
  000ef	5b		 pop	 ebx

; 4302 : }

  000f0	c2 0c 00	 ret	 12			; 0000000cH
?WaterPaint@UWaterTexture@@AAEXHHK@Z ENDP		; UWaterTexture::WaterPaint
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?MousePosition@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
_I$120333 = -4
_I$120338 = 16
?MousePosition@UWaterTexture@@UAEXKMM@Z PROC NEAR	; UWaterTexture::MousePosition, COMDAT
; _this$ = ecx

; 4306 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 4307 : 	WaterPaint(appRound(X),appRound(Y),Buttons);

  00007	d9 44 24 20	 fld	 DWORD PTR _Y$[esp+16]
  0000b	db 5c 24 10	 fistp	 DWORD PTR _I$120333[esp+20]
  0000f	d9 44 24 1c	 fld	 DWORD PTR _X$[esp+16]
  00013	db 5c 24 20	 fistp	 DWORD PTR _I$120338[esp+16]
  00017	8b 44 24 18	 mov	 eax, DWORD PTR _Buttons$[esp+16]
  0001b	8b 6c 24 20	 mov	 ebp, DWORD PTR _I$120338[esp+16]
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastMouseX@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00025	83 e0 01	 and	 eax, 1
  00028	3b cd		 cmp	 ecx, ebp
  0002a	75 10		 jne	 SHORT $L120395
  0002c	8b 4c 24 10	 mov	 ecx, DWORD PTR _I$120333[esp+20]
  00030	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?LastMouseY@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA, ecx
  00036	75 04		 jne	 SHORT $L120395
  00038	33 db		 xor	 ebx, ebx
  0003a	eb 05		 jmp	 SHORT $L120396
$L120395:
  0003c	bb 01 00 00 00	 mov	 ebx, 1
$L120396:
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?LastLeftButton@?1??WaterPaint@UWaterTexture@@AAEXHHK@Z@4HA
  00047	33 d2		 xor	 edx, edx
  00049	3b c8		 cmp	 ecx, eax
  0004b	8a 8e e0 00 00
	00		 mov	 cl, BYTE PTR [esi+224]
  00051	0f 95 c2	 setne	 dl
  00054	80 f9 08	 cmp	 cl, 8
  00057	8b fa		 mov	 edi, edx
  00059	ba 01 00 00 00	 mov	 edx, 1
  0005e	72 0c		 jb	 SHORT $L120389
  00060	80 f9 0f	 cmp	 cl, 15			; 0000000fH
  00063	76 05		 jbe	 SHORT $L120390
  00065	80 f9 11	 cmp	 cl, 17			; 00000011H
  00068	75 02		 jne	 SHORT $L120389
$L120390:
  0006a	33 d2		 xor	 edx, edx
$L120389:
  0006c	85 c0		 test	 eax, eax
  0006e	74 19		 je	 SHORT $L120391
  00070	85 d2		 test	 edx, edx
  00072	74 15		 je	 SHORT $L120391
  00074	85 db		 test	 ebx, ebx
  00076	75 04		 jne	 SHORT $L120392
  00078	85 ff		 test	 edi, edi
  0007a	74 0d		 je	 SHORT $L120391
$L120392:
  0007c	8b 44 24 10	 mov	 eax, DWORD PTR _I$120333[esp+20]
  00080	50		 push	 eax
  00081	55		 push	 ebp
  00082	8b ce		 mov	 ecx, esi
  00084	e8 00 00 00 00	 call	 ?AddDrop@UWaterTexture@@AAEXHH@Z ; UWaterTexture::AddDrop
$L120391:
  00089	f6 44 24 18 02	 test	 BYTE PTR _Buttons$[esp+16], 2
  0008e	74 6d		 je	 SHORT $L120410
  00090	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  00096	33 db		 xor	 ebx, ebx
  00098	85 d2		 test	 edx, edx
  0009a	7e 61		 jle	 SHORT $L120410
  0009c	8d 8e f3 00 00
	00		 lea	 ecx, DWORD PTR [esi+243]
  000a2	eb 04		 jmp	 SHORT $L120408
$L120415:
  000a4	8b 6c 24 20	 mov	 ebp, DWORD PTR _I$120338[esp+16]
$L120408:
  000a8	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  000ac	d1 e0		 shl	 eax, 1
  000ae	8b f8		 mov	 edi, eax
  000b0	8b c5		 mov	 eax, ebp
  000b2	2b c7		 sub	 eax, edi
  000b4	79 02		 jns	 SHORT $L120418
  000b6	f7 d8		 neg	 eax
$L120418:
  000b8	8b f8		 mov	 edi, eax
  000ba	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  000bd	d1 e0		 shl	 eax, 1
  000bf	8b e8		 mov	 ebp, eax
  000c1	8b 44 24 10	 mov	 eax, DWORD PTR _I$120333[esp+20]
  000c5	2b c5		 sub	 eax, ebp
  000c7	79 02		 jns	 SHORT $L120405
  000c9	f7 d8		 neg	 eax
$L120405:
  000cb	03 c7		 add	 eax, edi
  000cd	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000d0	7f 1d		 jg	 SHORT $L120409
  000d2	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000d5	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  000db	8b 94 c6 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+240]
  000e2	89 51 fd	 mov	 DWORD PTR [ecx-3], edx
  000e5	8b 84 c6 f4 00
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+244]
  000ec	89 41 01	 mov	 DWORD PTR [ecx+1], eax
$L120409:
  000ef	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  000f5	43		 inc	 ebx
  000f6	83 c1 08	 add	 ecx, 8
  000f9	3b da		 cmp	 ebx, edx
  000fb	7c a7		 jl	 SHORT $L120415
$L120410:
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5d		 pop	 ebp
  00100	5b		 pop	 ebx

; 4308 : }

  00101	59		 pop	 ecx
  00102	c2 0c 00	 ret	 12			; 0000000cH
?MousePosition@UWaterTexture@@UAEXKMM@Z ENDP		; UWaterTexture::MousePosition
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Click@UWaterTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
_MouseX$ = -4
_MouseY$ = 12
?Click@UWaterTexture@@UAEXKMM@Z PROC NEAR		; UWaterTexture::Click, COMDAT
; _this$ = ecx

; 4313 : {

  00000	51		 push	 ecx

; 4314 : 	INT MouseX=(INT) X, MouseY=(INT) Y;

  00001	d9 44 24 0c	 fld	 DWORD PTR _X$[esp]
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 __ftol
  00010	d9 44 24 20	 fld	 DWORD PTR _Y$[esp+16]
  00014	8b f8		 mov	 edi, eax
  00016	89 7c 24 10	 mov	 DWORD PTR _MouseX$[esp+20], edi
  0001a	e8 00 00 00 00	 call	 __ftol

; 4315 : 
; 4316 : 	// Paint on the water.
; 4317 :     if( Buttons & MOUSE_Left )

  0001f	8a 5c 24 18	 mov	 bl, BYTE PTR _Buttons$[esp+16]
  00023	f6 c3 01	 test	 bl, 1
  00026	8b e8		 mov	 ebp, eax
  00028	89 6c 24 1c	 mov	 DWORD PTR _MouseY$[esp+16], ebp
  0002c	74 09		 je	 SHORT $L109913

; 4318 : 	{
; 4319 :         AddDrop( MouseX, MouseY);

  0002e	55		 push	 ebp
  0002f	57		 push	 edi
  00030	8b ce		 mov	 ecx, esi
  00032	e8 00 00 00 00	 call	 ?AddDrop@UWaterTexture@@AAEXHH@Z ; UWaterTexture::AddDrop
$L109913:

; 4320 : 	}
; 4321 : 
; 4322 :     if( Buttons & MOUSE_Right )

  00037	f6 c3 02	 test	 bl, 2
  0003a	74 7b		 je	 SHORT $L120452

; 4323 :         DeleteDrops( MouseX, MouseY, DEL_RANGE);

  0003c	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  00042	33 db		 xor	 ebx, ebx
  00044	85 d2		 test	 edx, edx
  00046	7e 6f		 jle	 SHORT $L120452
  00048	8d 8e f3 00 00
	00		 lea	 ecx, DWORD PTR [esi+243]
  0004e	eb 08		 jmp	 SHORT $L120450
$L120457:
  00050	8b 6c 24 1c	 mov	 ebp, DWORD PTR _MouseY$[esp+16]
  00054	8b 7c 24 10	 mov	 edi, DWORD PTR _MouseX$[esp+20]
$L120450:
  00058	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  0005c	d1 e0		 shl	 eax, 1
  0005e	89 44 24 20	 mov	 DWORD PTR 16+[esp+16], eax
  00062	8b c7		 mov	 eax, edi
  00064	8b 7c 24 20	 mov	 edi, DWORD PTR 16+[esp+16]
  00068	2b c7		 sub	 eax, edi
  0006a	79 02		 jns	 SHORT $L120458
  0006c	f7 d8		 neg	 eax
$L120458:
  0006e	8b f8		 mov	 edi, eax
  00070	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00073	d1 e0		 shl	 eax, 1
  00075	89 44 24 20	 mov	 DWORD PTR 16+[esp+16], eax
  00079	8b c5		 mov	 eax, ebp
  0007b	8b 6c 24 20	 mov	 ebp, DWORD PTR 16+[esp+16]
  0007f	2b c5		 sub	 eax, ebp
  00081	79 02		 jns	 SHORT $L120447
  00083	f7 d8		 neg	 eax
$L120447:
  00085	03 c7		 add	 eax, edi
  00087	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0008a	7f 1d		 jg	 SHORT $L120451
  0008c	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  0008f	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax
  00095	8b 94 c6 f0 00
	00 00		 mov	 edx, DWORD PTR [esi+eax*8+240]
  0009c	89 51 fd	 mov	 DWORD PTR [ecx-3], edx
  0009f	8b 84 c6 f4 00
	00 00		 mov	 eax, DWORD PTR [esi+eax*8+244]
  000a6	89 41 01	 mov	 DWORD PTR [ecx+1], eax
$L120451:
  000a9	8b 96 ec 00 00
	00		 mov	 edx, DWORD PTR [esi+236]
  000af	43		 inc	 ebx
  000b0	83 c1 08	 add	 ecx, 8
  000b3	3b da		 cmp	 ebx, edx
  000b5	7c 99		 jl	 SHORT $L120457
$L120452:
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5d		 pop	 ebp
  000ba	5b		 pop	 ebx

; 4324 : }

  000bb	59		 pop	 ecx
  000bc	c2 0c 00	 ret	 12			; 0000000cH
?Click@UWaterTexture@@UAEXKMM@Z ENDP			; UWaterTexture::Click
_TEXT	ENDS
PUBLIC	??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'W', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'T', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E206
_TEXT	SEGMENT
_$E206	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	89 45 00	 mov	 DWORD PTR [ebp], eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?InternalConstructor@UTexture@@SAXPAX@Z
  00016	50		 push	 eax
  00017	68 04 40 08 04	 push	 67649540		; 04084004H
  0001c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  00021	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00026	33 c9		 xor	 ecx, ecx
  00028	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002b	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BM@IGJG@?$AAU?$AAW?$AAa?$AAt?$AAe?$AAr?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  00030	83 ec 10	 sub	 esp, 16			; 00000010H
  00033	33 d2		 xor	 edx, edx
  00035	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00038	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003e	8b cc		 mov	 ecx, esp
  00040	52		 push	 edx
  00041	33 f6		 xor	 esi, esi
  00043	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00046	33 ff		 xor	 edi, edi
  00048	89 39		 mov	 DWORD PTR [ecx], edi
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  0004f	33 c0		 xor	 eax, eax
  00051	33 db		 xor	 ebx, ebx
  00053	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00056	6a 01		 push	 1
  00058	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0005b	68 00 13 00 00	 push	 4864			; 00001300H
  00060	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00063	50		 push	 eax
  00064	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:_$E203
  00074	e8 00 00 00 00	 call	 _atexit
  00079	83 c4 04	 add	 esp, 4
  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5d		 pop	 ebp
  0007f	5b		 pop	 ebx
  00080	c3		 ret	 0
_$E206	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S204	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E203
_TEXT	SEGMENT
_$E203	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S204
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L109927
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S204, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L109927:
  0001f	c3		 ret	 0
_$E203	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E209
_TEXT	SEGMENT
_$E209	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUWaterTexture, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E209	ENDP
_TEXT	ENDS
PUBLIC	??0UWaveTexture@@QAE@XZ				; UWaveTexture::UWaveTexture
PUBLIC	?PostLoad@UWaveTexture@@UAEXXZ			; UWaveTexture::PostLoad
PUBLIC	?Init@UWaveTexture@@UAEXHH@Z			; UWaveTexture::Init
PUBLIC	?Clear@UWaveTexture@@UAEXK@Z			; UWaveTexture::Clear
PUBLIC	?ConstantTimeTick@UWaveTexture@@UAEXXZ		; UWaveTexture::ConstantTimeTick
PUBLIC	??_7UWaveTexture@@6B@				; UWaveTexture::`vftable'
PUBLIC	??_EUWaveTexture@@UAEPAXI@Z			; UWaveTexture::`vector deleting destructor'
;	COMDAT ??_7UWaveTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UWaveTexture@@6B@ DD FLAT:??_EUWaveTexture@@UAEPAXI@Z ; UWaveTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UWaveTexture@@UAEXXZ
	DD	FLAT:?Destroy@UWaterTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UWaveTexture@@UAEXK@Z
	DD	FLAT:?Init@UWaveTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UWaveTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UWaterTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UWaveTexture@@QAE@XZ
_TEXT	SEGMENT
??0UWaveTexture@@QAE@XZ PROC NEAR			; UWaveTexture::UWaveTexture, COMDAT
; _this$ = ecx

; 4336 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  0000c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00012	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0001b	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00021	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00026	33 c0		 xor	 eax, eax
  00028	b9 08 f1 ff ff	 mov	 ecx, -3832		; fffff108H
  0002d	33 ff		 xor	 edi, edi
  0002f	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  00035	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0003b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00041	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00047	8d ae f8 0c 00
	00		 lea	 ebp, DWORD PTR [esi+3320]
  0004d	2b ce		 sub	 ecx, esi

; 4337 : }

  0004f	90		 npad	 1

; 4336 : {

$L120536:
  00050	33 db		 xor	 ebx, ebx
  00052	8d 04 29	 lea	 eax, DWORD PTR [ecx+ebp]
  00055	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0005a	0f 9c c3	 setl	 bl
  0005d	8b c7		 mov	 eax, edi
  0005f	99		 cdq
  00060	2b c2		 sub	 eax, edx
  00062	d1 f8		 sar	 eax, 1
  00064	8d 84 03 00 ff
	ff ff		 lea	 eax, DWORD PTR [ebx+eax-256]
  0006b	85 c0		 test	 eax, eax
  0006d	7d 04		 jge	 SHORT $L120548
  0006f	33 c0		 xor	 eax, eax
  00071	eb 0c		 jmp	 SHORT $L120547
$L120548:
  00073	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00078	7c 05		 jl	 SHORT $L120547
  0007a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L120547:
  0007f	47		 inc	 edi
  00080	88 45 00	 mov	 BYTE PTR [ebp], al
  00083	45		 inc	 ebp
  00084	81 ff 00 06 00
	00		 cmp	 edi, 1536		; 00000600H
  0008a	7c c4		 jl	 SHORT $L120536
  0008c	5f		 pop	 edi
  0008d	c7 86 fc 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4860], -1
  00097	c6 86 f8 12 00
	00 00		 mov	 BYTE PTR [esi+4856], 0
  0009e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaveTexture@@6B@ ; UWaveTexture::`vftable'

; 4337 : }

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi
  000a7	5d		 pop	 ebp
  000a8	5b		 pop	 ebx
  000a9	c3		 ret	 0
??0UWaveTexture@@QAE@XZ ENDP				; UWaveTexture::UWaveTexture
_TEXT	ENDS
PUBLIC	??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ ; `string'
;	COMDAT ??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
; File ..\..\Core\Inc\UnTemplate.h
_DATA	SEGMENT
??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'W'
	DB	00H, 'a', 00H, 'v', 00H, 'e', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ DB 'B'
	DB	00H, 'u', 00H, 'm', 00H, 'p', 00H, 'M', 00H, 'a', 00H, 'p', 00H
	DB	'A', 00H, 'n', 00H, 'g', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
_DATA	ENDS
;	COMDAT ?Init@UWaveTexture@@UAEXHH@Z
_TEXT	SEGMENT
_InUSize$ = 8
_InVSize$ = 12
_this$ = -4
$T120705 = 12
?Init@UWaveTexture@@UAEXHH@Z PROC NEAR			; UWaveTexture::Init, COMDAT
; _this$ = ecx

; 4340 : {

  00000	51		 push	 ecx

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

  00001	a1 18 00 00 00	 mov	 eax, DWORD PTR ?PrivateStaticClass@UWaveTexture@@0VUClass@@A+24
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	6a 00		 push	 0
  0000c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  00011	50		 push	 eax
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UClass@@0V1@A
  00017	8b f9		 mov	 edi, ecx
  00019	50		 push	 eax
  0001a	89 7c 24 20	 mov	 DWORD PTR _this$[esp+36], edi
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticFindObjectChecked@UObject@@SAPAV1@PAVUClass@@PAV1@PBGH@Z
  00024	8b d8		 mov	 ebx, eax
  00026	83 c4 10	 add	 esp, 16			; 00000010H
  00029	85 db		 test	 ebx, ebx
  0002b	74 05		 je	 SHORT $L120611
  0002d	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00030	eb 02		 jmp	 SHORT $L120612
$L120611:
  00032	33 f6		 xor	 esi, esi
$L120612:
  00034	85 db		 test	 ebx, ebx
  00036	74 47		 je	 SHORT $L120740
$L120614:
  00038	85 f6		 test	 esi, esi
  0003a	74 31		 je	 SHORT $L120617
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A
$L120616:
  00042	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00045	85 c0		 test	 eax, eax
  00047	74 12		 je	 SHORT $L120627

; 4358 : }

  00049	8d a4 24 00 00
	00 00		 npad	 7

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

$L120625:
  00050	3b c1		 cmp	 eax, ecx
  00052	74 2b		 je	 SHORT $L120740
  00054	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00057	85 c0		 test	 eax, eax
  00059	75 f5		 jne	 SHORT $L120625
$L120627:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c9		 test	 ecx, ecx
  0005f	0f 94 c0	 sete	 al
  00062	85 c0		 test	 eax, eax
  00064	75 19		 jne	 SHORT $L120740
  00066	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00069	85 f6		 test	 esi, esi
  0006b	75 d5		 jne	 SHORT $L120616
$L120617:
  0006d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0006f	8b cb		 mov	 ecx, ebx
  00071	ff 52 5c	 call	 DWORD PTR [edx+92]
  00074	8b d8		 mov	 ebx, eax
  00076	85 db		 test	 ebx, ebx
  00078	74 05		 je	 SHORT $L120740
  0007a	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  0007d	eb b9		 jmp	 SHORT $L120614
$L120740:
  0007f	85 f6		 test	 esi, esi
  00081	0f 84 ab 00 00
	00		 je	 $L109956
  00087	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?appStricmp@@YAHPBG0@Z
  0008d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Logf@FOutputDevice@@QAAXPBGZZ
$L120664:
  00093	8b 06		 mov	 eax, DWORD PTR [esi]
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ ; `string'
  0009a	8b ce		 mov	 ecx, esi
  0009c	ff 50 44	 call	 DWORD PTR [eax+68]
  0009f	50		 push	 eax
  000a0	ff d7		 call	 edi
  000a2	83 c4 08	 add	 esp, 8
  000a5	85 c0		 test	 eax, eax
  000a7	75 2d		 jne	 SHORT $L109955
  000a9	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000ac	3d 01 13 00 00	 cmp	 eax, 4865		; 00001301H
  000b1	74 23		 je	 SHORT $L109955
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	68 01 13 00 00	 push	 4865			; 00001301H
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@BJIE@?$AAB?$AAu?$AAm?$AAp?$AAM?$AAa?$AAp?$AAA?$AAn?$AAg?$AAl?$AAe?$AA?$AA@ ; `string'
  000c6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@GIPJ@?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1FK@OIBJ@?$AAC?$AAl?$AAa?$AAs?$AAs?$AA?5?$AA?$CF?$AAs?$AA?5?$AAM?$AAe?$AAm?$AAb?$AAe?$AAr?$AA?5?$AA?$CF?$AAs?$AA?5?$AAp@ ; `string'
  000d0	52		 push	 edx
  000d1	ff d5		 call	 ebp
  000d3	83 c4 18	 add	 esp, 24			; 00000018H
$L109955:
  000d6	85 db		 test	 ebx, ebx
  000d8	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  000db	74 49		 je	 SHORT $L120742

; 4358 : }

  000dd	8d 49 00	 npad	 3

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

$L120666:
  000e0	85 f6		 test	 esi, esi
  000e2	74 30		 je	 SHORT $L120669
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?PrivateStaticClass@UProperty@@0VUClass@@A

; 4358 : }

  000ea	8d 9b 00 00 00
	00		 npad	 6

; 4341 : 	VERIFY_CLASS_OFFSET(U,WaveTexture,BumpMapAngle);

$L120668:
  000f0	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000f3	85 c0		 test	 eax, eax
  000f5	74 0b		 je	 SHORT $L120679
$L120677:
  000f7	3b c1		 cmp	 eax, ecx
  000f9	74 2b		 je	 SHORT $L120742
  000fb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000fe	85 c0		 test	 eax, eax
  00100	75 f5		 jne	 SHORT $L120677
$L120679:
  00102	33 c0		 xor	 eax, eax
  00104	85 c9		 test	 ecx, ecx
  00106	0f 94 c0	 sete	 al
  00109	85 c0		 test	 eax, eax
  0010b	75 19		 jne	 SHORT $L120742
  0010d	8b 76 2c	 mov	 esi, DWORD PTR [esi+44]
  00110	85 f6		 test	 esi, esi
  00112	75 dc		 jne	 SHORT $L120668
$L120669:
  00114	8b 03		 mov	 eax, DWORD PTR [ebx]
  00116	8b cb		 mov	 ecx, ebx
  00118	ff 50 5c	 call	 DWORD PTR [eax+92]
  0011b	8b d8		 mov	 ebx, eax
  0011d	85 db		 test	 ebx, ebx
  0011f	74 05		 je	 SHORT $L120742
  00121	8b 73 40	 mov	 esi, DWORD PTR [ebx+64]
  00124	eb ba		 jmp	 SHORT $L120666
$L120742:
  00126	85 f6		 test	 esi, esi
  00128	0f 85 65 ff ff
	ff		 jne	 $L120664
  0012e	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
$L109956:

; 4342 : 
; 4343 : 	// Init base class.
; 4344 : 	UWaterTexture::Init( InUSize, InVSize );

  00132	8b 4c 24 1c	 mov	 ecx, DWORD PTR _InVSize$[esp+16]
  00136	8b 54 24 18	 mov	 edx, DWORD PTR _InUSize$[esp+16]
  0013a	51		 push	 ecx
  0013b	52		 push	 edx
  0013c	8b cf		 mov	 ecx, edi
  0013e	e8 00 00 00 00	 call	 ?Init@UWaterTexture@@UAEXHH@Z ; UWaterTexture::Init

; 4345 : 
; 4346 : 	BumpMapAngle = 170;
; 4347 : 	BumpMapLight = 50;
; 4348 : 
; 4349 : 	PhongRange = 180;
; 4350 : 	PhongSize  = 32;
; 4351 : 
; 4352 : 	// Create a custom palette.	
; 4353 : 	Palette = new( GetOuter() )UPalette;

  00143	6a 00		 push	 0
  00145	8d 4c 24 20	 lea	 ecx, DWORD PTR $T120705[esp+20]
  00149	c6 87 01 13 00
	00 aa		 mov	 BYTE PTR [edi+4865], 170 ; 000000aaH
  00150	c6 87 00 13 00
	00 32		 mov	 BYTE PTR [edi+4864], 50	; 00000032H
  00157	c6 87 02 13 00
	00 b4		 mov	 BYTE PTR [edi+4866], 180 ; 000000b4H
  0015e	c6 87 03 13 00
	00 20		 mov	 BYTE PTR [edi+4867], 32	; 00000020H
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  0016b	8b cf		 mov	 ecx, edi
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00173	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00179	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017b	8b 4c 24 1c	 mov	 ecx, DWORD PTR $T120705[esp+16]
  0017f	6a 00		 push	 0
  00181	52		 push	 edx
  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00188	6a 00		 push	 0
  0018a	6a 00		 push	 0
  0018c	51		 push	 ecx
  0018d	50		 push	 eax
  0018e	52		 push	 edx
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00195	8b f0		 mov	 esi, eax
  00197	83 c4 1c	 add	 esp, 28			; 0000001cH
  0019a	85 f6		 test	 esi, esi
  0019c	74 1e		 je	 SHORT $L120557
  0019e	8b ce		 mov	 ecx, esi
  001a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  001a6	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  001ac	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  001b2	89 77 2c	 mov	 DWORD PTR [edi+44], esi
  001b5	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  001ba	eb 16		 jmp	 SHORT $L109972
$L120557:
  001bc	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  001c2	33 f6		 xor	 esi, esi
  001c4	89 77 2c	 mov	 DWORD PTR [edi+44], esi
  001c7	bb 00 01 00 00	 mov	 ebx, 256		; 00000100H
  001cc	eb 04		 jmp	 SHORT $L109972
$L120749:
  001ce	8b 7c 24 10	 mov	 edi, DWORD PTR _this$[esp+20]
$L109972:

; 4355 : 		new(Palette->Colors)FColor(0,0,0);

  001d2	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  001d5	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  001d8	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001db	83 c6 28	 add	 esi, 40			; 00000028H
  001de	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  001e1	3b c8		 cmp	 ecx, eax
  001e3	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  001e6	7e 19		 jle	 SHORT $L120721
  001e8	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  001eb	99		 cdq
  001ec	83 e2 07	 and	 edx, 7
  001ef	03 c2		 add	 eax, edx
  001f1	c1 f8 03	 sar	 eax, 3
  001f4	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  001f8	6a 04		 push	 4
  001fa	8b ce		 mov	 ecx, esi
  001fc	89 46 08	 mov	 DWORD PTR [esi+8], eax
  001ff	ff d5		 call	 ebp
$L120721:
  00201	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00203	8d 04 b9	 lea	 eax, DWORD PTR [ecx+edi*4]
  00206	85 c0		 test	 eax, eax
  00208	74 0b		 je	 SHORT $L109973
  0020a	c6 00 00	 mov	 BYTE PTR [eax], 0
  0020d	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
  00211	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$L109973:

; 4354 : 	for( INT i=0; i<256; i++ )

  00215	4b		 dec	 ebx
  00216	75 b6		 jne	 SHORT $L120749

; 4356 : 	BlueLagunaPalette(Palette);

  00218	8b 74 24 10	 mov	 esi, DWORD PTR _this$[esp+20]
  0021c	8b 56 2c	 mov	 edx, DWORD PTR [esi+44]
  0021f	52		 push	 edx
  00220	e8 00 00 00 00	 call	 ?BlueLagunaPalette@@YAXPAVUPalette@@@Z ; BlueLagunaPalette

; 4357 : 	MipZero = Palette->Colors(128);

  00225	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00228	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0022b	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  00231	83 c4 04	 add	 esp, 4
  00234	5f		 pop	 edi
  00235	89 56 44	 mov	 DWORD PTR [esi+68], edx
  00238	5e		 pop	 esi
  00239	5d		 pop	 ebp
  0023a	5b		 pop	 ebx

; 4358 : }

  0023b	59		 pop	 ecx
  0023c	c2 08 00	 ret	 8
?Init@UWaveTexture@@UAEXHH@Z ENDP			; UWaveTexture::Init
_TEXT	ENDS
PUBLIC	?SetWaveLight@UWaveTexture@@QAEXXZ		; UWaveTexture::SetWaveLight
; Function compile flags: /Ogty
;	COMDAT ?PostLoad@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT
_NewPalette$109987 = -8
$T120798 = -4
?PostLoad@UWaveTexture@@UAEXXZ PROC NEAR		; UWaveTexture::PostLoad, COMDAT
; _this$ = ecx

; 4361 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	55		 push	 ebp
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 4362 : 	Super::PostLoad();

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  0000d	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00010	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00013	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00019	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0001c	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0001f	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx
  00025	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  0002b	33 ed		 xor	 ebp, ebp
  0002d	3b d5		 cmp	 edx, ebp
  0002f	75 4d		 jne	 SHORT $L120775
  00031	0f af c1	 imul	 eax, ecx
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  0003a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003c	99		 cdq
  0003d	2b c2		 sub	 eax, edx
  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	d1 f8		 sar	 eax, 1
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00048	50		 push	 eax
  00049	ff 12		 call	 DWORD PTR [edx]
  0004b	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax
  00051	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00054	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00058	99		 cdq
  00059	2b c2		 sub	 eax, edx
  0005b	d1 f8		 sar	 eax, 1
  0005d	33 c9		 xor	 ecx, ecx
  0005f	85 c0		 test	 eax, eax
  00061	7e 1b		 jle	 SHORT $L120775
$L120773:
  00063	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00069	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0006d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00070	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00074	99		 cdq
  00075	2b c2		 sub	 eax, edx
  00077	41		 inc	 ecx
  00078	d1 f8		 sar	 eax, 1
  0007a	3b c8		 cmp	 ecx, eax
  0007c	7c e5		 jl	 SHORT $L120773
$L120775:

; 4363 : 
; 4364 : 	// Make sure the texture has its _own_ copy of the palette.
; 4365 : #if COPYPALETTE	
; 4366 : 	if( ( Palette!=NULL ) && ( GetOuter()!=Palette->GetOuter() ) )

  0007e	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00081	3b c5		 cmp	 eax, ebp
  00083	0f 84 f2 00 00
	00		 je	 $L109986
  00089	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0008c	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0008f	0f 84 e6 00 00
	00		 je	 $L109986

; 4367 : 	{
; 4368 : 		UPalette* NewPalette = new( GetOuter(), GetName() )UPalette;

  00095	8b 16		 mov	 edx, DWORD PTR [esi]
  00097	53		 push	 ebx
  00098	57		 push	 edi
  00099	6a 01		 push	 1
  0009b	8b ce		 mov	 ecx, esi
  0009d	ff 52 44	 call	 DWORD PTR [edx+68]
  000a0	50		 push	 eax
  000a1	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T120798[esp+32]
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@PBGW4EFindName@@@Z
  000ab	8b ce		 mov	 ecx, esi
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  000b9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bb	8b 4c 24 14	 mov	 ecx, DWORD PTR $T120798[esp+24]
  000bf	55		 push	 ebp
  000c0	52		 push	 edx
  000c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  000c7	55		 push	 ebp
  000c8	55		 push	 ebp
  000c9	51		 push	 ecx
  000ca	50		 push	 eax
  000cb	52		 push	 edx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  000d2	8b f8		 mov	 edi, eax
  000d4	83 c4 1c	 add	 esp, 28			; 0000001cH
  000d7	3b fd		 cmp	 edi, ebp
  000d9	74 14		 je	 SHORT $L120756
  000db	8b cf		 mov	 ecx, edi
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  000e3	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  000e9	89 7c 24 10	 mov	 DWORD PTR _NewPalette$109987[esp+24], edi
  000ed	eb 04		 jmp	 SHORT $L120757
$L120756:
  000ef	89 6c 24 10	 mov	 DWORD PTR _NewPalette$109987[esp+24], ebp
$L120757:
  000f3	8b 44 24 10	 mov	 eax, DWORD PTR _NewPalette$109987[esp+24]
  000f7	8d 78 28	 lea	 edi, DWORD PTR [eax+40]

; 4381 : }

  000fa	8d 9b 00 00 00
	00		 npad	 6

; 4367 : 	{
; 4368 : 		UPalette* NewPalette = new( GetOuter(), GetName() )UPalette;

$L109996:

; 4369 : 		//NewPalette->Colors = Palette->Colors;
; 4370 : 		for( INT i=0; i<256; i++ )
; 4371 : 			new(NewPalette->Colors)FColor( Palette->Colors(i) );

  00100	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00103	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00106	8d 4b 01	 lea	 ecx, DWORD PTR [ebx+1]
  00109	3b c8		 cmp	 ecx, eax
  0010b	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0010e	7e 1d		 jle	 SHORT $L120814
  00110	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00113	99		 cdq
  00114	83 e2 07	 and	 edx, 7
  00117	03 c2		 add	 eax, edx
  00119	c1 f8 03	 sar	 eax, 3
  0011c	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00120	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00123	6a 04		 push	 4
  00125	8b cf		 mov	 ecx, edi
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L120814:
  0012d	8b 17		 mov	 edx, DWORD PTR [edi]
  0012f	8d 04 9a	 lea	 eax, DWORD PTR [edx+ebx*4]
  00132	85 c0		 test	 eax, eax
  00134	74 0b		 je	 SHORT $L109997
  00136	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  00139	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0013c	8b 0c 2a	 mov	 ecx, DWORD PTR [edx+ebp]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
$L109997:
  00141	83 c5 04	 add	 ebp, 4
  00144	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  0014a	7c b4		 jl	 SHORT $L109996

; 4372 : 		Palette = NewPalette->ReplaceWithExisting();

  0014c	8b 4c 24 10	 mov	 ecx, DWORD PTR _NewPalette$109987[esp+24]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ReplaceWithExisting@UPalette@@QAEPAV1@XZ
  00156	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 4373 : 		MipZero = Palette->Colors(128);

  00159	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  0015c	8b 82 00 02 00
	00		 mov	 eax, DWORD PTR [edx+512]

; 4374 : 		GCache.Flush();

  00162	6a 00		 push	 0
  00164	6a ff		 push	 -1
  00166	6a 00		 push	 0
  00168	89 46 44	 mov	 DWORD PTR [esi+68], eax
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GCache@@3VFMemCache@@A
  00171	6a 00		 push	 0
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Flush@FMemCache@@QAEX_KKH@Z
  00179	5f		 pop	 edi
  0017a	5b		 pop	 ebx
$L109986:

; 4375 : 	}
; 4376 : #endif
; 4377 : 	
; 4378 : 	// Recalculate the rendering LUT
; 4379 : 	// Depends on: WaveAmp, PhongRange, and PhongSize.
; 4380 : 	SetWaveLight(); //TODO: Check params before superfluous updates ??

  0017b	8b ce		 mov	 ecx, esi
  0017d	e8 00 00 00 00	 call	 ?SetWaveLight@UWaveTexture@@QAEXXZ ; UWaveTexture::SetWaveLight
  00182	5e		 pop	 esi
  00183	5d		 pop	 ebp

; 4381 : }

  00184	83 c4 08	 add	 esp, 8
  00187	c3		 ret	 0
?PostLoad@UWaveTexture@@UAEXXZ ENDP			; UWaveTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UWaveTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UWaveTexture@@UAEXK@Z PROC NEAR			; UWaveTexture::Clear, COMDAT
; _this$ = ecx

; 4384 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 4385 : 	// Init to zero.
; 4386 : 	UWaterTexture::Clear( ClearFlags );

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _ClearFlags$[esp+8]
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z
  00010	8b df		 mov	 ebx, edi
  00012	83 e3 02	 and	 ebx, 2
  00015	74 34		 je	 SHORT $L120838
  00017	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0001a	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  0001e	99		 cdq
  0001f	2b c2		 sub	 eax, edx
  00021	d1 f8		 sar	 eax, 1
  00023	33 c9		 xor	 ecx, ecx
  00025	85 c0		 test	 eax, eax
  00027	7e 22		 jle	 SHORT $L120838

; 4396 : }

  00029	8d a4 24 00 00
	00 00		 npad	 7

; 4385 : 	// Init to zero.
; 4386 : 	UWaterTexture::Clear( ClearFlags );

$L120836:
  00030	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00036	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0003a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	41		 inc	 ecx
  00045	d1 f8		 sar	 eax, 1
  00047	3b c8		 cmp	 ecx, eax
  00049	7c e5		 jl	 SHORT $L120836
$L120838:
  0004b	83 e7 01	 and	 edi, 1
  0004e	74 0a		 je	 SHORT $L120839
  00050	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L120839:

; 4387 : 
; 4388 : 	// Clear fields.
; 4389 : 	if( ClearFlags & TCLEAR_Bitmap )

  0005a	85 db		 test	 ebx, ebx
  0005c	74 2d		 je	 SHORT $L110015

; 4390 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  0005e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00061	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00065	99		 cdq
  00066	2b c2		 sub	 eax, edx
  00068	d1 f8		 sar	 eax, 1
  0006a	33 c9		 xor	 ecx, ecx
  0006c	85 c0		 test	 eax, eax
  0006e	7e 1b		 jle	 SHORT $L110015
$L110013:

; 4391 : 			SourceFields[i] = 128;

  00070	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  00076	c6 04 11 80	 mov	 BYTE PTR [ecx+edx], 128	; 00000080H
  0007a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0007d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00081	99		 cdq
  00082	2b c2		 sub	 eax, edx
  00084	41		 inc	 ecx
  00085	d1 f8		 sar	 eax, 1
  00087	3b c8		 cmp	 ecx, eax
  00089	7c e5		 jl	 SHORT $L110013
$L110015:

; 4392 : 
; 4393 : 	// Clear drops.
; 4394 : 	if( ClearFlags & TCLEAR_Temporal )

  0008b	85 ff		 test	 edi, edi
  0008d	74 0a		 je	 SHORT $L110016

; 4395 : 		NumDrops=0;

  0008f	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L110016:
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 4396 : }

  0009c	c2 04 00	 ret	 4
?Clear@UWaveTexture@@UAEXK@Z ENDP			; UWaveTexture::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWaveTexture@@UAEXXZ
_TEXT	SEGMENT
?ConstantTimeTick@UWaveTexture@@UAEXXZ PROC NEAR	; UWaveTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4399 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4400 : 	if( (USize>=8) && (VSize>=8) ) // safe sizes ?

  00003	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00006	b8 08 00 00 00	 mov	 eax, 8
  0000b	3b c8		 cmp	 ecx, eax
  0000d	7c 14		 jl	 SHORT $L110020
  0000f	39 46 38	 cmp	 DWORD PTR [esi+56], eax
  00012	7c 0f		 jl	 SHORT $L110020

; 4401 : 	{
; 4402 : 		WaterRedrawDrops();

  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?WaterRedrawDrops@UWaterTexture@@QAEXXZ ; UWaterTexture::WaterRedrawDrops

; 4403 : 		CalculateWater(); 

  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	e9 00 00 00 00	 jmp	 ?CalculateWater@UWaterTexture@@QAEXXZ ; UWaterTexture::CalculateWater
$L110020:
  00023	5e		 pop	 esi

; 4404 : 	}
; 4405 : }

  00024	c3		 ret	 0
?ConstantTimeTick@UWaveTexture@@UAEXXZ ENDP		; UWaveTexture::ConstantTimeTick
_TEXT	ENDS
PUBLIC	__real@44000000
PUBLIC	__real@3ba72f05
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@3b000000
PUBLIC	__real@3f893b368acefc14
PUBLIC	__real@3b808081
;	COMDAT __real@3f893b368acefc14
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
__real@3f893b368acefc14 DQ 03f893b368acefc14r	; 0.01232
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@44000000
CONST	SEGMENT
__real@44000000 DD 044000000r			; 512
CONST	ENDS
;	COMDAT __real@3ba72f05
CONST	SEGMENT
__real@3ba72f05 DD 03ba72f05r			; 0.00510204
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3b000000
CONST	SEGMENT
__real@3b000000 DD 03b000000r			; 0.00195313
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ?SetWaveLight@UWaveTexture@@QAEXXZ
_TEXT	SEGMENT
_i$ = -8
_PhongRadius$110035 = -8
?SetWaveLight@UWaveTexture@@QAEXXZ PROC NEAR		; UWaveTexture::SetWaveLight, COMDAT
; _this$ = ecx

; 4409 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 4410 : 	// Compute shades for surface normals.
; 4411 :     FLOAT Lamp   = PI * BumpMapLight / 255.0;

  00009	0f b6 87 00 13
	00 00		 movzx	 eax, BYTE PTR [edi+4864]

; 4412 :     FLOAT Viewer = PI * BumpMapAngle / 255.0;

  00010	0f b6 8f 01 13
	00 00		 movzx	 ecx, BYTE PTR [edi+4865]
  00017	89 44 24 10	 mov	 DWORD PTR -8+[esp+24], eax

; 4413 : 
; 4414 :     for( INT i=0; i<1024 ; i++ )

  0001b	33 ed		 xor	 ebp, ebp
  0001d	db 44 24 10	 fild	 DWORD PTR -8+[esp+24]
  00021	89 4c 24 10	 mov	 DWORD PTR -8+[esp+24], ecx
  00025	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f893b368acefc14
  0002b	db 44 24 10	 fild	 DWORD PTR -8+[esp+24]
  0002f	89 6c 24 10	 mov	 DWORD PTR _i$[esp+24], ebp
  00033	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f893b368acefc14

; 4432 :     }
; 4433 : }

  00039	8d a4 24 00 00
	00 00		 npad	 7

; 4413 : 
; 4414 :     for( INT i=0; i<1024 ; i++ )

$L110027:

; 4415 :     {
; 4416 : 		// Get reflection magnitude.
; 4417 :         FLOAT Normal = FakeAtan(  ((FLOAT)WaveAmp/255.0F) * (512.0F - (float)i) / 196.0F )  + (PI * 0.5F);

  00040	0f b6 97 e1 00
	00 00		 movzx	 edx, BYTE PTR [edi+225]
  00047	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  0004b	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  0004f	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b808081
  00055	db 44 24 10	 fild	 DWORD PTR _i$[esp+24]
  00059	d8 2d 00 00 00
	00		 fsubr	 DWORD PTR __real@44000000
  0005f	de c9		 fmulp	 ST(1), ST(0)
  00061	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3ba72f05
  00067	d9 c0		 fld	 ST(0)
  00069	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  0006f	df e0		 fnstsw	 ax
  00071	f6 c4 01	 test	 ah, 1
  00074	74 02		 je	 SHORT $L120866
  00076	d9 e0		 fchs
$L120866:
  00078	d9 c9		 fxch	 ST(1)
  0007a	0f b6 9f 02 13
	00 00		 movzx	 ebx, BYTE PTR [edi+4866]
  00081	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3ff921cac0000000

; 4418 : 
; 4419 :         // Max in this palette is 255, diffuse light reaches to 256-(PhongRange/2). 
; 4420 :         INT  TempLight = (INT) ( (256-(PhongRange/2)) * appCos ( Normal- Lamp ) );   //* ((FLOAT)WaveAmp/256.0F) );

  00087	8b c3		 mov	 eax, ebx
  00089	d9 c9		 fxch	 ST(1)
  0008b	d1 e8		 shr	 eax, 1
  0008d	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff0000000000000
  00093	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00098	2b c8		 sub	 ecx, eax
  0009a	de f9		 fdivp	 ST(1), ST(0)
  0009c	89 4c 24 14	 mov	 DWORD PTR -4+[esp+24], ecx
  000a0	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3ff921fb54442d18
  000a6	d9 c0		 fld	 ST(0)
  000a8	d8 e3		 fsub	 ST(0), ST(3)
  000aa	d9 ff		 fcos
  000ac	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  000b0	de c9		 fmulp	 ST(1), ST(0)
  000b2	e8 00 00 00 00	 call	 __ftol

; 4421 : 
; 4422 :         // Create a phong-ish highlight.
; 4423 :         // Based on angle between viewer direction and reflected light:
; 4424 :         // Reflected light angle : = Normal*2 - Lamp.
; 4425 : 		// Old defaults: PhongRange = 75; PhongRadius=0.11;
; 4426 : 		FLOAT PhongRadius = (FLOAT) PhongSize / 512.0f; 

  000b7	0f b6 97 03 13
	00 00		 movzx	 edx, BYTE PTR [edi+4867]
  000be	89 54 24 14	 mov	 DWORD PTR -4+[esp+24], edx
  000c2	8b f0		 mov	 esi, eax
  000c4	db 44 24 14	 fild	 DWORD PTR -4+[esp+24]
  000c8	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  000ce	d9 5c 24 10	 fstp	 DWORD PTR _PhongRadius$110035[esp+24]

; 4427 :         FLOAT Reflected = (Normal*2 - Lamp);

  000d2	dc c0		 fadd	 ST(0), ST(0)
  000d4	d8 e2		 fsub	 ST(0), ST(2)

; 4428 :         if( Square(Reflected-Viewer) < Square(PhongRadius) )

  000d6	d8 e1		 fsub	 ST(0), ST(1)
  000d8	d9 c0		 fld	 ST(0)
  000da	d9 c0		 fld	 ST(0)
  000dc	d8 c9		 fmul	 ST(0), ST(1)
  000de	d9 44 24 10	 fld	 DWORD PTR _PhongRadius$110035[esp+24]
  000e2	d8 4c 24 10	 fmul	 DWORD PTR _PhongRadius$110035[esp+24]
  000e6	de d9		 fcompp
  000e8	df e0		 fnstsw	 ax
  000ea	dd d8		 fstp	 ST(0)
  000ec	f6 c4 41	 test	 ah, 65			; 00000041H
  000ef	75 2b		 jne	 SHORT $L120912

; 4429 :             TempLight +=  (INT) ((PhongRange * 2 ) * (PhongRadius - Abs(Reflected-Viewer)) / PhongRadius);

  000f1	d8 15 00 00 00
	00		 fcom	 DWORD PTR __real@00000000
  000f7	df e0		 fnstsw	 ax
  000f9	f6 c4 01	 test	 ah, 1
  000fc	74 02		 je	 SHORT $L120885
  000fe	d9 e0		 fchs
$L120885:
  00100	d9 44 24 10	 fld	 DWORD PTR _PhongRadius$110035[esp+24]
  00104	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00107	d8 e1		 fsub	 ST(0), ST(1)
  00109	89 44 24 14	 mov	 DWORD PTR -4+[esp+24], eax
  0010d	d8 74 24 10	 fdiv	 DWORD PTR _PhongRadius$110035[esp+24]
  00111	da 4c 24 14	 fimul	 DWORD PTR -4+[esp+24]
  00115	e8 00 00 00 00	 call	 __ftol
  0011a	03 f0		 add	 esi, eax
$L120912:

; 4430 : 
; 4431 :         RenderTable[i] = Clamp( TempLight, 0, 255 );

  0011c	85 f6		 test	 esi, esi
  0011e	dd d8		 fstp	 ST(0)
  00120	7d 04		 jge	 SHORT $L120896
  00122	33 c0		 xor	 eax, eax
  00124	eb 0f		 jmp	 SHORT $L120895
$L120896:
  00126	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  0012c	8b c6		 mov	 eax, esi
  0012e	7c 05		 jl	 SHORT $L120895
  00130	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L120895:
  00135	88 84 2f f4 08
	00 00		 mov	 BYTE PTR [edi+ebp+2292], al
  0013c	45		 inc	 ebp
  0013d	81 fd 00 04 00
	00		 cmp	 ebp, 1024		; 00000400H
  00143	89 6c 24 10	 mov	 DWORD PTR _i$[esp+24], ebp
  00147	0f 8c f3 fe ff
	ff		 jl	 $L110027
  0014d	5f		 pop	 edi
  0014e	dd d8		 fstp	 ST(0)
  00150	5e		 pop	 esi
  00151	dd d8		 fstp	 ST(0)
  00153	5d		 pop	 ebp
  00154	5b		 pop	 ebx

; 4432 :     }
; 4433 : }

  00155	83 c4 08	 add	 esp, 8
  00158	c3		 ret	 0
?SetWaveLight@UWaveTexture@@QAEXXZ ENDP			; UWaveTexture::SetWaveLight
_TEXT	ENDS
PUBLIC	??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UWaveTexture@@SAXPAX@Z	; UWaveTexture::InternalConstructor
;	COMDAT ??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'W', 00H, 'a', 00H, 'v', 00H, 'e', 00H, 'T', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E215
_TEXT	SEGMENT
_$E215	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UWaveTexture@@SAXPAX@Z ; UWaveTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BK@BLG@?$AAU?$AAW?$AAa?$AAv?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 04 13 00 00	 push	 4868			; 00001304H
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E212
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E215	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S213	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E212
_TEXT	SEGMENT
_$E212	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S213
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L110066
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S213, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L110066:
  0001f	c3		 ret	 0
_$E212	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E218
_TEXT	SEGMENT
_$E218	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUWaveTexture, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E218	ENDP
_TEXT	ENDS
PUBLIC	??0UWetTexture@@QAE@XZ				; UWetTexture::UWetTexture
PUBLIC	?PostLoad@UWetTexture@@UAEXXZ			; UWetTexture::PostLoad
PUBLIC	?Destroy@UWetTexture@@UAEXXZ			; UWetTexture::Destroy
PUBLIC	?Init@UWetTexture@@UAEXHH@Z			; UWetTexture::Init
PUBLIC	?Clear@UWetTexture@@UAEXK@Z			; UWetTexture::Clear
PUBLIC	?ConstantTimeTick@UWetTexture@@UAEXXZ		; UWetTexture::ConstantTimeTick
PUBLIC	?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ; UWetTexture::Lock
PUBLIC	??_7UWetTexture@@6B@				; UWetTexture::`vftable'
PUBLIC	??_EUWetTexture@@UAEPAXI@Z			; UWetTexture::`vector deleting destructor'
;	COMDAT ??_7UWetTexture@@6B@
; File ..\..\Core\Inc\UnTemplate.h
CONST	SEGMENT
??_7UWetTexture@@6B@ DD FLAT:??_EUWetTexture@@UAEPAXI@Z	; UWetTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UWetTexture@@UAEXXZ
	DD	FLAT:?Destroy@UWetTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UWetTexture@@UAEXK@Z
	DD	FLAT:?Init@UWetTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UWetTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UWaterTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UWaterTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\UnFractal.cpp
CONST	ENDS
;	COMDAT ??0UWetTexture@@QAE@XZ
_TEXT	SEGMENT
??0UWetTexture@@QAE@XZ PROC NEAR			; UWetTexture::UWetTexture, COMDAT
; _this$ = ecx

; 4445 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b f1		 mov	 esi, ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  0000c	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  00012	83 c9 0c	 or	 ecx, 12			; 0000000cH
  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0001b	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00021	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00026	33 c0		 xor	 eax, eax
  00028	b9 08 f1 ff ff	 mov	 ecx, -3832		; fffff108H
  0002d	33 ff		 xor	 edi, edi
  0002f	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  00035	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0003b	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  00041	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00047	8d ae f8 0c 00
	00		 lea	 ebp, DWORD PTR [esi+3320]
  0004d	2b ce		 sub	 ecx, esi

; 4448 : }

  0004f	90		 npad	 1

; 4445 : {

$L120995:
  00050	33 db		 xor	 ebx, ebx
  00052	8d 04 29	 lea	 eax, DWORD PTR [ecx+ebp]
  00055	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0005a	0f 9c c3	 setl	 bl
  0005d	8b c7		 mov	 eax, edi
  0005f	99		 cdq
  00060	2b c2		 sub	 eax, edx
  00062	d1 f8		 sar	 eax, 1
  00064	33 d2		 xor	 edx, edx
  00066	8d 84 03 00 ff
	ff ff		 lea	 eax, DWORD PTR [ebx+eax-256]
  0006d	3b c2		 cmp	 eax, edx
  0006f	7d 04		 jge	 SHORT $L121001
  00071	33 c0		 xor	 eax, eax
  00073	eb 0c		 jmp	 SHORT $L121000
$L121001:
  00075	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0007a	7c 05		 jl	 SHORT $L121000
  0007c	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$L121000:
  00081	47		 inc	 edi
  00082	88 45 00	 mov	 BYTE PTR [ebp], al
  00085	45		 inc	 ebp
  00086	81 ff 00 06 00
	00		 cmp	 edi, 1536		; 00000600H
  0008c	7c c2		 jl	 SHORT $L120995
  0008e	5f		 pop	 edi
  0008f	c7 86 fc 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4860], -1
  00099	88 96 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], dl
  0009f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWetTexture@@6B@ ; UWetTexture::`vftable'

; 4446 : 	OldSourceTex = NULL;

  000a5	89 96 04 13 00
	00		 mov	 DWORD PTR [esi+4868], edx

; 4447 : 	LocalSourceBitmap = NULL;

  000ab	89 96 08 13 00
	00		 mov	 DWORD PTR [esi+4872], edx

; 4448 : }

  000b1	8b c6		 mov	 eax, esi
  000b3	5e		 pop	 esi
  000b4	5d		 pop	 ebp
  000b5	5b		 pop	 ebx
  000b6	c3		 ret	 0
??0UWetTexture@@QAE@XZ ENDP				; UWetTexture::UWetTexture
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Init@UWetTexture@@UAEXHH@Z
_TEXT	SEGMENT
$T121024 = 12
_InUSize$ = 8
_InVSize$ = 12
?Init@UWetTexture@@UAEXHH@Z PROC NEAR			; UWetTexture::Init, COMDAT
; _this$ = ecx

; 4452 : 	// Init base class.
; 4453 : 	UWaterTexture::Init( InUSize, InVSize );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _InVSize$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b e9		 mov	 ebp, ecx
  0000a	8b 4c 24 14	 mov	 ecx, DWORD PTR _InUSize$[esp+12]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b cd		 mov	 ecx, ebp
  00012	e8 00 00 00 00	 call	 ?Init@UWaterTexture@@UAEXHH@Z ; UWaterTexture::Init

; 4454 : 
; 4455 : 	// Create a custom palette.
; 4456 : 	Palette = new( GetOuter() )UPalette;

  00017	6a 00		 push	 0
  00019	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T121024[esp+16]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  00023	8b cd		 mov	 ecx, ebp
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00031	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00033	8b 54 24 18	 mov	 edx, DWORD PTR $T121024[esp+12]
  00037	6a 00		 push	 0
  00039	51		 push	 ecx
  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  0004c	8b f0		 mov	 esi, eax
  0004e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00051	85 f6		 test	 esi, esi
  00053	74 10		 je	 SHORT $L121011
  00055	8b ce		 mov	 ecx, esi
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  0005d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  00063	eb 02		 jmp	 SHORT $L121012
$L121011:
  00065	33 f6		 xor	 esi, esi
$L121012:
  00067	89 75 2c	 mov	 DWORD PTR [ebp+44], esi

; 4457 : 	for( INT i=0; i<256; i++ )

  0006a	33 db		 xor	 ebx, ebx

; 4461 : }

  0006c	8d 64 24 00	 npad	 4

; 4457 : 	for( INT i=0; i<256; i++ )

$L110094:

; 4458 : 		new(Palette->Colors)FColor(i,i,i);

  00070	8b 75 2c	 mov	 esi, DWORD PTR [ebp+44]
  00073	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00076	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00079	83 c6 28	 add	 esi, 40			; 00000028H
  0007c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0007f	3b c8		 cmp	 ecx, eax
  00081	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00084	7e 1d		 jle	 SHORT $L121039
  00086	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00089	99		 cdq
  0008a	83 e2 07	 and	 edx, 7
  0008d	03 c2		 add	 eax, edx
  0008f	c1 f8 03	 sar	 eax, 3
  00092	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00096	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00099	6a 04		 push	 4
  0009b	8b ce		 mov	 ecx, esi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L121039:
  000a3	8b 16		 mov	 edx, DWORD PTR [esi]
  000a5	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
  000a8	85 c0		 test	 eax, eax
  000aa	74 08		 je	 SHORT $L110095
  000ac	88 18		 mov	 BYTE PTR [eax], bl
  000ae	88 58 01	 mov	 BYTE PTR [eax+1], bl
  000b1	88 58 02	 mov	 BYTE PTR [eax+2], bl
$L110095:
  000b4	43		 inc	 ebx
  000b5	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000bb	7c b3		 jl	 SHORT $L110094

; 4459 : 	BlueLagunaPalette(Palette);

  000bd	8b 45 2c	 mov	 eax, DWORD PTR [ebp+44]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ?BlueLagunaPalette@@YAXPAVUPalette@@@Z ; BlueLagunaPalette

; 4460 : 	MipZero = Palette->Colors(128);

  000c6	8b 4d 2c	 mov	 ecx, DWORD PTR [ebp+44]
  000c9	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000cc	8b 82 00 02 00
	00		 mov	 eax, DWORD PTR [edx+512]
  000d2	83 c4 04	 add	 esp, 4
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	89 45 44	 mov	 DWORD PTR [ebp+68], eax
  000da	5d		 pop	 ebp
  000db	5b		 pop	 ebx

; 4461 : }

  000dc	c2 08 00	 ret	 8
?Init@UWetTexture@@UAEXHH@Z ENDP			; UWetTexture::Init
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?PostLoad@UWetTexture@@UAEXXZ
_TEXT	SEGMENT
_Info$ = -128
_UScaler$110113 = -144
_VScaler$110114 = -136
_SourceMapAddr$110120 = -148
?PostLoad@UWetTexture@@UAEXXZ PROC NEAR			; UWetTexture::PostLoad, COMDAT
; _this$ = ecx

; 4464 : {

  00000	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 4465 : 	Super::PostLoad();

  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  00010	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00013	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00016	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  0001c	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0001f	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  00022	89 96 cc 00 00
	00		 mov	 DWORD PTR [esi+204], edx
  00028	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  0002e	33 ff		 xor	 edi, edi
  00030	3b d7		 cmp	 edx, edi
  00032	75 4d		 jne	 SHORT $L121073
  00034	0f af c1	 imul	 eax, ecx
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	99		 cdq
  00040	2b c2		 sub	 eax, edx
  00042	8b 11		 mov	 edx, DWORD PTR [ecx]
  00044	d1 f8		 sar	 eax, 1
  00046	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  0004b	50		 push	 eax
  0004c	ff 12		 call	 DWORD PTR [edx]
  0004e	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax
  00054	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00057	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  0005b	99		 cdq
  0005c	2b c2		 sub	 eax, edx
  0005e	d1 f8		 sar	 eax, 1
  00060	33 c9		 xor	 ecx, ecx
  00062	85 c0		 test	 eax, eax
  00064	7e 1b		 jle	 SHORT $L121073
$L121071:
  00066	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  0006c	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  00070	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00073	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  00077	99		 cdq
  00078	2b c2		 sub	 eax, edx
  0007a	41		 inc	 ecx
  0007b	d1 f8		 sar	 eax, 1
  0007d	3b c8		 cmp	 ecx, eax
  0007f	7c e5		 jl	 SHORT $L121071
$L121073:

; 4466 : 
; 4467 : 	if( !SourceTexture ) return;

  00081	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  00087	3b cf		 cmp	 ecx, edi
  00089	0f 84 dd 01 00
	00		 je	 $L110107

; 4468 : 
; 4469 : 	// Make sure the source texture data is in memory !
; 4470 : 	FTextureInfo Info; 
; 4471 : 	if( SourceTexture != this ) 

  0008f	3b ce		 cmp	 ecx, esi
  00091	74 1c		 je	 SHORT $L110110

; 4472 : 	{
; 4473 : 		 SourceTexture->Lock( Info, 0.0, 0, NULL );

  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	57		 push	 edi
  00096	57		 push	 edi
  00097	57		 push	 edi
  00098	57		 push	 edi
  00099	8d 54 24 2c	 lea	 edx, DWORD PTR _Info$[esp+172]
  0009d	ff 50 48	 call	 DWORD PTR [eax+72]

; 4474 : 		 SourceTexture->Unlock( Info );

  000a0	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  000a6	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a8	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$[esp+156]
  000ac	ff 50 4c	 call	 DWORD PTR [eax+76]
$L110110:

; 4475 : 	}
; 4476 : 
; 4477 : 	// Make sure this is the same size as our displacement-waves texture.
; 4478 : 	if( ( SourceTexture->UBits  != UBits) || (SourceTexture->VBits  != VBits)  )

  000af	8b 86 00 13 00
	00		 mov	 eax, DWORD PTR [esi+4864]
  000b5	8a 48 30	 mov	 cl, BYTE PTR [eax+48]
  000b8	8a 56 30	 mov	 dl, BYTE PTR [esi+48]
  000bb	3a ca		 cmp	 cl, dl
  000bd	53		 push	 ebx
  000be	55		 push	 ebp
  000bf	75 2f		 jne	 SHORT $L110112
  000c1	8a 58 31	 mov	 bl, BYTE PTR [eax+49]
  000c4	3a 5e 31	 cmp	 bl, BYTE PTR [esi+49]
  000c7	75 27		 jne	 SHORT $L110112

; 4503 : 		}
; 4504 : 	}
; 4505 : 	else
; 4506 : 	{
; 4507 : 		// Sizes match, may have changed to a fullsized sourcetexture.
; 4508 : 		if( LocalSourceBitmap ) 

  000c9	8b 86 08 13 00
	00		 mov	 eax, DWORD PTR [esi+4872]
  000cf	3b c7		 cmp	 eax, edi
  000d1	0f 84 fb 00 00
	00		 je	 $L110129

; 4509 : 		{
; 4510 : 			delete LocalSourceBitmap;

  000d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000dd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000df	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e1	50		 push	 eax
  000e2	ff 52 08	 call	 DWORD PTR [edx+8]

; 4511 : 			LocalSourceBitmap = NULL;

  000e5	89 be 08 13 00
	00		 mov	 DWORD PTR [esi+4872], edi
  000eb	e9 e2 00 00 00	 jmp	 $L110129
$L110112:

; 4479 : 	{
; 4480 : 
; 4481 : 		// Size discrepancy; try to recover a source texture by upsampling..
; 4482 : 		INT UScaler = UBits - SourceTexture->UBits;

  000f0	33 db		 xor	 ebx, ebx
  000f2	8a da		 mov	 bl, dl

; 4483 : 		INT VScaler = VBits - SourceTexture->VBits;

  000f4	0f b6 50 31	 movzx	 edx, BYTE PTR [eax+49]
  000f8	0f b6 46 31	 movzx	 eax, BYTE PTR [esi+49]
  000fc	0f b6 c9	 movzx	 ecx, cl
  000ff	2b d9		 sub	 ebx, ecx
  00101	2b c2		 sub	 eax, edx

; 4484 : 
; 4485 : 		if( (UScaler>=0 ) && (VScaler>=0) )

  00103	3b df		 cmp	 ebx, edi
  00105	89 5c 24 14	 mov	 DWORD PTR _UScaler$110113[esp+164], ebx
  00109	89 44 24 1c	 mov	 DWORD PTR _VScaler$110114[esp+164], eax
  0010d	0f 8c b9 00 00
	00		 jl	 $L110115
  00113	3b c7		 cmp	 eax, edi
  00115	0f 8c b1 00 00
	00		 jl	 $L110115

; 4486 : 		{
; 4487 : 			if( LocalSourceBitmap ) delete LocalSourceBitmap;

  0011b	8b 86 08 13 00
	00		 mov	 eax, DWORD PTR [esi+4872]
  00121	3b c7		 cmp	 eax, edi
  00123	74 0e		 je	 SHORT $L121090
  00125	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  0012b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0012d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012f	50		 push	 eax
  00130	ff 52 08	 call	 DWORD PTR [edx+8]
$L121090:

; 4488 : 			LocalSourceBitmap = new BYTE[ USize * VSize ]; 

  00133	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00136	0f af 46 34	 imul	 eax, DWORD PTR [esi+52]
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00140	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00142	8b 11		 mov	 edx, DWORD PTR [ecx]
  00144	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_17JBDG@?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
  00149	50		 push	 eax
  0014a	ff 12		 call	 DWORD PTR [edx]
  0014c	89 86 08 13 00
	00		 mov	 DWORD PTR [esi+4872], eax

; 4489 : 			BYTE* SourceMapAddr  = &SourceTexture->Mips(0).DataArray(0);

  00152	8b 86 00 13 00
	00		 mov	 eax, DWORD PTR [esi+4864]
  00158	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]

; 4490 : 			
; 4491 : 			for( INT V=0; V<VSize; V++)

  0015e	39 7e 38	 cmp	 DWORD PTR [esi+56], edi
  00161	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00164	89 54 24 10	 mov	 DWORD PTR _SourceMapAddr$110120[esp+164], edx
  00168	7e 68		 jle	 SHORT $L110129
  0016a	8b 56 34	 mov	 edx, DWORD PTR [esi+52]

; 4528 : }

  0016d	8d 49 00	 npad	 3
$L110122:

; 4492 : 			{
; 4493 : 				for( INT U=0; U<USize; U++)

  00170	33 c0		 xor	 eax, eax
  00172	85 d2		 test	 edx, edx
  00174	7e 4c		 jle	 SHORT $L110123
  00176	8b 4c 24 1c	 mov	 ecx, DWORD PTR _VScaler$110114[esp+164]
  0017a	8b ef		 mov	 ebp, edi
  0017c	d3 fd		 sar	 ebp, cl
  0017e	89 6c 24 18	 mov	 DWORD PTR -140+[esp+164], ebp
  00182	eb 04		 jmp	 SHORT $L110126
$L121137:

; 4489 : 			BYTE* SourceMapAddr  = &SourceTexture->Mips(0).DataArray(0);

  00184	8b 6c 24 18	 mov	 ebp, DWORD PTR -140+[esp+164]
$L110126:

; 4494 : 				{	
; 4495 : 					LocalSourceBitmap[ U + ( V * USize )] = 
; 4496 : 						SourceMapAddr[ ( U >> UScaler ) + ((V >> VScaler) << SourceTexture->UBits) ]; 

  00188	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  0018e	0f af d7	 imul	 edx, edi
  00191	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00194	d3 e5		 shl	 ebp, cl
  00196	8b c8		 mov	 ecx, eax
  00198	89 4c 24 20	 mov	 DWORD PTR -132+[esp+164], ecx
  0019c	8b cb		 mov	 ecx, ebx
  0019e	8b d8		 mov	 ebx, eax
  001a0	d3 fb		 sar	 ebx, cl
  001a2	8b 4c 24 10	 mov	 ecx, DWORD PTR _SourceMapAddr$110120[esp+164]
  001a6	03 cd		 add	 ecx, ebp
  001a8	8b ae 08 13 00
	00		 mov	 ebp, DWORD PTR [esi+4872]
  001ae	8a 0c 0b	 mov	 cl, BYTE PTR [ebx+ecx]
  001b1	8b 5c 24 14	 mov	 ebx, DWORD PTR _UScaler$110113[esp+164]
  001b5	03 d0		 add	 edx, eax
  001b7	88 0c 2a	 mov	 BYTE PTR [edx+ebp], cl
  001ba	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  001bd	40		 inc	 eax
  001be	3b c2		 cmp	 eax, edx
  001c0	7c c2		 jl	 SHORT $L121137
$L110123:

; 4490 : 			
; 4491 : 			for( INT V=0; V<VSize; V++)

  001c2	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  001c5	47		 inc	 edi
  001c6	3b f8		 cmp	 edi, eax
  001c8	7c a6		 jl	 SHORT $L110122

; 4497 : 				}
; 4498 : 			}		
; 4499 : 		}
; 4500 : 		else 

  001ca	eb 06		 jmp	 SHORT $L110129
$L110115:

; 4501 : 		{
; 4502 : 			SourceTexture = NULL; // Give up trying to recover a valid sourcetexture.

  001cc	89 be 00 13 00
	00		 mov	 DWORD PTR [esi+4864], edi
$L110129:

; 4512 : 		}
; 4513 : 	}
; 4514 : 
; 4515 : 	if( (SourceTexture) && ( SourceTexture != OldSourceTex ) )

  001d2	8b 86 00 13 00
	00		 mov	 eax, DWORD PTR [esi+4864]
  001d8	85 c0		 test	 eax, eax
  001da	74 0e		 je	 SHORT $L110133
  001dc	3b 86 04 13 00
	00		 cmp	 eax, DWORD PTR [esi+4868]
  001e2	74 06		 je	 SHORT $L110133

; 4516 : 	{
; 4517 : 		// Update palette if new source texture selected.
; 4518 : 		Palette = SourceTexture->Palette; 

  001e4	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  001e7	89 56 2c	 mov	 DWORD PTR [esi+44], edx
$L110133:

; 4519 : 	}
; 4520 : 	OldSourceTex = SourceTexture;
; 4521 : 
; 4522 : 	// Recalculate the rendering LUT if needed.
; 4523 : 	if( WaveAmp != OldWaveAmp )

  001ea	8b 8e fc 12 00
	00		 mov	 ecx, DWORD PTR [esi+4860]
  001f0	89 86 04 13 00
	00		 mov	 DWORD PTR [esi+4868], eax
  001f6	0f b6 86 e1 00
	00 00		 movzx	 eax, BYTE PTR [esi+225]
  001fd	3b c1		 cmp	 eax, ecx
  001ff	74 5c		 je	 SHORT $L121127

; 4524 : 	{
; 4525 : 		SetRefractionTable();

  00201	bb 0d f5 ff ff	 mov	 ebx, -2803		; fffff50dH
  00206	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  0020b	2b de		 sub	 ebx, esi
  0020d	8d be f4 08 00
	00		 lea	 edi, DWORD PTR [esi+2292]
  00213	2b ee		 sub	 ebp, esi
$L121125:
  00215	0f b6 8e e1 00
	00 00		 movzx	 ecx, BYTE PTR [esi+225]
  0021c	89 4c 24 10	 mov	 DWORD PTR -148+[esp+164], ecx
  00220	8d 14 3b	 lea	 edx, DWORD PTR [ebx+edi]
  00223	db 44 24 10	 fild	 DWORD PTR -148+[esp+164]
  00227	89 54 24 10	 mov	 DWORD PTR -148+[esp+164], edx
  0022b	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  00231	da 4c 24 10	 fimul	 DWORD PTR -148+[esp+164]
  00235	e8 00 00 00 00	 call	 __ftol
  0023a	83 f8 80	 cmp	 eax, -128		; ffffff80H
  0023d	7d 07		 jge	 SHORT $L121120
  0023f	b8 80 ff ff ff	 mov	 eax, -128		; ffffff80H
  00244	eb 0a		 jmp	 SHORT $L121119
$L121120:
  00246	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00249	7c 05		 jl	 SHORT $L121119
  0024b	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
$L121119:
  00250	88 07		 mov	 BYTE PTR [edi], al
  00252	47		 inc	 edi
  00253	8d 04 2f	 lea	 eax, DWORD PTR [edi+ebp]
  00256	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0025b	7c b8		 jl	 SHORT $L121125
$L121127:

; 4526 : 	}
; 4527 : 	OldWaveAmp = WaveAmp;

  0025d	0f b6 8e e1 00
	00 00		 movzx	 ecx, BYTE PTR [esi+225]
  00264	5d		 pop	 ebp
  00265	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
  0026b	5b		 pop	 ebx
$L110107:
  0026c	5f		 pop	 edi
  0026d	5e		 pop	 esi

; 4528 : }

  0026e	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  00274	c3		 ret	 0
?PostLoad@UWetTexture@@UAEXXZ ENDP			; UWetTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UWetTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UWetTexture@@UAEXK@Z PROC NEAR			; UWetTexture::Clear, COMDAT
; _this$ = ecx

; 4532 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 4533 : 	// Init to zero.
; 4534 : 	UWaterTexture::Clear( ClearFlags );

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _ClearFlags$[esp+8]
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z
  00010	8b df		 mov	 ebx, edi
  00012	83 e3 02	 and	 ebx, 2
  00015	74 34		 je	 SHORT $L121148
  00017	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0001a	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  0001e	99		 cdq
  0001f	2b c2		 sub	 eax, edx
  00021	d1 f8		 sar	 eax, 1
  00023	33 c9		 xor	 ecx, ecx
  00025	85 c0		 test	 eax, eax
  00027	7e 22		 jle	 SHORT $L121148

; 4544 : }

  00029	8d a4 24 00 00
	00 00		 npad	 7

; 4533 : 	// Init to zero.
; 4534 : 	UWaterTexture::Clear( ClearFlags );

$L121146:
  00030	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00036	c6 04 01 80	 mov	 BYTE PTR [ecx+eax], 128	; 00000080H
  0003a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	41		 inc	 ecx
  00045	d1 f8		 sar	 eax, 1
  00047	3b c8		 cmp	 ecx, eax
  00049	7c e5		 jl	 SHORT $L121146
$L121148:
  0004b	83 e7 01	 and	 edi, 1
  0004e	74 0a		 je	 SHORT $L121149
  00050	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L121149:

; 4535 : 
; 4536 : 	// Clear fields.
; 4537 : 	if( ClearFlags & TCLEAR_Bitmap )

  0005a	85 db		 test	 ebx, ebx
  0005c	74 2d		 je	 SHORT $L110143

; 4538 : 		for( INT i=0; i< USize * VSize / 2; i++ )

  0005e	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00061	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00065	99		 cdq
  00066	2b c2		 sub	 eax, edx
  00068	d1 f8		 sar	 eax, 1
  0006a	33 c9		 xor	 ecx, ecx
  0006c	85 c0		 test	 eax, eax
  0006e	7e 1b		 jle	 SHORT $L110143
$L110141:

; 4539 : 			SourceFields[i] = 128;

  00070	8b 96 f0 08 00
	00		 mov	 edx, DWORD PTR [esi+2288]
  00076	c6 04 11 80	 mov	 BYTE PTR [ecx+edx], 128	; 00000080H
  0007a	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0007d	0f af 46 38	 imul	 eax, DWORD PTR [esi+56]
  00081	99		 cdq
  00082	2b c2		 sub	 eax, edx
  00084	41		 inc	 ecx
  00085	d1 f8		 sar	 eax, 1
  00087	3b c8		 cmp	 ecx, eax
  00089	7c e5		 jl	 SHORT $L110141
$L110143:

; 4540 : 
; 4541 : 	// Clear drops.
; 4542 : 	if( ClearFlags & TCLEAR_Temporal )

  0008b	85 ff		 test	 edi, edi
  0008d	74 0a		 je	 SHORT $L110144

; 4543 : 		NumDrops=0;

  0008f	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
$L110144:
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 4544 : }

  0009c	c2 04 00	 ret	 4
?Clear@UWetTexture@@UAEXK@Z ENDP			; UWetTexture::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UWetTexture@@UAEXXZ
_TEXT	SEGMENT
_Info$110149 = -128
?ConstantTimeTick@UWetTexture@@UAEXXZ PROC NEAR		; UWetTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4547 : {

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 4548 : 	if( SourceTexture && USize>=8 && VSize>=8 ) // safe sizes ?

  00009	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 4e		 je	 SHORT $L110148
  00013	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00016	b8 08 00 00 00	 mov	 eax, 8
  0001b	3b d0		 cmp	 edx, eax
  0001d	7c 42		 jl	 SHORT $L110148
  0001f	39 46 38	 cmp	 DWORD PTR [esi+56], eax
  00022	7c 3d		 jl	 SHORT $L110148

; 4549 : 	{
; 4550 : 		// Make sure referred textures are updated also.
; 4551 : 		FTextureInfo Info; 
; 4552 : 		if( SourceTexture != this )  

  00024	3b ce		 cmp	 ecx, esi
  00026	74 24		 je	 SHORT $L110150

; 4553 : 		{
; 4554 : 			SourceTexture->Lock( Info, LastUpdateTime, 0, NULL );

  00028	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  0002b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	52		 push	 edx
  00032	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00035	52		 push	 edx
  00036	8d 54 24 14	 lea	 edx, DWORD PTR _Info$110149[esp+148]
  0003a	ff 50 48	 call	 DWORD PTR [eax+72]

; 4555 : 			SourceTexture->Unlock( Info );

  0003d	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  00043	8b 01		 mov	 eax, DWORD PTR [ecx]
  00045	8d 54 24 04	 lea	 edx, DWORD PTR _Info$110149[esp+132]
  00049	ff 50 4c	 call	 DWORD PTR [eax+76]
$L110150:

; 4556 : 			//SourceTexture->Update(LastUpdateTime);
; 4557 : 		}
; 4558 : 
; 4559 : 		//Update the water.
; 4560 : 		WaterRedrawDrops();

  0004c	8b ce		 mov	 ecx, esi
  0004e	e8 00 00 00 00	 call	 ?WaterRedrawDrops@UWaterTexture@@QAEXXZ ; UWaterTexture::WaterRedrawDrops

; 4561 : 		CalculateWater();  

  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 ?CalculateWater@UWaterTexture@@QAEXXZ ; UWaterTexture::CalculateWater

; 4562 :         ApplyWetTexture(); 

  0005a	8b ce		 mov	 ecx, esi
  0005c	e8 00 00 00 00	 call	 ?ApplyWetTexture@UWetTexture@@AAEXXZ ; UWetTexture::ApplyWetTexture
$L110148:
  00061	5e		 pop	 esi

; 4563 : 	}
; 4564 : }

  00062	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00068	c3		 ret	 0
?ConstantTimeTick@UWetTexture@@UAEXXZ ENDP		; UWetTexture::ConstantTimeTick
_TEXT	ENDS
PUBLIC	?SetRefractionTable@UWetTexture@@AAEXXZ		; UWetTexture::SetRefractionTable
; Function compile flags: /Ogty
;	COMDAT ?SetRefractionTable@UWetTexture@@AAEXXZ
_TEXT	SEGMENT
?SetRefractionTable@UWetTexture@@AAEXXZ PROC NEAR	; UWetTexture::SetRefractionTable, COMDAT
; _this$ = ecx

; 4571 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 4572 : 	// 'zero' is 512
; 4573 : 	for( INT i=0; i<1024 ; i++ )

  00007	bb 0d f5 ff ff	 mov	 ebx, -2803		; fffff50dH
  0000c	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  00011	2b df		 sub	 ebx, edi
  00013	8d b7 f4 08 00
	00		 lea	 esi, DWORD PTR [edi+2292]
  00019	2b ef		 sub	 ebp, edi

; 4577 :     }
; 4578 : }

  0001b	90 8d 64 24 00	 npad	 5

; 4572 : 	// 'zero' is 512
; 4573 : 	for( INT i=0; i<1024 ; i++ )

$L110155:

; 4574 :     {
; 4575 : 		INT TempLight = (INT) ((+i-511) * ((FLOAT)WaveAmp/512.0F));

  00020	0f b6 8f e1 00
	00 00		 movzx	 ecx, BYTE PTR [edi+225]
  00027	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  0002a	89 44 24 10	 mov	 DWORD PTR -4+[esp+20], eax
  0002e	db 44 24 10	 fild	 DWORD PTR -4+[esp+20]
  00032	89 4c 24 10	 mov	 DWORD PTR -4+[esp+20], ecx
  00036	db 44 24 10	 fild	 DWORD PTR -4+[esp+20]
  0003a	d8 0d 00 00 00
	00		 fmul	 DWORD PTR __real@3b000000
  00040	de c9		 fmulp	 ST(1), ST(0)
  00042	e8 00 00 00 00	 call	 __ftol

; 4576 : 		RenderTable[i] = Clamp( TempLight, -128, 127 );

  00047	83 f8 80	 cmp	 eax, -128		; ffffff80H
  0004a	7d 07		 jge	 SHORT $L121177
  0004c	b8 80 ff ff ff	 mov	 eax, -128		; ffffff80H
  00051	eb 0a		 jmp	 SHORT $L121176
$L121177:
  00053	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00056	7c 05		 jl	 SHORT $L121176
  00058	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
$L121176:
  0005d	88 06		 mov	 BYTE PTR [esi], al
  0005f	46		 inc	 esi
  00060	8d 14 2e	 lea	 edx, DWORD PTR [esi+ebp]
  00063	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  00069	7c b5		 jl	 SHORT $L110155
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5d		 pop	 ebp
  0006e	5b		 pop	 ebx

; 4577 :     }
; 4578 : }

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
?SetRefractionTable@UWetTexture@@AAEXXZ ENDP		; UWetTexture::SetRefractionTable
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Destroy@UWetTexture@@UAEXXZ
_TEXT	SEGMENT
?Destroy@UWetTexture@@UAEXXZ PROC NEAR			; UWetTexture::Destroy, COMDAT
; _this$ = ecx

; 4581 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 4582 : 	// Free memory.
; 4583 : 	if( LocalSourceBitmap )

  00003	8b 86 08 13 00
	00		 mov	 eax, DWORD PTR [esi+4872]
  00009	85 c0		 test	 eax, eax
  0000b	74 0e		 je	 SHORT $L121188

; 4584 : 		delete LocalSourceBitmap;

  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00013	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	50		 push	 eax
  00018	ff 52 08	 call	 DWORD PTR [edx+8]
$L121188:

; 4585 : 
; 4586 : 	// Must call direct parents' class destroy.	
; 4587 : 	Super::Destroy();

  0001b	8b 86 f0 08 00
	00		 mov	 eax, DWORD PTR [esi+2288]
  00021	85 c0		 test	 eax, eax
  00023	74 0e		 je	 SHORT $L121199
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  0002b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	50		 push	 eax
  00030	ff 52 08	 call	 DWORD PTR [edx+8]
$L121199:
  00033	8b ce		 mov	 ecx, esi
  00035	5e		 pop	 esi
  00036	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Destroy@UTexture@@UAEXXZ
?Destroy@UWetTexture@@UAEXXZ ENDP			; UWetTexture::Destroy
_TEXT	ENDS
PUBLIC	??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UWetTexture@@SAXPAX@Z	; UWetTexture::InternalConstructor
;	COMDAT ??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'W', 00H, 'e', 00H, 't', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E224
_TEXT	SEGMENT
_$E224	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UWetTexture@@SAXPAX@Z ; UWetTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@JHNI@?$AAU?$AAW?$AAe?$AAt?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 0c 13 00 00	 push	 4876			; 0000130cH
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E221
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E224	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S222	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E221
_TEXT	SEGMENT
_$E221	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S222
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L110183
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S222, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L110183:
  0001f	c3		 ret	 0
_$E221	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E227
_TEXT	SEGMENT
_$E227	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUWetTexture, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E227	ENDP
_TEXT	ENDS
PUBLIC	??0UIceTexture@@QAE@XZ				; UIceTexture::UIceTexture
PUBLIC	?PostLoad@UIceTexture@@UAEXXZ			; UIceTexture::PostLoad
PUBLIC	?Destroy@UIceTexture@@UAEXXZ			; UIceTexture::Destroy
PUBLIC	?Init@UIceTexture@@UAEXHH@Z			; UIceTexture::Init
PUBLIC	?Clear@UIceTexture@@UAEXK@Z			; UIceTexture::Clear
PUBLIC	?ConstantTimeTick@UIceTexture@@UAEXXZ		; UIceTexture::ConstantTimeTick
PUBLIC	?Tick@UIceTexture@@UAIXM@Z			; UIceTexture::Tick
PUBLIC	?MousePosition@UIceTexture@@UAEXKMM@Z		; UIceTexture::MousePosition
PUBLIC	?Click@UIceTexture@@UAEXKMM@Z			; UIceTexture::Click
PUBLIC	?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ; UIceTexture::Lock
PUBLIC	??_7UIceTexture@@6B@				; UIceTexture::`vftable'
PUBLIC	??_EUIceTexture@@UAEPAXI@Z			; UIceTexture::`vector deleting destructor'
;	COMDAT ??_7UIceTexture@@6B@
CONST	SEGMENT
??_7UIceTexture@@6B@ DD FLAT:??_EUIceTexture@@UAEPAXI@Z	; UIceTexture::`vftable'
	DD	FLAT:?ProcessEvent@UObject@@UAEXPAVUFunction@@PAX1@Z
	DD	FLAT:?ProcessState@UObject@@UAEXM@Z
	DD	FLAT:?ProcessRemoteFunction@UObject@@UAEHPAVUFunction@@PAXPAUFFrame@@@Z
	DD	FLAT:?Modify@UObject@@UAEXXZ
	DD	FLAT:?PostLoad@UIceTexture@@UAEXXZ
	DD	FLAT:?Destroy@UIceTexture@@UAEXXZ
	DD	FLAT:?Serialize@UTexture@@UAEXAAVFArchive@@@Z
	DD	FLAT:?IsPendingKill@UObject@@UAEHXZ
	DD	FLAT:?GotoLabel@UObject@@UAEHVFName@@@Z
	DD	FLAT:?InitExecution@UObject@@UAEXXZ
	DD	FLAT:?ShutdownAfterError@UObject@@UAEXXZ
	DD	FLAT:?PostEditChange@UFractalTexture@@UAEXXZ
	DD	FLAT:?CallFunction@UObject@@UAEXAAUFFrame@@QAXPAVUFunction@@@Z
	DD	FLAT:?ScriptConsoleExec@UObject@@UAEHPBGAAVFOutputDevice@@PAV1@@Z
	DD	FLAT:?Register@UObject@@UAEXXZ
	DD	FLAT:?LanguageChange@UObject@@UAEXXZ
	DD	FLAT:?GetName@UObject@@UBEPBGXZ
	DD	FLAT:?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
	DD	FLAT:?Unlock@UTexture@@UAIXAAUFTextureInfo@@@Z
	DD	FLAT:?GetMip@UTexture@@UAEPAUFMipmapBase@@H@Z
	DD	FLAT:?Clear@UIceTexture@@UAEXK@Z
	DD	FLAT:?Init@UIceTexture@@UAEXHH@Z
	DD	FLAT:?Tick@UIceTexture@@UAIXM@Z
	DD	FLAT:?ConstantTimeTick@UIceTexture@@UAEXXZ
	DD	FLAT:?MousePosition@UIceTexture@@UAEXKMM@Z
	DD	FLAT:?Click@UIceTexture@@UAEXKMM@Z
	DD	FLAT:?Update@UTexture@@UAEXN@Z
	DD	FLAT:?TouchTexture@UFractalTexture@@UAEXHHM@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0UIceTexture@@QAE@XZ
_TEXT	SEGMENT
??0UIceTexture@@QAE@XZ PROC NEAR			; UIceTexture::UIceTexture, COMDAT
; _this$ = ecx

; 4599 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@XZ
  00009	8b 86 88 00 00
	00		 mov	 eax, DWORD PTR [esi+136]
  0000f	83 c8 0c	 or	 eax, 12			; 0000000cH
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00018	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0001e	e8 00 00 00 00	 call	 ?InitTables@@YAXXZ	; InitTables
  00023	33 c0		 xor	 eax, eax

; 4600 : 	MasterCount=0.0f;
; 4601 : 	OldUDisp =   -1;

  00025	83 c9 ff	 or	 ecx, -1
  00028	88 86 dc 00 00
	00		 mov	 BYTE PTR [esi+220], al
  0002e	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  00034	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  0003a	89 86 f4 00 00
	00		 mov	 DWORD PTR [esi+244], eax

; 4602 : 	OldVDisp =   -1;
; 4603 : 
; 4604 : 	OldSourceTex = NULL;

  00040	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax

; 4605 : 	OldGlassTex = NULL;

  00046	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax

; 4606 : 
; 4607 : 	LocalSourceBitmap = NULL;

  0004c	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  00052	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UIceTexture@@6B@ ; UIceTexture::`vftable'
  00058	89 8e 0c 01 00
	00		 mov	 DWORD PTR [esi+268], ecx
  0005e	89 8e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ecx

; 4608 : 
; 4609 : 	ForceRefresh = 1;

  00064	c7 86 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+288], 1

; 4610 : }

  0006e	8b c6		 mov	 eax, esi
  00070	5e		 pop	 esi
  00071	c3		 ret	 0
??0UIceTexture@@QAE@XZ ENDP				; UIceTexture::UIceTexture
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?PostLoad@UIceTexture@@UAEXXZ
_TEXT	SEGMENT
_Info$110202 = -128
_UScaler$110213 = -148
_VScaler$110214 = -136
_SourceMapAddr$110216 = -140
?PostLoad@UIceTexture@@UAEXXZ PROC NEAR			; UIceTexture::PostLoad, COMDAT
; _this$ = ecx

; 4613 : {

  00000	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx

; 4614 : 	Super::PostLoad();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?PostLoad@UTexture@@UAEXXZ
  00012	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00015	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00018	48		 dec	 eax
  00019	49		 dec	 ecx
  0001a	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx

; 4615 : 
; 4616 : 	// Validate all sizes: minima & matching requirements.
; 4617 : 	if( SourceTexture )  

  00020	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00026	33 ed		 xor	 ebp, ebp
  00028	3b cd		 cmp	 ecx, ebp
  0002a	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00030	0f 84 4e 01 00
	00		 je	 $L110225

; 4618 : 	{
; 4619 : 		// Make sure the source texture data is loaded.
; 4620 : 		FTextureInfo Info; 
; 4621 : 		if( SourceTexture != this ) 

  00036	3b ce		 cmp	 ecx, esi
  00038	74 1c		 je	 SHORT $L110203

; 4622 : 		{
; 4623 : 			SourceTexture->Lock( Info, 0.0, 0, NULL );

  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003c	55		 push	 ebp
  0003d	55		 push	 ebp
  0003e	55		 push	 ebp
  0003f	55		 push	 ebp
  00040	8d 54 24 34	 lea	 edx, DWORD PTR _Info$110202[esp+180]
  00044	ff 50 48	 call	 DWORD PTR [eax+72]

; 4624 : 			SourceTexture->Unlock( Info );

  00047	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	8d 54 24 24	 lea	 edx, DWORD PTR _Info$110202[esp+164]
  00053	ff 50 4c	 call	 DWORD PTR [eax+76]
$L110203:

; 4625 : 		}
; 4626 : 
; 4627 : 		if  (  ((USize<8) || (VSize<8))  )

  00056	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00059	83 fa 08	 cmp	 edx, 8
  0005c	0f 8c 16 01 00
	00		 jl	 $L110205
  00062	8b 5e 38	 mov	 ebx, DWORD PTR [esi+56]
  00065	83 fb 08	 cmp	 ebx, 8
  00068	0f 8c 0a 01 00
	00		 jl	 $L110205

; 4631 : 		}
; 4632 : 		else
; 4633 : 		{
; 4634 : 			UBOOL  WrongSizedSource = ((  SourceTexture->USize != USize ) || (  SourceTexture->VSize != VSize ) );

  0006e	8b be e4 00 00
	00		 mov	 edi, DWORD PTR [esi+228]
  00074	39 57 34	 cmp	 DWORD PTR [edi+52], edx
  00077	75 05		 jne	 SHORT $L121265
  00079	39 5f 38	 cmp	 DWORD PTR [edi+56], ebx
  0007c	74 05		 je	 SHORT $L121266
$L121265:
  0007e	bd 01 00 00 00	 mov	 ebp, 1
$L121266:

; 4635 : 			UBOOL  WrongSizedGlass = true;
; 4636 : 			if( GlassTexture ) 

  00083	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  00089	85 c0		 test	 eax, eax
  0008b	b9 01 00 00 00	 mov	 ecx, 1
  00090	74 1d		 je	 SHORT $L110210

; 4637 : 			{
; 4638 : 				WrongSizedGlass = ((  GlassTexture->USize  != USize ) || (  GlassTexture->VSize  != VSize ) );

  00092	39 50 34	 cmp	 DWORD PTR [eax+52], edx
  00095	75 09		 jne	 SHORT $L121267
  00097	39 58 38	 cmp	 DWORD PTR [eax+56], ebx
  0009a	75 04		 jne	 SHORT $L121267
  0009c	33 c9		 xor	 ecx, ecx
  0009e	eb 0f		 jmp	 SHORT $L110210
$L121267:
  000a0	b9 01 00 00 00	 mov	 ecx, 1

; 4639 : 				if( WrongSizedGlass ) GlassTexture = NULL;

  000a5	c7 86 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+224], 0
$L110210:

; 4640 : 			}
; 4641 : 
; 4642 : 			if( ( (!WrongSizedSource) && (!WrongSizedGlass) ) )

  000af	85 ed		 test	 ebp, ebp
  000b1	75 0f		 jne	 SHORT $L110211
  000b3	85 c9		 test	 ecx, ecx
  000b5	75 0b		 jne	 SHORT $L110211

; 4643 : 			{
; 4644 : 				LocalSourceBitmap = NULL;

  000b7	89 8e 1c 01 00
	00		 mov	 DWORD PTR [esi+284], ecx

; 4645 : 			}
; 4646 : 			else //	Static fake texture created if( WrongSizedSource || WrongSizedGlass ) 

  000bd	e9 c2 00 00 00	 jmp	 $L110225
$L110211:

; 4647 : 			{
; 4648 : 				// If either glass or source texture size is invalid, no longer animate 
; 4649 : 				// but do copy whatever's in the source texture to be sure there's 
; 4650 : 				// something valid on display..... and upsample if necessary.
; 4651 : 				// Try to copy source texture to current texture.
; 4652 : 				// Size changed? Try to recover a source texture by upsampling.
; 4653 : 			
; 4654 : 				INT UScaler = UBits - SourceTexture->UBits;

  000c2	0f b6 4f 30	 movzx	 ecx, BYTE PTR [edi+48]
  000c6	0f b6 6e 30	 movzx	 ebp, BYTE PTR [esi+48]

; 4655 : 				INT VScaler = VBits - SourceTexture->VBits;

  000ca	0f b6 47 31	 movzx	 eax, BYTE PTR [edi+49]
  000ce	2b e9		 sub	 ebp, ecx
  000d0	0f b6 4e 31	 movzx	 ecx, BYTE PTR [esi+49]
  000d4	2b c8		 sub	 ecx, eax

; 4656 : 
; 4657 : 				if( (UScaler >=0) && (VScaler>=0) )

  000d6	85 ed		 test	 ebp, ebp
  000d8	89 6c 24 10	 mov	 DWORD PTR _UScaler$110213[esp+164], ebp
  000dc	89 4c 24 1c	 mov	 DWORD PTR _VScaler$110214[esp+164], ecx
  000e0	0f 8c 86 00 00
	00		 jl	 $L110215
  000e6	85 c9		 test	 ecx, ecx
  000e8	0f 8c 7e 00 00
	00		 jl	 $L110215

; 4658 : 				{
; 4659 : 					LocalSourceBitmap = &Mips(0).DataArray(0);  // Our static output image.

  000ee	8b 86 a8 00 00
	00		 mov	 eax, DWORD PTR [esi+168]
  000f4	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000f7	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax

; 4660 : 					BYTE* SourceMapAddr = &SourceTexture->Mips(0).DataArray(0);

  000fd	8b 87 a8 00 00
	00		 mov	 eax, DWORD PTR [edi+168]
  00103	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 4661 : 						
; 4662 : 					// Copy, with optional scaling, to our first mipmap.
; 4663 : 					for( INT V=0; V< VSize; V++)

  00106	33 ff		 xor	 edi, edi
  00108	85 db		 test	 ebx, ebx
  0010a	89 44 24 18	 mov	 DWORD PTR _SourceMapAddr$110216[esp+164], eax
  0010e	7e 74		 jle	 SHORT $L110225
$L110218:

; 4664 : 					{
; 4665 : 						for( INT U=0; U< USize; U++)

  00110	33 c0		 xor	 eax, eax
  00112	85 d2		 test	 edx, edx
  00114	7e 4c		 jle	 SHORT $L110219
  00116	8b df		 mov	 ebx, edi
  00118	d3 fb		 sar	 ebx, cl
  0011a	89 5c 24 20	 mov	 DWORD PTR -132+[esp+164], ebx
  0011e	eb 04		 jmp	 SHORT $L110222
$L121298:

; 4660 : 					BYTE* SourceMapAddr = &SourceTexture->Mips(0).DataArray(0);

  00120	8b 5c 24 20	 mov	 ebx, DWORD PTR -132+[esp+164]
$L110222:

; 4666 : 						{	
; 4667 : 							LocalSourceBitmap[ U + ( V * USize )] = 
; 4668 : 								SourceMapAddr[ ( U >> UScaler ) + ((V >> VScaler) << SourceTexture->UBits) ];

  00124	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0012a	0f af d7	 imul	 edx, edi
  0012d	8a 49 30	 mov	 cl, BYTE PTR [ecx+48]
  00130	d3 e3		 shl	 ebx, cl
  00132	8b c8		 mov	 ecx, eax
  00134	89 4c 24 14	 mov	 DWORD PTR -144+[esp+164], ecx
  00138	8b cd		 mov	 ecx, ebp
  0013a	8b e8		 mov	 ebp, eax
  0013c	d3 fd		 sar	 ebp, cl
  0013e	8b 4c 24 18	 mov	 ecx, DWORD PTR _SourceMapAddr$110216[esp+164]
  00142	03 cb		 add	 ecx, ebx
  00144	8b 9e 1c 01 00
	00		 mov	 ebx, DWORD PTR [esi+284]
  0014a	8a 0c 29	 mov	 cl, BYTE PTR [ecx+ebp]
  0014d	8b 6c 24 10	 mov	 ebp, DWORD PTR _UScaler$110213[esp+164]
  00151	03 d3		 add	 edx, ebx
  00153	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00156	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00159	40		 inc	 eax
  0015a	3b c2		 cmp	 eax, edx
  0015c	7c c2		 jl	 SHORT $L121298

; 4664 : 					{
; 4665 : 						for( INT U=0; U< USize; U++)

  0015e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _VScaler$110214[esp+164]
$L110219:

; 4661 : 						
; 4662 : 					// Copy, with optional scaling, to our first mipmap.
; 4663 : 					for( INT V=0; V< VSize; V++)

  00162	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00165	47		 inc	 edi
  00166	3b f8		 cmp	 edi, eax
  00168	7c a6		 jl	 SHORT $L110218

; 4669 : 						}
; 4670 : 					}					
; 4671 : 				}
; 4672 : 				else

  0016a	eb 18		 jmp	 SHORT $L110225
$L110215:

; 4673 : 				{
; 4674 : 					SourceTexture = NULL; // Give up trying to rebuild a sourcetexture.

  0016c	c7 86 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+228], 0
  00176	eb 0c		 jmp	 SHORT $L110225
$L110205:

; 4628 : 		{
; 4629 : 			SourceTexture = NULL;

  00178	89 ae e4 00 00
	00		 mov	 DWORD PTR [esi+228], ebp

; 4630 : 			GlassTexture =  NULL;

  0017e	89 ae e0 00 00
	00		 mov	 DWORD PTR [esi+224], ebp
$L110225:

; 4675 : 				}
; 4676 : 			}
; 4677 : 		}
; 4678 : 	}
; 4679 : 
; 4680 : 	if( (SourceTexture) && ( SourceTexture != OldSourceTex ) )

  00184	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0018a	85 c0		 test	 eax, eax
  0018c	74 18		 je	 SHORT $L110226
  0018e	3b 86 18 01 00
	00		 cmp	 eax, DWORD PTR [esi+280]
  00194	74 10		 je	 SHORT $L110226

; 4681 : 	{
; 4682 : 		Palette = SourceTexture->Palette; // Make sure palette pointer gets updated.

  00196	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00199	89 56 2c	 mov	 DWORD PTR [esi+44], edx

; 4683 : 		ForceRefresh = 1;

  0019c	c7 86 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+288], 1
$L110226:

; 4684 : 	}
; 4685 : 	OldSourceTex = SourceTexture;
; 4686 : 
; 4687 : 	if( GlassTexture != OldGlassTex ) 

  001a6	8b 8e 14 01 00
	00		 mov	 ecx, DWORD PTR [esi+276]
  001ac	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  001b2	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  001b8	3b c1		 cmp	 eax, ecx

; 4689 : 	OldGlassTex = GlassTexture;

  001ba	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  001c0	74 0a		 je	 SHORT $L110227

; 4688 : 		ForceRefresh = 1;

  001c2	c7 86 20 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+288], 1
$L110227:
  001cc	5f		 pop	 edi
  001cd	5e		 pop	 esi
  001ce	5d		 pop	 ebp
  001cf	5b		 pop	 ebx

; 4690 : }

  001d0	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  001d6	c3		 ret	 0
?PostLoad@UIceTexture@@UAEXXZ ENDP			; UIceTexture::PostLoad
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Init@UIceTexture@@UAEXHH@Z
_TEXT	SEGMENT
$T121321 = 12
_InUSize$ = 8
_InVSize$ = 12
?Init@UIceTexture@@UAEXHH@Z PROC NEAR			; UIceTexture::Init, COMDAT
; _this$ = ecx

; 4694 : 	// Init base class.
; 4695 : 	UFractalTexture::Init( InUSize, InVSize );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _InVSize$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 4c 24 14	 mov	 ecx, DWORD PTR _InUSize$[esp+12]
  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	8b cf		 mov	 ecx, edi
  00012	e8 00 00 00 00	 call	 ?Init@UFractalTexture@@UAEXHH@Z ; UFractalTexture::Init

; 4696 : 
; 4697 : 	UDisplace=0;
; 4698 : 	VDisplace=0;
; 4699 : 
; 4700 : 	HorizPanSpeed = 128;
; 4701 : 	VertPanSpeed  = 128;
; 4702 : 
; 4703 : 	PanningStyle = SLIDE_Linear;
; 4704 : 	Frequency    = 11;
; 4705 : 	Amplitude    = 44;
; 4706 : 
; 4707 : 	MoveIce=1;  // Move around the ICE if 1, TEXTURE if 0.

  00017	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR [edi+240]
  0001d	33 db		 xor	 ebx, ebx
  0001f	83 c9 01	 or	 ecx, 1
  00022	b0 80		 mov	 al, 128			; 00000080H
  00024	89 8f f0 00 00
	00		 mov	 DWORD PTR [edi+240], ecx

; 4708 : 
; 4709 : 	// Create a dummy palette.
; 4710 : 	Palette = new( GetOuter() )UPalette;

  0002a	53		 push	 ebx
  0002b	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T121321[esp+16]
  0002f	89 9f f8 00 00
	00		 mov	 DWORD PTR [edi+248], ebx
  00035	89 9f fc 00 00
	00		 mov	 DWORD PTR [edi+252], ebx
  0003b	88 87 ea 00 00
	00		 mov	 BYTE PTR [edi+234], al
  00041	88 87 eb 00 00
	00		 mov	 BYTE PTR [edi+235], al
  00047	88 9f e8 00 00
	00		 mov	 BYTE PTR [edi+232], bl
  0004d	c6 87 ec 00 00
	00 0b		 mov	 BYTE PTR [edi+236], 11	; 0000000bH
  00054	c6 87 ed 00 00
	00 2c		 mov	 BYTE PTR [edi+237], 44	; 0000002cH
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FName@@QAE@W4EName@@@Z
  00061	8b cf		 mov	 ecx, edi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetOuter@UObject@@QBEPAV1@XZ
  00069	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  0006f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00071	8b 54 24 18	 mov	 edx, DWORD PTR $T121321[esp+12]
  00075	53		 push	 ebx
  00076	51		 push	 ecx
  00077	53		 push	 ebx
  00078	53		 push	 ebx
  00079	52		 push	 edx
  0007a	50		 push	 eax
  0007b	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?PrivateStaticClass@UPalette@@0VUClass@@A
  00080	50		 push	 eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00087	8b f0		 mov	 esi, eax
  00089	83 c4 1c	 add	 esp, 28			; 0000001cH
  0008c	3b f3		 cmp	 esi, ebx
  0008e	74 10		 je	 SHORT $L121308
  00090	8b ce		 mov	 ecx, esi
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UPalette@@QAE@XZ
  00098	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_SUPalette@@6B@ ; UPalette::`local vftable'
  0009e	eb 02		 jmp	 SHORT $L121309
$L121308:
  000a0	33 f6		 xor	 esi, esi
$L121309:
  000a2	89 77 2c	 mov	 DWORD PTR [edi+44], esi
$L110241:

; 4711 : 	for( INT i=0; i<256; i++ )
; 4712 : 		new(Palette->Colors)FColor(i,i,i);

  000a5	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  000a8	8b 6e 2c	 mov	 ebp, DWORD PTR [esi+44]
  000ab	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000ae	83 c6 28	 add	 esi, 40			; 00000028H
  000b1	8d 4d 01	 lea	 ecx, DWORD PTR [ebp+1]
  000b4	3b c8		 cmp	 ecx, eax
  000b6	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000b9	7e 1d		 jle	 SHORT $L121338
  000bb	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  000be	99		 cdq
  000bf	83 e2 07	 and	 edx, 7
  000c2	03 c2		 add	 eax, edx
  000c4	c1 f8 03	 sar	 eax, 3
  000c7	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  000cb	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  000ce	6a 04		 push	 4
  000d0	8b ce		 mov	 ecx, esi
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L121338:
  000d8	8b 16		 mov	 edx, DWORD PTR [esi]
  000da	8d 04 aa	 lea	 eax, DWORD PTR [edx+ebp*4]
  000dd	85 c0		 test	 eax, eax
  000df	74 08		 je	 SHORT $L110242
  000e1	88 18		 mov	 BYTE PTR [eax], bl
  000e3	88 58 01	 mov	 BYTE PTR [eax+1], bl
  000e6	88 58 02	 mov	 BYTE PTR [eax+2], bl
$L110242:
  000e9	43		 inc	 ebx
  000ea	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  000f0	7c b3		 jl	 SHORT $L110241

; 4713 : 	MipZero = Palette->Colors(128);

  000f2	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  000f5	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000f8	8b 91 00 02 00
	00		 mov	 edx, DWORD PTR [ecx+512]
  000fe	89 57 44	 mov	 DWORD PTR [edi+68], edx
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5d		 pop	 ebp
  00104	5b		 pop	 ebx

; 4714 : }

  00105	c2 08 00	 ret	 8
?Init@UIceTexture@@UAEXHH@Z ENDP			; UIceTexture::Init
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Clear@UIceTexture@@UAEXK@Z
_TEXT	SEGMENT
_ClearFlags$ = 8
?Clear@UIceTexture@@UAEXK@Z PROC NEAR			; UIceTexture::Clear, COMDAT
; _this$ = ecx

; 4718 : 	// Init to zero.
; 4719 : 	UFractalTexture::Clear( ClearFlags );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Clear@UTexture@@UAEXK@Z
?Clear@UIceTexture@@UAEXK@Z ENDP			; UIceTexture::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?ConstantTimeTick@UIceTexture@@UAEXXZ
_TEXT	SEGMENT
$T121377 = -132
$T121383 = -136
$T121389 = -136
$T121395 = -136
_I$121399 = -136
_I$121402 = -132
_I$121405 = -132
_I$121408 = -132
_Info$110260 = -128
_Info$110263 = -128
?ConstantTimeTick@UIceTexture@@UAEXXZ PROC NEAR		; UIceTexture::ConstantTimeTick, COMDAT
; _this$ = ecx

; 4723 : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 4724 : 	// Make sure referred textures are updated/loaded also.
; 4725 : 	if( SourceTexture )

  00009	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 28		 je	 SHORT $L110261

; 4726 : 	{
; 4727 : 		FTextureInfo Info; 
; 4728 : 		if( SourceTexture != this ) 

  00013	3b ce		 cmp	 ecx, esi
  00015	74 24		 je	 SHORT $L110261

; 4729 : 		{
; 4730 : 			SourceTexture->Lock( Info, LastUpdateTime, 0, NULL );

  00017	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  0001a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	52		 push	 edx
  00021	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00024	52		 push	 edx
  00025	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$110260[esp+156]
  00029	ff 50 48	 call	 DWORD PTR [eax+72]

; 4731 : 			SourceTexture->Unlock( Info );

  0002c	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$110260[esp+140]
  00038	ff 50 4c	 call	 DWORD PTR [eax+76]
$L110261:

; 4732 : 			//SourceTexture->Update(LastUpdateTime);
; 4733 : 		}
; 4734 : 	}
; 4735 : 	if( GlassTexture )

  0003b	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  00041	85 c9		 test	 ecx, ecx
  00043	74 28		 je	 SHORT $L110264

; 4736 : 	{
; 4737 : 		FTextureInfo Info; 
; 4738 : 		if( GlassTexture != this ) 

  00045	3b ce		 cmp	 ecx, esi
  00047	74 24		 je	 SHORT $L110264

; 4739 : 		{
; 4740 : 			GlassTexture->Lock( Info, LastUpdateTime, 0, NULL );

  00049	8b 56 50	 mov	 edx, DWORD PTR [esi+80]
  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	52		 push	 edx
  00053	8b 56 4c	 mov	 edx, DWORD PTR [esi+76]
  00056	52		 push	 edx
  00057	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$110263[esp+156]
  0005b	ff 50 48	 call	 DWORD PTR [eax+72]

; 4741 : 			GlassTexture->Unlock( Info );

  0005e	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  00064	8b 01		 mov	 eax, DWORD PTR [ecx]
  00066	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$110263[esp+140]
  0006a	ff 50 4c	 call	 DWORD PTR [eax+76]
$L110264:

; 4742 : 			//GlassTexture->Update(LastUpdateTime);
; 4743 : 		}
; 4744 : 	}
; 4745 : 	// Simulated 'deltaseconds' for 120 fps.
; 4746 : 	RenderIce(1.0f/120.0f );

  0006d	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  00073	85 c0		 test	 eax, eax
  00075	0f 84 c9 00 00
	00		 je	 $L121412
  0007b	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  00081	85 c0		 test	 eax, eax
  00083	0f 84 bb 00 00
	00		 je	 $L121412
  00089	68 89 88 08 3c	 push	 1007192201		; 3c088889H
  0008e	8b ce		 mov	 ecx, esi
  00090	e8 00 00 00 00	 call	 ?MoveIcePosition@UIceTexture@@AAEXM@Z ; UIceTexture::MoveIcePosition
  00095	8b 8e 00 01 00
	00		 mov	 ecx, DWORD PTR [esi+256]
  0009b	89 4c 24 08	 mov	 DWORD PTR $T121377[esp+140], ecx
  0009f	d9 44 24 08	 fld	 DWORD PTR $T121377[esp+140]
  000a3	db 5c 24 04	 fistp	 DWORD PTR _I$121399[esp+140]
  000a7	8b 54 24 04	 mov	 edx, DWORD PTR _I$121399[esp+140]
  000ab	3b 96 0c 01 00
	00		 cmp	 edx, DWORD PTR [esi+268]
  000b1	75 28		 jne	 SHORT $L121413
  000b3	8b 86 04 01 00
	00		 mov	 eax, DWORD PTR [esi+260]
  000b9	89 44 24 04	 mov	 DWORD PTR $T121383[esp+140], eax
  000bd	d9 44 24 04	 fld	 DWORD PTR $T121383[esp+140]
  000c1	db 5c 24 08	 fistp	 DWORD PTR _I$121402[esp+140]
  000c5	8b 4c 24 08	 mov	 ecx, DWORD PTR _I$121402[esp+140]
  000c9	3b 8e 10 01 00
	00		 cmp	 ecx, DWORD PTR [esi+272]
  000cf	75 0a		 jne	 SHORT $L121413
  000d1	8b 86 20 01 00
	00		 mov	 eax, DWORD PTR [esi+288]
  000d7	85 c0		 test	 eax, eax
  000d9	74 69		 je	 SHORT $L121412
$L121413:
  000db	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  000e1	89 54 24 04	 mov	 DWORD PTR $T121389[esp+140], edx
  000e5	d9 44 24 04	 fld	 DWORD PTR $T121389[esp+140]
  000e9	db 5c 24 08	 fistp	 DWORD PTR _I$121405[esp+140]
  000ed	8b 44 24 08	 mov	 eax, DWORD PTR _I$121405[esp+140]
  000f1	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  000f7	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  000fd	89 4c 24 04	 mov	 DWORD PTR $T121395[esp+140], ecx
  00101	d9 44 24 04	 fld	 DWORD PTR $T121395[esp+140]
  00105	db 5c 24 08	 fistp	 DWORD PTR _I$121408[esp+140]
  00109	f6 86 f0 00 00
	00 01		 test	 BYTE PTR [esi+240], 1
  00110	8b 54 24 08	 mov	 edx, DWORD PTR _I$121408[esp+140]
  00114	89 96 10 01 00
	00		 mov	 DWORD PTR [esi+272], edx
  0011a	8b ce		 mov	 ecx, esi
  0011c	75 17		 jne	 SHORT $L121414
  0011e	e8 00 00 00 00	 call	 ?BlitIceTex@UIceTexture@@AAEXXZ ; UIceTexture::BlitIceTex
  00123	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
  0012d	5e		 pop	 esi

; 4747 : }

  0012e	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00134	c3		 ret	 0

; 4742 : 			//GlassTexture->Update(LastUpdateTime);
; 4743 : 		}
; 4744 : 	}
; 4745 : 	// Simulated 'deltaseconds' for 120 fps.
; 4746 : 	RenderIce(1.0f/120.0f );

$L121414:
  00135	e8 00 00 00 00	 call	 ?BlitTexIce@UIceTexture@@AAEXXZ ; UIceTexture::BlitTexIce
  0013a	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
$L121412:
  00144	5e		 pop	 esi

; 4747 : }

  00145	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  0014b	c3		 ret	 0
?ConstantTimeTick@UIceTexture@@UAEXXZ ENDP		; UIceTexture::ConstantTimeTick
_TEXT	ENDS
EXTRN	__imp_?Tick@UTexture@@UAIXM@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Tick@UIceTexture@@UAIXM@Z
_TEXT	SEGMENT
$T121440 = -132
_DeltaSeconds$ = 8
$T121446 = -136
_Info$110271 = -128
_Info$110274 = -128
$T121452 = -136
$T121458 = -136
_I$121462 = -136
_I$121465 = -132
_I$121468 = -132
_I$121472 = -132
?Tick@UIceTexture@@UAIXM@Z PROC NEAR			; UIceTexture::Tick, COMDAT
; _this$ = ecx

; 4754 : {

  00000	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 4755 : 	// Revert to parent Tick() if panning stile is 'FrameSynced'. 
; 4756 : 	if( TimeMethod == 0 ) 

  00009	8a 86 e9 00 00
	00		 mov	 al, BYTE PTR [esi+233]
  0000f	84 c0		 test	 al, al
  00011	75 18		 jne	 SHORT $L110269

; 4757 : 	{	
; 4758 : 		// Call parent, which might call UIceTexture::ConstantTimeTick 
; 4759 : 		UFractalTexture::Tick(DeltaSeconds); 

  00013	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR _DeltaSeconds$[esp+136]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Tick@UTexture@@UAIXM@Z
  00021	5e		 pop	 esi

; 4783 : }

  00022	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00028	c2 04 00	 ret	 4
$L110269:

; 4760 : 		return;
; 4761 : 	}
; 4762 : 
; 4763 : 	// Make sure referred textures are updated/loaded also.
; 4764 : 	if( SourceTexture )

  0002b	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00031	85 c9		 test	 ecx, ecx
  00033	74 24		 je	 SHORT $L110272

; 4765 : 	{
; 4766 : 		FTextureInfo Info; 
; 4767 : 		if( SourceTexture != this ) 

  00035	3b ce		 cmp	 ecx, esi
  00037	74 20		 je	 SHORT $L110272

; 4768 : 		{
; 4769 : 			SourceTexture->Lock( Info, 0.0, 0, NULL );

  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	6a 00		 push	 0
  00041	6a 00		 push	 0
  00043	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$110271[esp+156]
  00047	ff 50 48	 call	 DWORD PTR [eax+72]

; 4770 : 			SourceTexture->Unlock( Info );

  0004a	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  00050	8b 01		 mov	 eax, DWORD PTR [ecx]
  00052	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$110271[esp+140]
  00056	ff 50 4c	 call	 DWORD PTR [eax+76]
$L110272:

; 4771 : 		}
; 4772 : 	}
; 4773 : 	if( GlassTexture )

  00059	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  0005f	85 c9		 test	 ecx, ecx
  00061	74 24		 je	 SHORT $L110275

; 4774 : 	{
; 4775 : 		FTextureInfo Info; 
; 4776 : 		if( GlassTexture != this )

  00063	3b ce		 cmp	 ecx, esi
  00065	74 20		 je	 SHORT $L110275

; 4777 : 		{
; 4778 : 			GlassTexture->Lock( Info, 0.0, 0, NULL );

  00067	8b 01		 mov	 eax, DWORD PTR [ecx]
  00069	6a 00		 push	 0
  0006b	6a 00		 push	 0
  0006d	6a 00		 push	 0
  0006f	6a 00		 push	 0
  00071	8d 54 24 1c	 lea	 edx, DWORD PTR _Info$110274[esp+156]
  00075	ff 50 48	 call	 DWORD PTR [eax+72]

; 4779 : 			GlassTexture->Unlock( Info );

  00078	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  0007e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00080	8d 54 24 0c	 lea	 edx, DWORD PTR _Info$110274[esp+140]
  00084	ff 50 4c	 call	 DWORD PTR [eax+76]
$L110275:

; 4780 : 		}
; 4781 : 	}
; 4782 : 	RenderIce(DeltaSeconds);	

  00087	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  0008d	85 c0		 test	 eax, eax
  0008f	0f 84 ce 00 00
	00		 je	 $L121475
  00095	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  0009b	85 c0		 test	 eax, eax
  0009d	0f 84 c0 00 00
	00		 je	 $L121475
  000a3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR _DeltaSeconds$[esp+136]
  000aa	51		 push	 ecx
  000ab	8b ce		 mov	 ecx, esi
  000ad	e8 00 00 00 00	 call	 ?MoveIcePosition@UIceTexture@@AAEXM@Z ; UIceTexture::MoveIcePosition
  000b2	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  000b8	89 54 24 08	 mov	 DWORD PTR $T121440[esp+140], edx
  000bc	d9 44 24 08	 fld	 DWORD PTR $T121440[esp+140]
  000c0	db 5c 24 04	 fistp	 DWORD PTR _I$121462[esp+140]
  000c4	8b 44 24 04	 mov	 eax, DWORD PTR _I$121462[esp+140]
  000c8	3b 86 0c 01 00
	00		 cmp	 eax, DWORD PTR [esi+268]
  000ce	75 28		 jne	 SHORT $L121476
  000d0	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  000d6	89 4c 24 04	 mov	 DWORD PTR $T121446[esp+140], ecx
  000da	d9 44 24 04	 fld	 DWORD PTR $T121446[esp+140]
  000de	db 5c 24 08	 fistp	 DWORD PTR _I$121465[esp+140]
  000e2	8b 54 24 08	 mov	 edx, DWORD PTR _I$121465[esp+140]
  000e6	3b 96 10 01 00
	00		 cmp	 edx, DWORD PTR [esi+272]
  000ec	75 0a		 jne	 SHORT $L121476
  000ee	8b 86 20 01 00
	00		 mov	 eax, DWORD PTR [esi+288]
  000f4	85 c0		 test	 eax, eax
  000f6	74 6b		 je	 SHORT $L121475
$L121476:
  000f8	8b 86 00 01 00
	00		 mov	 eax, DWORD PTR [esi+256]
  000fe	89 44 24 04	 mov	 DWORD PTR $T121452[esp+140], eax
  00102	d9 44 24 04	 fld	 DWORD PTR $T121452[esp+140]
  00106	db 5c 24 08	 fistp	 DWORD PTR _I$121468[esp+140]
  0010a	8b 4c 24 08	 mov	 ecx, DWORD PTR _I$121468[esp+140]
  0010e	8b 96 04 01 00
	00		 mov	 edx, DWORD PTR [esi+260]
  00114	89 8e 0c 01 00
	00		 mov	 DWORD PTR [esi+268], ecx
  0011a	89 54 24 04	 mov	 DWORD PTR $T121458[esp+140], edx
  0011e	d9 44 24 04	 fld	 DWORD PTR $T121458[esp+140]
  00122	db 5c 24 08	 fistp	 DWORD PTR _I$121472[esp+140]
  00126	8b 44 24 08	 mov	 eax, DWORD PTR _I$121472[esp+140]
  0012a	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax
  00130	f6 86 f0 00 00
	00 01		 test	 BYTE PTR [esi+240], 1
  00137	8b ce		 mov	 ecx, esi
  00139	75 19		 jne	 SHORT $L121477
  0013b	e8 00 00 00 00	 call	 ?BlitIceTex@UIceTexture@@AAEXXZ ; UIceTexture::BlitIceTex
  00140	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
  0014a	5e		 pop	 esi

; 4783 : }

  0014b	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  00151	c2 04 00	 ret	 4

; 4780 : 		}
; 4781 : 	}
; 4782 : 	RenderIce(DeltaSeconds);	

$L121477:
  00154	e8 00 00 00 00	 call	 ?BlitTexIce@UIceTexture@@AAEXXZ ; UIceTexture::BlitTexIce
  00159	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
$L121475:
  00163	5e		 pop	 esi

; 4783 : }

  00164	81 c4 88 00 00
	00		 add	 esp, 136		; 00000088H
  0016a	c2 04 00	 ret	 4
?Tick@UIceTexture@@UAIXM@Z ENDP				; UIceTexture::Tick
_TEXT	ENDS
PUBLIC	?RenderIce@UIceTexture@@AAEXM@Z			; UIceTexture::RenderIce
; Function compile flags: /Ogty
;	COMDAT ?RenderIce@UIceTexture@@AAEXM@Z
_TEXT	SEGMENT
_DeltaTime$ = 8
_I$121484 = -4
$T121486 = 8
_I$121490 = -4
$T121492 = 8
_I$121496 = -4
$T121498 = 8
_I$121502 = -4
$T121504 = 8
?RenderIce@UIceTexture@@AAEXM@Z PROC NEAR		; UIceTexture::RenderIce, COMDAT
; _this$ = ecx

; 4786 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 4787 :     // Safety & update checks. 
; 4788 : 	if( (GlassTexture == NULL) || (SourceTexture == NULL) ) return;

  00004	8b 86 e0 00 00
	00		 mov	 eax, DWORD PTR [esi+224]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 c4 00 00
	00		 je	 $L110281
  00012	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 b6 00 00
	00		 je	 $L110281

; 4789 : 
; 4790 : 	MoveIcePosition(DeltaTime);

  00020	8b 44 24 0c	 mov	 eax, DWORD PTR _DeltaTime$[esp+4]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ?MoveIcePosition@UIceTexture@@AAEXM@Z ; UIceTexture::MoveIcePosition

; 4791 : 
; 4792 : 	// Skip update if last position == new position.
; 4793 : 	if( (appRound(UPosition) == OldUDisp) 
; 4794 : 		&& (appRound(VPosition) == OldVDisp)
; 4795 : 		&& (! ForceRefresh) ) 

  0002a	8b 8e 00 01 00
	00		 mov	 ecx, DWORD PTR [esi+256]
  00030	89 4c 24 0c	 mov	 DWORD PTR $T121486[esp+4], ecx
  00034	d9 44 24 0c	 fld	 DWORD PTR $T121486[esp+4]
  00038	db 5c 24 04	 fistp	 DWORD PTR _I$121484[esp+8]
  0003c	8b 54 24 04	 mov	 edx, DWORD PTR _I$121484[esp+8]
  00040	3b 96 0c 01 00
	00		 cmp	 edx, DWORD PTR [esi+268]
  00046	75 28		 jne	 SHORT $L110282
  00048	8b 86 04 01 00
	00		 mov	 eax, DWORD PTR [esi+260]
  0004e	89 44 24 0c	 mov	 DWORD PTR $T121492[esp+4], eax
  00052	d9 44 24 0c	 fld	 DWORD PTR $T121492[esp+4]
  00056	db 5c 24 04	 fistp	 DWORD PTR _I$121490[esp+8]
  0005a	8b 4c 24 04	 mov	 ecx, DWORD PTR _I$121490[esp+8]
  0005e	3b 8e 10 01 00
	00		 cmp	 ecx, DWORD PTR [esi+272]
  00064	75 0a		 jne	 SHORT $L110282
  00066	8b 86 20 01 00
	00		 mov	 eax, DWORD PTR [esi+288]
  0006c	85 c0		 test	 eax, eax
  0006e	74 66		 je	 SHORT $L110281
$L110282:

; 4796 : 		return;
; 4797 : 
; 4798 : 	OldUDisp = appRound( UPosition );

  00070	8b 96 00 01 00
	00		 mov	 edx, DWORD PTR [esi+256]
  00076	89 54 24 0c	 mov	 DWORD PTR $T121498[esp+4], edx
  0007a	d9 44 24 0c	 fld	 DWORD PTR $T121498[esp+4]
  0007e	db 5c 24 04	 fistp	 DWORD PTR _I$121496[esp+8]
  00082	8b 44 24 04	 mov	 eax, DWORD PTR _I$121496[esp+8]

; 4799 : 	OldVDisp = appRound( VPosition );

  00086	8b 8e 04 01 00
	00		 mov	 ecx, DWORD PTR [esi+260]
  0008c	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  00092	89 4c 24 0c	 mov	 DWORD PTR $T121504[esp+4], ecx
  00096	d9 44 24 0c	 fld	 DWORD PTR $T121504[esp+4]
  0009a	db 5c 24 04	 fistp	 DWORD PTR _I$121502[esp+8]

; 4800 : 
; 4801 : 	// Actual redrawing.
; 4802 : 	if  (! MoveIce ) BlitIceTex();

  0009e	f6 86 f0 00 00
	00 01		 test	 BYTE PTR [esi+240], 1
  000a5	8b 54 24 04	 mov	 edx, DWORD PTR _I$121502[esp+8]
  000a9	89 96 10 01 00
	00		 mov	 DWORD PTR [esi+272], edx
  000af	8b ce		 mov	 ecx, esi
  000b1	75 14		 jne	 SHORT $L110283
  000b3	e8 00 00 00 00	 call	 ?BlitIceTex@UIceTexture@@AAEXXZ ; UIceTexture::BlitIceTex

; 4804 : 
; 4805 : 	ForceRefresh=0;

  000b8	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
  000c2	5e		 pop	 esi

; 4806 : }

  000c3	59		 pop	 ecx
  000c4	c2 04 00	 ret	 4
$L110283:

; 4803 : 		 else        BlitTexIce();

  000c7	e8 00 00 00 00	 call	 ?BlitTexIce@UIceTexture@@AAEXXZ ; UIceTexture::BlitTexIce

; 4804 : 
; 4805 : 	ForceRefresh=0;

  000cc	c7 86 20 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+288], 0
$L110281:
  000d6	5e		 pop	 esi

; 4806 : }

  000d7	59		 pop	 ecx
  000d8	c2 04 00	 ret	 4
?RenderIce@UIceTexture@@AAEXM@Z ENDP			; UIceTexture::RenderIce
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?MousePosition@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT
_Buttons$ = 8
_X$ = 12
_Y$ = 16
?MousePosition@UIceTexture@@UAEXKMM@Z PROC NEAR		; UIceTexture::MousePosition, COMDAT
; _this$ = ecx

; 4810 : 	static FLOAT  MouseLastU=0.0f;
; 4811 : 	static FLOAT  MouseLastV=0.0f;
; 4812 : 
; 4813 : 	if( Buttons & MOUSE_Left )

  00000	f6 44 24 04 01	 test	 BYTE PTR _Buttons$[esp-4], 1
  00005	74 44		 je	 SHORT $L110295

; 4814 : 	{ 
; 4815 : 		UDisplace +=(MouseLastU - X);

  00007	d9 05 00 00 00
	00		 fld	 DWORD PTR ?MouseLastU@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA
  0000d	d8 64 24 08	 fsub	 DWORD PTR _X$[esp-4]
  00011	d8 81 f8 00 00
	00		 fadd	 DWORD PTR [ecx+248]
  00017	d9 99 f8 00 00
	00		 fstp	 DWORD PTR [ecx+248]

; 4816 : 		VDisplace +=(MouseLastV - Y);
; 4817 : 
; 4818 : 		UPosition = UDisplace;

  0001d	8b 81 f8 00 00
	00		 mov	 eax, DWORD PTR [ecx+248]
  00023	d9 05 00 00 00
	00		 fld	 DWORD PTR ?MouseLastV@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA
  00029	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax
  0002f	d8 64 24 0c	 fsub	 DWORD PTR _Y$[esp-4]
  00033	d8 81 fc 00 00
	00		 fadd	 DWORD PTR [ecx+252]
  00039	d9 99 fc 00 00
	00		 fstp	 DWORD PTR [ecx+252]

; 4819 : 		VPosition = VDisplace;

  0003f	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00045	89 91 04 01 00
	00		 mov	 DWORD PTR [ecx+260], edx
$L110295:

; 4820 : 	}
; 4821 : 
; 4822 : 	MouseLastU = X;

  0004b	8b 44 24 08	 mov	 eax, DWORD PTR _X$[esp-4]

; 4823 : 	MouseLastV = Y;

  0004f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _Y$[esp-4]
  00053	a3 00 00 00 00	 mov	 DWORD PTR ?MouseLastU@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA, eax
  00058	89 0d 00 00 00
	00		 mov	 DWORD PTR ?MouseLastV@?1??MousePosition@UIceTexture@@UAEXKMM@Z@4MA, ecx

; 4824 : }

  0005e	c2 0c 00	 ret	 12			; 0000000cH
?MousePosition@UIceTexture@@UAEXKMM@Z ENDP		; UIceTexture::MousePosition
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Click@UIceTexture@@UAEXKMM@Z
_TEXT	SEGMENT
?Click@UIceTexture@@UAEXKMM@Z PROC NEAR			; UIceTexture::Click, COMDAT
; _this$ = ecx

; 4828 : }

  00000	c2 0c 00	 ret	 12			; 0000000cH
?Click@UIceTexture@@UAEXKMM@Z ENDP			; UIceTexture::Click
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Destroy@UIceTexture@@UAEXXZ
_TEXT	SEGMENT
?Destroy@UIceTexture@@UAEXXZ PROC NEAR			; UIceTexture::Destroy, COMDAT
; _this$ = ecx

; 4832 : 	// Must call base class' destroy.
; 4833 : 	Super::Destroy();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?Destroy@UTexture@@UAEXXZ
?Destroy@UIceTexture@@UAEXXZ ENDP			; UIceTexture::Destroy
_TEXT	ENDS
PUBLIC	??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ ; `string'
PUBLIC	?InternalConstructor@UIceTexture@@SAXPAX@Z	; UIceTexture::InternalConstructor
;	COMDAT ??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@
_DATA	SEGMENT
??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@ DB 'U'
	DB	00H, 'I', 00H, 'c', 00H, 'e', 00H, 'T', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT _$E233
_TEXT	SEGMENT
_$E233	PROC NEAR					; COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?StaticConstructor@UObject@@QAEXXZ
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 ec 10	 sub	 esp, 16			; 00000010H
  0000c	8b ec		 mov	 ebp, esp
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:?InternalConstructor@UIceTexture@@SAXPAX@Z ; UIceTexture::InternalConstructor
  00013	68 04 40 08 04	 push	 67649540		; 04084004H
  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1O@KHFL@?$AAS?$AAy?$AAs?$AAt?$AAe?$AAm?$AA?$AA@ ; `string'
  0001d	89 45 00	 mov	 DWORD PTR [ebp], eax
  00020	68 00 00 00 00	 push	 OFFSET FLAT:_GPackage
  00025	33 c9		 xor	 ecx, ecx
  00027	89 4d 04	 mov	 DWORD PTR [ebp+4], ecx
  0002a	68 02 00 00 00	 push	 OFFSET FLAT:??_C@_1BI@MCDB@?$AAU?$AAI?$AAc?$AAe?$AAT?$AAe?$AAx?$AAt?$AAu?$AAr?$AAe?$AA?$AA@+2
  0002f	83 ec 10	 sub	 esp, 16			; 00000010H
  00032	33 d2		 xor	 edx, edx
  00034	89 55 08	 mov	 DWORD PTR [ebp+8], edx
  00037	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?PrivateStaticClass@UObject@@0VUClass@@A
  0003d	8b cc		 mov	 ecx, esp
  0003f	52		 push	 edx
  00040	33 f6		 xor	 esi, esi
  00042	89 75 0c	 mov	 DWORD PTR [ebp+12], esi
  00045	33 c0		 xor	 eax, eax
  00047	33 ff		 xor	 edi, edi
  00049	89 39		 mov	 DWORD PTR [ecx], edi
  0004b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00050	33 db		 xor	 ebx, ebx
  00052	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00055	50		 push	 eax
  00056	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00059	68 24 01 00 00	 push	 292			; 00000124H
  0005e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00061	50		 push	 eax
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UClass@@QAE@W4ENativeConstructor@@KKPAV0@1VFGuid@@PBG33KP6AXPAX@ZP8UObject@@AEXXZ@Z
  0006d	68 00 00 00 00	 push	 OFFSET FLAT:_$E230
  00072	e8 00 00 00 00	 call	 _atexit
  00077	83 c4 04	 add	 esp, 4
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp
  0007d	5b		 pop	 ebx
  0007e	c3		 ret	 0
_$E233	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_$S231	DB	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT _$E230
_TEXT	SEGMENT
_$E230	PROC NEAR					; COMDAT
  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _$S231
  00006	b0 01		 mov	 al, 1
  00008	84 c8		 test	 cl, al
  0000a	75 13		 jne	 SHORT $L110317
  0000c	0a c8		 or	 cl, al
  0000e	88 0d 00 00 00
	00		 mov	 BYTE PTR _$S231, cl
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UClass@@UAE@XZ
$L110317:
  0001f	c3		 ret	 0
_$E230	ENDP
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT _$E236
_TEXT	SEGMENT
_$E236	PROC NEAR					; COMDAT
  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _autoclassUIceTexture, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A ; UIceTexture::PrivateStaticClass
  0000a	c3		 ret	 0
_$E236	ENDP
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
  00000	8b 44 24 0c	 mov	 eax, DWORD PTR ___n$[esp-4]
  00004	48		 dec	 eax
  00005	78 26		 js	 SHORT $L84983
  00007	53		 push	 ebx
  00008	8b 5c 24 14	 mov	 ebx, DWORD PTR ___f$[esp]
  0000c	55		 push	 ebp
  0000d	8b 6c 24 10	 mov	 ebp, DWORD PTR ___s$[esp+4]
  00011	56		 push	 esi
  00012	8b 74 24 10	 mov	 esi, DWORD PTR ___t$[esp+8]
  00016	57		 push	 edi
  00017	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001a	8d 9b 00 00 00
	00		 npad	 6
$L84982:
  00020	8b ce		 mov	 ecx, esi
  00022	ff d3		 call	 ebx
  00024	03 f5		 add	 esi, ebp
  00026	4f		 dec	 edi
  00027	75 f7		 jne	 SHORT $L84982
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	5b		 pop	 ebx
$L84983:
  0002d	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
EXTRN	__imp_??1UPalette@@UAE@XZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ??_GUPalette@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUPalette@@UAEPAXI@Z PROC NEAR			; UPalette::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UPalette@@UAE@XZ
  00009	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000e	74 0d		 je	 SHORT $L121573
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	56		 push	 esi
  0001a	ff 52 08	 call	 DWORD PTR [edx+8]
$L121573:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	c2 04 00	 ret	 4
??_GUPalette@@UAEPAXI@Z ENDP				; UPalette::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?CycleCount@@YAHXZ				; CycleCount
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
;	COMDAT ?CycleCount@@YAHXZ
_TEXT	SEGMENT
_OutCyc$ = -4
?CycleCount@@YAHXZ PROC NEAR				; CycleCount, COMDAT

; 48   : {

  00000	51		 push	 ecx

; 49   : #if ASM
; 50   :     INT OutCyc;
; 51   :     __asm
; 52   :    {
; 53   :         xor edx,edx

  00001	33 d2		 xor	 edx, edx

; 54   : 		xor eax,eax

  00003	33 c0		 xor	 eax, eax

; 55   :         //RDTSC;     // Moves Pentium+ time stamp register to EDX:EAX
; 56   :         _emit 0x0F;

  00005	0f		 DB	 15			; 0000000fH

; 57   :         _emit 0x31;

  00006	31		 DB	 49			; 00000031H

; 58   :         //
; 59   :         mov OutCyc,EAX //only low-order 32-bits needed

  00007	89 44 24 00	 mov	 DWORD PTR _OutCyc$[esp+4], eax

; 60   :     }
; 61   :     return (OutCyc);

  0000b	8b 44 24 00	 mov	 eax, DWORD PTR _OutCyc$[esp+4]

; 62   : #else
; 63   : 	return 0;
; 64   : #endif
; 65   : }

  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
?CycleCount@@YAHXZ ENDP					; CycleCount
_TEXT	ENDS
PUBLIC	?StaticClass@UFractalTexture@@SAPAVUClass@@XZ	; UFractalTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UFractalTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UFractalTexture@@SAPAVUClass@@XZ PROC NEAR	; UFractalTexture::StaticClass, COMDAT

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UFractalTexture@@SAPAVUClass@@XZ ENDP	; UFractalTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z ; UFractalTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UFractalTexture::operator new, COMDAT

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFractalTexture@@0VUClass@@A ; UFractalTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UFractalTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UFractalTexture::operator new
_TEXT	ENDS
PUBLIC	??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z	; UFractalTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UFractalTexture::operator new, COMDAT

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UFractalTexture@@SAPAXIPAW4EInternal@@@Z ENDP	; UFractalTexture::operator new
_TEXT	ENDS
PUBLIC	??_GFMipmap@@QAEPAXI@Z				; FMipmap::`scalar deleting destructor'
PUBLIC	??1UFractalTexture@@UAE@XZ			; UFractalTexture::~UFractalTexture
PUBLIC	??1?$TArray@UFMipmap@@@@QAE@XZ			; TArray<FMipmap>::~TArray<FMipmap>
EXTRN	__imp_??1UObject@@UAE@XZ:NEAR
EXTRN	__imp_??_7UTexture@@6B@:BYTE
EXTRN	__imp_?ConditionalDestroy@UObject@@QAEHXZ:NEAR
EXTRN	__imp_??1FArray@@QAE@XZ:NEAR
EXTRN	__imp_??1UProceduralTexture@@UAE@XZ:NEAR
EXTRN	__imp_??_7UProceduralTexture@@6B@:BYTE
EXTRN	__imp_??1UBitmap@@UAE@XZ:NEAR
EXTRN	__imp_??_7UBitmap@@6B@:BYTE
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp_??1UTexture@@UAE@XZ:NEAR
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T121796 DD	0ffffffffH
	DD	FLAT:$L121592
	DD	0ffffffffH
	DD	FLAT:$L121594
	DD	0ffffffffH
	DD	FLAT:$L121596
	DD	02H
	DD	FLAT:$L121597
	DD	03H
	DD	FLAT:$L121598
	DD	03H
	DD	FLAT:$L121600
	DD	02H
	DD	FLAT:$L121648
	DD	0ffffffffH
	DD	FLAT:$L121696
$T121786 DD	019930520H
	DD	08H
	DD	FLAT:$T121796
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UFractalTexture@@UAE@XZ
_TEXT	SEGMENT
$T121646 = -16
$T121694 = -16
__$EHRec$ = -12
_this$ = -20
??1UFractalTexture@@UAE@XZ PROC NEAR			; UFractalTexture::~UFractalTexture, COMDAT
; _this$ = ecx

; 78   : 	DECLARE_ABSTRACT_CLASS(UFractalTexture,UProceduralTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L121794
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0003b	89 06		 mov	 DWORD PTR [esi], eax
  0003d	8b ce		 mov	 ecx, esi
  0003f	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00047	ff d7		 call	 edi
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  0004f	89 0e		 mov	 DWORD PTR [esi], ecx
  00051	8b ce		 mov	 ecx, esi
  00053	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 4
  0005b	ff d7		 call	 edi
  0005d	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00063	89 7c 24 18	 mov	 DWORD PTR $T121646[esp+40], edi
  00067	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0006a	3b dd		 cmp	 ebx, ebp
  0006c	c6 44 24 24 05	 mov	 BYTE PTR __$EHRec$[esp+48], 5
  00071	7d 18		 jge	 SHORT $L121748
  00073	68 fd 01 00 00	 push	 509			; 000001fdH
  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0007d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121748:
  0008b	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  0008e	7e 18		 jle	 SHORT $L121749
  00090	68 fe 01 00 00	 push	 510			; 000001feH
  00095	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0009a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121749:
  000a8	3b dd		 cmp	 ebx, ebp
  000aa	7e 1f		 jle	 SHORT $L121754
  000ac	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L121752:
  000b0	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000b2	6a 00		 push	 0
  000b4	03 cd		 add	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000bb	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000bf	83 c5 28	 add	 ebp, 40			; 00000028H
  000c2	48		 dec	 eax
  000c3	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000c7	75 e7		 jne	 SHORT $L121752
  000c9	33 ed		 xor	 ebp, ebp
$L121754:
  000cb	6a 28		 push	 40			; 00000028H
  000cd	53		 push	 ebx
  000ce	55		 push	 ebp
  000cf	8b cf		 mov	 ecx, edi
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000d7	8b 07		 mov	 eax, DWORD PTR [edi]
  000d9	3b c5		 cmp	 eax, ebp
  000db	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  000e0	74 0e		 je	 SHORT $L121761
  000e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000e8	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ec	50		 push	 eax
  000ed	ff 52 08	 call	 DWORD PTR [edx+8]
$L121761:
  000f0	89 2f		 mov	 DWORD PTR [edi], ebp
  000f2	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  000f5	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  000f8	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  000fe	89 7c 24 18	 mov	 DWORD PTR $T121694[esp+40], edi
  00102	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00105	85 ed		 test	 ebp, ebp
  00107	c6 44 24 24 06	 mov	 BYTE PTR __$EHRec$[esp+48], 6
  0010c	7d 18		 jge	 SHORT $L121767
  0010e	68 fd 01 00 00	 push	 509			; 000001fdH
  00113	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00118	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121767:
  00126	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  00129	7e 18		 jle	 SHORT $L121768
  0012b	68 fe 01 00 00	 push	 510			; 000001feH
  00130	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00135	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0013a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121768:
  00143	85 ed		 test	 ebp, ebp
  00145	7e 22		 jle	 SHORT $L121773
  00147	33 db		 xor	 ebx, ebx
  00149	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0014d	8d 49 00	 npad	 3
$L121771:
  00150	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00152	6a 00		 push	 0
  00154	03 cb		 add	 ecx, ebx
  00156	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0015b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0015f	83 c3 28	 add	 ebx, 40			; 00000028H
  00162	48		 dec	 eax
  00163	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00167	75 e7		 jne	 SHORT $L121771
$L121773:
  00169	6a 28		 push	 40			; 00000028H
  0016b	55		 push	 ebp
  0016c	33 db		 xor	 ebx, ebx
  0016e	53		 push	 ebx
  0016f	8b cf		 mov	 ecx, edi
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00177	8b 07		 mov	 eax, DWORD PTR [edi]
  00179	3b c3		 cmp	 eax, ebx
  0017b	c6 44 24 24 02	 mov	 BYTE PTR __$EHRec$[esp+48], 2
  00180	74 0e		 je	 SHORT $L121780
  00182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00188	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0018a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018c	50		 push	 eax
  0018d	ff 52 08	 call	 DWORD PTR [edx+8]
$L121780:
  00190	89 1f		 mov	 DWORD PTR [edi], ebx
  00192	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00195	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00198	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  0019d	89 06		 mov	 DWORD PTR [esi], eax
  0019f	8b ce		 mov	 ecx, esi
  001a1	c7 44 24 24 07
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 7
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001af	8b ce		 mov	 ecx, esi
  001b1	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001bf	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001c3	5f		 pop	 edi
  001c4	5e		 pop	 esi
  001c5	5d		 pop	 ebp
  001c6	5b		 pop	 ebx
  001c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ce	83 c4 18	 add	 esp, 24			; 00000018H
  001d1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L121592:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L121594:
  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L121596:
  00012	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L121597:
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00024	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L121598:
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00032	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L121600:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR $T121646[ebp]
  0003a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L121648:
  00040	8b 4d f0	 mov	 ecx, DWORD PTR $T121694[ebp]
  00043	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L121696:
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L121794:
  00052	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T121786
  00057	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UFractalTexture@@UAE@XZ ENDP				; UFractalTexture::~UFractalTexture
PUBLIC	??1?$TArray@E@@QAE@XZ				; TArray<unsigned char>::~TArray<unsigned char>
PUBLIC	?Remove@?$TArray@E@@QAEXHH@Z			; TArray<unsigned char>::Remove
PUBLIC	?Load@?$TLazyArray@E@@UAEXXZ			; TLazyArray<unsigned char>::Load
PUBLIC	?Unload@?$TLazyArray@E@@UAEXXZ			; TLazyArray<unsigned char>::Unload
PUBLIC	??_7?$TLazyArray@E@@6B@				; TLazyArray<unsigned char>::`vftable'
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	SEGMENT
$T121898 DD	0ffffffffH
	DD	FLAT:$L121803
	DD	00H
	DD	FLAT:$L121819
	DD	00H
	DD	FLAT:$L121821
$T121894 DD	019930520H
	DD	03H
	DD	FLAT:$T121898
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$TLazyArray@E@@6B@
CONST	SEGMENT
??_7?$TLazyArray@E@@6B@ DD FLAT:?Load@?$TLazyArray@E@@UAEXXZ ; TLazyArray<unsigned char>::`vftable'
	DD	FLAT:?Unload@?$TLazyArray@E@@UAEXXZ
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??1?$TArray@UFMipmap@@@@QAE@XZ
_TEXT	SEGMENT
$T121824 = -16
$T121832 = -20
_this$ = -24
__$EHRec$ = -12
??1?$TArray@UFMipmap@@@@QAE@XZ PROC NEAR		; TArray<FMipmap>::~TArray<FMipmap>, COMDAT
; _this$ = ecx

; 371  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L121897
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b e9		 mov	 ebp, ecx
  0001d	57		 push	 edi
  0001e	89 6c 24 14	 mov	 DWORD PTR _this$[esp+44], ebp

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

  00022	8b 5d 04	 mov	 ebx, DWORD PTR [ebp+4]
  00025	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0002b	33 ff		 xor	 edi, edi
  0002d	3b df		 cmp	 ebx, edi
  0002f	89 7c 24 28	 mov	 DWORD PTR __$EHRec$[esp+52], edi
  00033	89 5c 24 10	 mov	 DWORD PTR -28+[esp+44], ebx
  00037	7d 14		 jge	 SHORT $L121862
  00039	68 fd 01 00 00	 push	 509			; 000001fdH
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00043	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00048	ff d6		 call	 esi
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121862:
  0004d	3b 5d 04	 cmp	 ebx, DWORD PTR [ebp+4]
  00050	7e 14		 jle	 SHORT $L121863
  00052	68 fe 01 00 00	 push	 510			; 000001feH
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  00061	ff d6		 call	 esi
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121863:
  00066	3b df		 cmp	 ebx, edi
  00068	7e 5c		 jle	 SHORT $L121868

; 375  : 	}

  0006a	8d 9b 00 00 00
	00		 npad	 6

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

$L121866:
  00070	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  00073	03 c7		 add	 eax, edi
  00075	8d 70 10	 lea	 esi, DWORD PTR [eax+16]
  00078	89 74 24 18	 mov	 DWORD PTR $T121832[esp+44], esi
  0007c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7?$TLazyArray@E@@6B@ ; TLazyArray<unsigned char>::`vftable'
  00082	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00085	85 c9		 test	 ecx, ecx
  00087	c6 44 24 28 01	 mov	 BYTE PTR __$EHRec$[esp+52], 1
  0008c	74 06		 je	 SHORT $L121880
  0008e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00090	56		 push	 esi
  00091	ff 50 3c	 call	 DWORD PTR [eax+60]
$L121880:
  00094	83 c6 0c	 add	 esi, 12			; 0000000cH
  00097	89 74 24 1c	 mov	 DWORD PTR $T121824[esp+44], esi
  0009b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0009e	51		 push	 ecx
  0009f	6a 00		 push	 0
  000a1	8b ce		 mov	 ecx, esi
  000a3	c6 44 24 30 02	 mov	 BYTE PTR __$EHRec$[esp+60], 2
  000a8	e8 00 00 00 00	 call	 ?Remove@?$TArray@E@@QAEXHH@Z ; TArray<unsigned char>::Remove
  000ad	8b ce		 mov	 ecx, esi
  000af	c6 44 24 28 00	 mov	 BYTE PTR __$EHRec$[esp+52], 0
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  000ba	83 c7 28	 add	 edi, 40			; 00000028H
  000bd	4b		 dec	 ebx
  000be	75 b0		 jne	 SHORT $L121866
  000c0	8b 5c 24 10	 mov	 ebx, DWORD PTR -28+[esp+44]
  000c4	33 ff		 xor	 edi, edi
$L121868:
  000c6	6a 28		 push	 40			; 00000028H
  000c8	53		 push	 ebx
  000c9	57		 push	 edi
  000ca	8b cd		 mov	 ecx, ebp
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z

; 375  : 	}

  000d2	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000d5	3b c7		 cmp	 eax, edi
  000d7	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+52], -1
  000df	74 0e		 je	 SHORT $L121891
  000e1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000e7	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000e9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000eb	50		 push	 eax
  000ec	ff 52 08	 call	 DWORD PTR [edx+8]
$L121891:
  000ef	8b 4c 24 20	 mov	 ecx, DWORD PTR __$EHRec$[esp+44]
  000f3	89 7d 00	 mov	 DWORD PTR [ebp], edi
  000f6	89 7d 08	 mov	 DWORD PTR [ebp+8], edi
  000f9	89 7d 04	 mov	 DWORD PTR [ebp+4], edi
  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5d		 pop	 ebp
  000ff	5b		 pop	 ebx
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00107	83 c4 1c	 add	 esp, 28			; 0000001cH
  0010a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L121803:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L121819:
  00009	83 7d ec 00	 cmp	 DWORD PTR $T121832[ebp], 0
  0000d	0f 84 0e 00 00
	00		 je	 $L121817
  00013	8b 45 ec	 mov	 eax, DWORD PTR $T121832[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 f0	 mov	 DWORD PTR $T121824[ebp], eax
  0001c	e9 07 00 00 00	 jmp	 $L121818
$L121817:
  00021	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T121824[ebp], 0
$L121818:
  00028	8b 4d f0	 mov	 ecx, DWORD PTR $T121824[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$TArray@E@@QAE@XZ	; TArray<unsigned char>::~TArray<unsigned char>
$L121821:
  00030	8b 4d f0	 mov	 ecx, DWORD PTR $T121824[ebp]
  00033	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L121897:
  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T121894
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1?$TArray@UFMipmap@@@@QAE@XZ ENDP			; TArray<FMipmap>::~TArray<FMipmap>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T121931 DD	0ffffffffH
	DD	FLAT:$L121904
$T121927 DD	019930520H
	DD	01H
	DD	FLAT:$T121931
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TArray@E@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$TArray@E@@QAE@XZ PROC NEAR				; TArray<unsigned char>::~TArray<unsigned char>, COMDAT
; _this$ = ecx

; 371  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L121930
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	57		 push	 edi
  0001b	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

  0001f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00022	85 ff		 test	 edi, edi
  00024	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0002a	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0
  00032	7d 14		 jge	 SHORT $L121911
  00034	68 fd 01 00 00	 push	 509			; 000001fdH
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00043	ff d3		 call	 ebx
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121911:
  00048	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0004b	7e 14		 jle	 SHORT $L121912
  0004d	68 fe 01 00 00	 push	 510			; 000001feH
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005c	ff d3		 call	 ebx
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L121912:
  00061	6a 01		 push	 1
  00063	57		 push	 edi
  00064	6a 00		 push	 0
  00066	8b ce		 mov	 ecx, esi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z

; 375  : 	}

  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	85 c0		 test	 eax, eax
  00072	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  0007a	74 0e		 je	 SHORT $L121925
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00082	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00084	8b 11		 mov	 edx, DWORD PTR [ecx]
  00086	50		 push	 eax
  00087	ff 52 08	 call	 DWORD PTR [edx+8]
$L121925:
  0008a	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0008e	5f		 pop	 edi
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00095	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0009c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ac	83 c4 10	 add	 esp, 16			; 00000010H
  000af	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L121904:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L121930:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T121927
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1?$TArray@E@@QAE@XZ ENDP				; TArray<unsigned char>::~TArray<unsigned char>
EXTRN	__imp_?GNumLazyLoads@@3HA:DWORD
; Function compile flags: /Ogty
;	COMDAT ?Load@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT
_PushedPos$110619 = -4
?Load@?$TLazyArray@E@@UAEXXZ PROC NEAR			; TLazyArray<unsigned char>::Load, COMDAT
; _this$ = ecx

; 807  : 	{

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 808  : 		// Make sure this array is loaded.
; 809  : 		if( SavedPos>0 )

  00004	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00007	85 c0		 test	 eax, eax
  00009	0f 8e 85 00 00
	00		 jle	 $L110618

; 810  : 		{
; 811  : 			// Lazy load it now.
; 812  : 			INT PushedPos = SavedAr->Tell();

  0000f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	53		 push	 ebx
  00015	55		 push	 ebp
  00016	57		 push	 edi
  00017	ff 50 28	 call	 DWORD PTR [eax+40]

; 813  : 			SavedAr->Seek( SavedPos );

  0001a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	89 44 24 10	 mov	 DWORD PTR _PushedPos$110619[esp+20], eax
  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00026	50		 push	 eax
  00027	ff 52 34	 call	 DWORD PTR [edx+52]

; 814  : 			*SavedAr << (TArray<T>&)*this;

  0002a	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0002d	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00030	8b 17		 mov	 edx, DWORD PTR [edi]
  00032	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  00035	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00038	8d 6b 04	 lea	 ebp, DWORD PTR [ebx+4]
  0003b	50		 push	 eax
  0003c	51		 push	 ecx
  0003d	8b cf		 mov	 ecx, edi
  0003f	ff 52 14	 call	 DWORD PTR [edx+20]
  00042	55		 push	 ebp
  00043	57		 push	 edi
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6@YAAAVFArchive@@AAV0@AAVFCompactIndex@@@Z
  0004a	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	74 10		 je	 SHORT $L122053
  00054	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00057	6a 01		 push	 1
  00059	8b cb		 mov	 ecx, ebx
  0005b	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L122053:
  00064	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00067	8b 13		 mov	 edx, DWORD PTR [ebx]
  00069	8b 07		 mov	 eax, DWORD PTR [edi]
  0006b	51		 push	 ecx
  0006c	52		 push	 edx
  0006d	8b cf		 mov	 ecx, edi
  0006f	ff 50 04	 call	 DWORD PTR [eax+4]

; 815  : 			SavedPos *= -1;

  00072	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 816  : 			SavedAr->Seek( PushedPos );

  00075	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00078	f7 d8		 neg	 eax
  0007a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007d	8b 44 24 10	 mov	 eax, DWORD PTR _PushedPos$110619[esp+20]
  00081	8b 11		 mov	 edx, DWORD PTR [ecx]
  00083	50		 push	 eax
  00084	ff 52 34	 call	 DWORD PTR [edx+52]

; 817  : 			GNumLazyLoads++;		// JEP

  00087	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GNumLazyLoads@@3HA
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	5f		 pop	 edi
  0008f	41		 inc	 ecx
  00090	5d		 pop	 ebp
  00091	89 08		 mov	 DWORD PTR [eax], ecx
  00093	5b		 pop	 ebx
$L110618:
  00094	5e		 pop	 esi

; 818  : 		}
; 819  : 	}

  00095	59		 pop	 ecx
  00096	c3		 ret	 0
?Load@?$TLazyArray@E@@UAEXXZ ENDP			; TLazyArray<unsigned char>::Load
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Unload@?$TLazyArray@E@@UAEXXZ
_TEXT	SEGMENT
?Unload@?$TLazyArray@E@@UAEXXZ PROC NEAR		; TLazyArray<unsigned char>::Unload, COMDAT
; _this$ = ecx

; 824  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 825  : 		// Make sure this array is unloaded.
; 826  : 		if( SavedPos<0 )

  00003	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00006	33 c0		 xor	 eax, eax
  00008	3b c8		 cmp	 ecx, eax
  0000a	7d 19		 jge	 SHORT $L110623

; 827  : 		{
; 828  : 			// Unload it now.
; 829  : 			Empty();

  0000c	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0000f	6a 01		 push	 1
  00011	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00014	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 830  : 			SavedPos *= -1;

  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	f7 d8		 neg	 eax
  00022	89 46 08	 mov	 DWORD PTR [esi+8], eax
$L110623:
  00025	5e		 pop	 esi

; 831  : 		}
; 832  : 	}

  00026	c3		 ret	 0
?Unload@?$TLazyArray@E@@UAEXXZ ENDP			; TLazyArray<unsigned char>::Unload
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Remove@?$TArray@E@@QAEXHH@Z
_TEXT	SEGMENT
_Index$ = 8
_Count$ = 12
?Remove@?$TArray@E@@QAEXHH@Z PROC NEAR			; TArray<unsigned char>::Remove, COMDAT
; _this$ = ecx

; 507  : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 508  : 		check(Index>=0);

  00002	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 7c 24 14	 mov	 edi, DWORD PTR _Index$[esp+12]
  0000e	85 ff		 test	 edi, edi
  00010	8b f1		 mov	 esi, ecx
  00012	7d 14		 jge	 SHORT $L111064
  00014	68 fc 01 00 00	 push	 508			; 000001fcH
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  00023	ff d5		 call	 ebp
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$L111064:

; 509  : 		check(Index<=ArrayNum);

  00028	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0002b	7e 14		 jle	 SHORT $L111065
  0002d	68 fd 01 00 00	 push	 509			; 000001fdH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0003c	ff d5		 call	 ebp
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L111065:

; 510  : 		check(Index+Count<=ArrayNum);

  00041	8b 5c 24 18	 mov	 ebx, DWORD PTR _Count$[esp+12]
  00045	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00048	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0004b	3b c1		 cmp	 eax, ecx
  0004d	7e 14		 jle	 SHORT $L111066
  0004f	68 fe 01 00 00	 push	 510			; 000001feH
  00054	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005e	ff d5		 call	 ebp
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$L111066:

; 511  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 512  : 			for( INT i=Index; i<Index+Count; i++ )
; 513  : 				(&(*this)(i))->~T();
; 514  : 		FArray::Remove( Index, Count, sizeof(T) );

  00063	6a 01		 push	 1
  00065	53		 push	 ebx
  00066	57		 push	 edi
  00067	8b ce		 mov	 ecx, esi
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5d		 pop	 ebp
  00072	5b		 pop	 ebx

; 515  : 	}

  00073	c2 08 00	 ret	 8
?Remove@?$TArray@E@@QAEXHH@Z ENDP			; TArray<unsigned char>::Remove
_TEXT	ENDS
EXTRN	__imp_??1FMipmap@@QAE@XZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ??_GFMipmap@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GFMipmap@@QAEPAXI@Z PROC NEAR			; FMipmap::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  00009	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000e	74 0d		 je	 SHORT $L122113
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	56		 push	 esi
  0001a	ff 52 08	 call	 DWORD PTR [edx+8]
$L122113:
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	c2 04 00	 ret	 4
??_GFMipmap@@QAEPAXI@Z ENDP				; FMipmap::`scalar deleting destructor'
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
_TEXT	ENDS
;	COMDAT ?PostEditChange@UFractalTexture@@UAEXXZ
_TEXT	SEGMENT
?PostEditChange@UFractalTexture@@UAEXXZ PROC NEAR	; UFractalTexture::PostEditChange, COMDAT
; _this$ = ecx

; 94   : 	void PostEditChange() {PostLoad();}

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 14	 jmp	 DWORD PTR [eax+20]
?PostEditChange@UFractalTexture@@UAEXXZ ENDP		; UFractalTexture::PostEditChange
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?TouchTexture@UFractalTexture@@UAEXHHM@Z
_TEXT	SEGMENT
?TouchTexture@UFractalTexture@@UAEXHHM@Z PROC NEAR	; UFractalTexture::TouchTexture, COMDAT
; _this$ = ecx

; 100  : 	virtual void TouchTexture(INT UPos, INT VPos, FLOAT Magnitude) {}

  00000	c2 0c 00	 ret	 12			; 0000000cH
?TouchTexture@UFractalTexture@@UAEXHHM@Z ENDP		; UFractalTexture::TouchTexture
_TEXT	ENDS
PUBLIC	??0UFractalTexture@@QAE@ABV0@@Z			; UFractalTexture::UFractalTexture
PUBLIC	??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z		; TArray<FMipmap>::TArray<FMipmap>
EXTRN	__imp_??0UObject@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T122147 DD	0ffffffffH
	DD	FLAT:$L122127
	DD	00H
	DD	FLAT:$L122128
$T122145 DD	019930520H
	DD	02H
	DD	FLAT:$T122147
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UFractalTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0UFractalTexture@@QAE@ABV0@@Z PROC NEAR		; UFractalTexture::UFractalTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L122146
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UObject@@QAE@ABV0@@Z
  00029	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  0002c	88 46 28	 mov	 BYTE PTR [esi+40], al
  0002f	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00032	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00035	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00038	88 56 30	 mov	 BYTE PTR [esi+48], dl
  0003b	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  0003e	88 46 31	 mov	 BYTE PTR [esi+49], al
  00041	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00044	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00047	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  0004a	89 56 38	 mov	 DWORD PTR [esi+56], edx
  0004d	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00050	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00053	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00056	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00059	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  0005c	89 56 44	 mov	 DWORD PTR [esi+68], edx
  0005f	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  00062	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00065	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00068	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  0006b	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0006e	89 56 50	 mov	 DWORD PTR [esi+80], edx
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00076	89 06		 mov	 DWORD PTR [esi], eax
  00078	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  0007b	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
  0007e	8b 57 58	 mov	 edx, DWORD PTR [edi+88]
  00081	89 56 58	 mov	 DWORD PTR [esi+88], edx
  00084	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  00087	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0008a	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0008d	89 4e 60	 mov	 DWORD PTR [esi+96], ecx
  00090	8b 57 64	 mov	 edx, DWORD PTR [edi+100]
  00093	89 56 64	 mov	 DWORD PTR [esi+100], edx
  00096	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00099	89 46 68	 mov	 DWORD PTR [esi+104], eax
  0009c	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  0009f	89 4e 6c	 mov	 DWORD PTR [esi+108], ecx
  000a2	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  000a5	89 56 70	 mov	 DWORD PTR [esi+112], edx
  000a8	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000ab	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000ae	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  000b1	89 4e 78	 mov	 DWORD PTR [esi+120], ecx
  000b4	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]
  000b7	89 56 7c	 mov	 DWORD PTR [esi+124], edx
  000ba	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [edi+128]
  000c0	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  000c6	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  000cc	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx
  000d2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000d8	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000de	33 c1		 xor	 eax, ecx
  000e0	83 e0 01	 and	 eax, 1
  000e3	33 c1		 xor	 eax, ecx
  000e5	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000eb	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f1	33 c8		 xor	 ecx, eax
  000f3	83 e1 02	 and	 ecx, 2
  000f6	33 c8		 xor	 ecx, eax
  000f8	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000fe	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00104	33 c1		 xor	 eax, ecx
  00106	83 e0 04	 and	 eax, 4
  00109	33 c1		 xor	 eax, ecx
  0010b	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00111	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00117	33 c8		 xor	 ecx, eax
  00119	83 e1 08	 and	 ecx, 8
  0011c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00132	33 c1		 xor	 eax, ecx
  00134	83 e0 10	 and	 eax, 16			; 00000010H
  00137	33 c1		 xor	 eax, ecx
  00139	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0013f	8b 97 88 00 00
	00		 mov	 edx, DWORD PTR [edi+136]
  00145	33 d0		 xor	 edx, eax
  00147	83 e2 20	 and	 edx, 32			; 00000020H
  0014a	33 d0		 xor	 edx, eax
  0014c	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx
  00152	8a 87 8c 00 00
	00		 mov	 al, BYTE PTR [edi+140]
  00158	88 86 8c 00 00
	00		 mov	 BYTE PTR [esi+140], al
  0015e	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]
  00164	89 8e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ecx
  0016a	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [edi+148]
  00170	89 96 94 00 00
	00		 mov	 DWORD PTR [esi+148], edx
  00176	8a 87 98 00 00
	00		 mov	 al, BYTE PTR [edi+152]
  0017c	88 86 98 00 00
	00		 mov	 BYTE PTR [esi+152], al
  00182	8a 8f 99 00 00
	00		 mov	 cl, BYTE PTR [edi+153]
  00188	88 8e 99 00 00
	00		 mov	 BYTE PTR [esi+153], cl
  0018e	8b 97 9c 00 00
	00		 mov	 edx, DWORD PTR [edi+156]
  00194	89 96 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edx
  0019a	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  001a0	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  001a6	8b 8f a4 00 00
	00		 mov	 ecx, DWORD PTR [edi+164]
  001ac	8d 97 a8 00 00
	00		 lea	 edx, DWORD PTR [edi+168]
  001b2	89 8e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ecx
  001b8	52		 push	 edx
  001b9	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  001bf	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001c4	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001ca	50		 push	 eax
  001cb	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001d1	c6 44 24 18 01	 mov	 BYTE PTR __$EHRec$[esp+36], 1
  001d6	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001db	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  001e1	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  001e7	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  001ed	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  001f3	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UTexture@@6B@
  001f8	89 06		 mov	 DWORD PTR [esi], eax
  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00200	89 0e		 mov	 DWORD PTR [esi], ecx
  00202	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00208	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0020e	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00214	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0021a	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  00220	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  00226	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  0022c	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  00232	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  00238	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  0023e	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  00244	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  0024a	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  00250	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00254	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  0025a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00260	5f		 pop	 edi
  00261	8b c6		 mov	 eax, esi
  00263	5e		 pop	 esi
  00264	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0026b	83 c4 10	 add	 esp, 16			; 00000010H
  0026e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L122127:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L122128:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00012	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L122146:
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T122145
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UFractalTexture@@QAE@ABV0@@Z ENDP			; UFractalTexture::UFractalTexture
PUBLIC	??0?$TArray@E@@QAE@ABV0@@Z			; TArray<unsigned char>::TArray<unsigned char>
PUBLIC	??0FLazyLoader@@QAE@ABV0@@Z			; FLazyLoader::FLazyLoader
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnFile.h
xdata$x	SEGMENT
$T122256 DD	0ffffffffH
	DD	FLAT:$L122156
	DD	00H
	DD	FLAT:$L122190
$T122248 DD	019930520H
	DD	02H
	DD	FLAT:$T122256
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	ENDS
;	COMDAT ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
$T122195 = -16
__$EHRec$ = -12
_this$ = -20
_i$110667 = -24
_Other$ = 8
??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z PROC NEAR		; TArray<FMipmap>::TArray<FMipmap>, COMDAT
; _this$ = ecx

; 350  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L122255
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	8b 5c 24 20	 mov	 ebx, DWORD PTR _Other$[esp+24]
  0001d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00020	55		 push	 ebp
  00021	56		 push	 esi
  00022	8b f1		 mov	 esi, ecx
  00024	33 ed		 xor	 ebp, ebp
  00026	6a 28		 push	 40			; 00000028H
  00028	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  0002c	89 2e		 mov	 DWORD PTR [esi], ebp
  0002e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00031	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 351  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 352  : 		{
; 353  : 			ArrayNum=0;

  0003a	89 6e 04	 mov	 DWORD PTR [esi+4], ebp

; 354  : 			for( INT i=0; i<Other.ArrayNum; i++ )

  0003d	39 6b 04	 cmp	 DWORD PTR [ebx+4], ebp
  00040	89 6c 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], ebp
  00044	89 6c 24 0c	 mov	 DWORD PTR _i$110667[esp+36], ebp
  00048	0f 8e b6 00 00
	00		 jle	 $L122253
  0004e	57		 push	 edi
  0004f	89 6c 24 2c	 mov	 DWORD PTR 8+[esp+36], ebp
$L110668:

; 355  : 				new(*this)T(Other(i));

  00053	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00056	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00059	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0005c	3b c8		 cmp	 ecx, eax
  0005e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00061	7e 1d		 jle	 SHORT $L122177
  00063	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00066	99		 cdq
  00067	83 e2 07	 and	 edx, 7
  0006a	03 c2		 add	 eax, edx
  0006c	c1 f8 03	 sar	 eax, 3
  0006f	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  00073	6a 28		 push	 40			; 00000028H
  00075	8b ce		 mov	 ecx, esi
  00077	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L122177:
  00080	8b 16		 mov	 edx, DWORD PTR [esi]
  00082	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00085	8d 0c ca	 lea	 ecx, DWORD PTR [edx+ecx*8]
  00088	3b cd		 cmp	 ecx, ebp
  0008a	74 58		 je	 SHORT $L110669
  0008c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0008e	03 44 24 2c	 add	 eax, DWORD PTR 8+[esp+36]
  00092	8b d0		 mov	 edx, eax
  00094	8b 2a		 mov	 ebp, DWORD PTR [edx]
  00096	8b f9		 mov	 edi, ecx
  00098	89 2f		 mov	 DWORD PTR [edi], ebp
  0009a	8b 6a 04	 mov	 ebp, DWORD PTR [edx+4]
  0009d	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  000a0	8b 6a 08	 mov	 ebp, DWORD PTR [edx+8]
  000a3	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  000a6	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  000a9	89 57 0c	 mov	 DWORD PTR [edi+12], edx
  000ac	8d 68 10	 lea	 ebp, DWORD PTR [eax+16]
  000af	85 ed		 test	 ebp, ebp
  000b1	8d 79 10	 lea	 edi, DWORD PTR [ecx+16]
  000b4	89 7c 24 18	 mov	 DWORD PTR $T122195[esp+40], edi
  000b8	74 05		 je	 SHORT $L122201
  000ba	8d 45 0c	 lea	 eax, DWORD PTR [ebp+12]
  000bd	eb 02		 jmp	 SHORT $L122202
$L122201:
  000bf	33 c0		 xor	 eax, eax
$L122202:
  000c1	50		 push	 eax
  000c2	8d 4f 0c	 lea	 ecx, DWORD PTR [edi+12]
  000c5	e8 00 00 00 00	 call	 ??0?$TArray@E@@QAE@ABV0@@Z ; TArray<unsigned char>::TArray<unsigned char>
  000ca	55		 push	 ebp
  000cb	8b cf		 mov	 ecx, edi
  000cd	c6 44 24 28 01	 mov	 BYTE PTR __$EHRec$[esp+52], 1
  000d2	e8 00 00 00 00	 call	 ??0FLazyLoader@@QAE@ABV0@@Z ; FLazyLoader::FLazyLoader
  000d7	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET FLAT:??_7?$TLazyArray@E@@6B@ ; TLazyArray<unsigned char>::`vftable'
  000dd	c6 44 24 24 00	 mov	 BYTE PTR __$EHRec$[esp+48], 0
  000e2	33 ed		 xor	 ebp, ebp
$L110669:
  000e4	8b 44 24 10	 mov	 eax, DWORD PTR _i$110667[esp+40]
  000e8	8b 54 24 2c	 mov	 edx, DWORD PTR 8+[esp+36]
  000ec	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000ef	40		 inc	 eax
  000f0	83 c2 28	 add	 edx, 40			; 00000028H
  000f3	3b c1		 cmp	 eax, ecx
  000f5	89 44 24 10	 mov	 DWORD PTR _i$110667[esp+40], eax
  000f9	89 54 24 2c	 mov	 DWORD PTR 8+[esp+36], edx
  000fd	0f 8c 50 ff ff
	ff		 jl	 $L110668
  00103	5f		 pop	 edi
$L122253:

; 356  : 		}
; 357  : 		else if( sizeof(T)!=1 )
; 358  : 		{
; 359  : 			for( INT i=0; i<ArrayNum; i++ )
; 360  : 				(*this)(i) = Other(i);
; 361  : 		}
; 362  : 		else
; 363  : 		{
; 364  : 			appMemcpy( &(*this)(0), (void *)&Other(0), ArrayNum * sizeof(T) );
; 365  : 		}
; 366  : 	}

  00104	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00108	8b c6		 mov	 eax, esi
  0010a	5e		 pop	 esi
  0010b	5d		 pop	 ebp
  0010c	5b		 pop	 ebx
  0010d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00114	83 c4 18	 add	 esp, 24			; 00000018H
  00117	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L122156:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L122190:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR $T122195[ebp]
  0000c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000f	e9 00 00 00 00	 jmp	 ??1?$TArray@E@@QAE@XZ	; TArray<unsigned char>::~TArray<unsigned char>
$L122255:
  00014	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T122248
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ENDP		; TArray<FMipmap>::TArray<FMipmap>
PUBLIC	??_7FLazyLoader@@6B@				; FLazyLoader::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7FLazyLoader@@6B@
CONST	SEGMENT
??_7FLazyLoader@@6B@ DD FLAT:__purecall			; FLazyLoader::`vftable'
	DD	FLAT:__purecall
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0FLazyLoader@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0FLazyLoader@@QAE@ABV0@@Z PROC NEAR			; FLazyLoader::FLazyLoader, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000c	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7FLazyLoader@@6B@ ; FLazyLoader::`vftable'
  00018	c2 04 00	 ret	 4
??0FLazyLoader@@QAE@ABV0@@Z ENDP			; FLazyLoader::FLazyLoader
_TEXT	ENDS
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnFile.h
xdata$x	SEGMENT
$T122322 DD	0ffffffffH
	DD	FLAT:$L122268
$T122316 DD	019930520H
	DD	01H
	DD	FLAT:$T122322
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	ENDS
;	COMDAT ??0?$TArray@E@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -52
_Other$ = 8
$T122312 = 8
$T122313 = -20
$T122314 = -16
__$EHRec$ = -12
??0?$TArray@E@@QAE@ABV0@@Z PROC NEAR			; TArray<unsigned char>::TArray<unsigned char>, COMDAT
; _this$ = ecx

; 350  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L122321
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b 74 24 24	 mov	 esi, DWORD PTR _Other$[esp+28]
  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b e9		 mov	 ebp, ecx
  00024	57		 push	 edi
  00025	6a 01		 push	 1
  00027	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], 0
  0002e	89 45 04	 mov	 DWORD PTR [ebp+4], eax
  00031	89 45 08	 mov	 DWORD PTR [ebp+8], eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 351  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 352  : 		{
; 353  : 			ArrayNum=0;
; 354  : 			for( INT i=0; i<Other.ArrayNum; i++ )
; 355  : 				new(*this)T(Other(i));
; 356  : 		}
; 357  : 		else if( sizeof(T)!=1 )
; 358  : 		{
; 359  : 			for( INT i=0; i<ArrayNum; i++ )
; 360  : 				(*this)(i) = Other(i);
; 361  : 		}
; 362  : 		else
; 363  : 		{
; 364  : 			appMemcpy( &(*this)(0), (void *)&Other(0), ArrayNum * sizeof(T) );

  0003a	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0003d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003f	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00042	89 44 24 14	 mov	 DWORD PTR $T122314[esp+36], eax
  00046	89 4c 24 10	 mov	 DWORD PTR $T122313[esp+36], ecx
  0004a	89 54 24 28	 mov	 DWORD PTR $T122312[esp+32], edx
  0004e	8b 4c 24 14	 mov	 ecx, DWORD PTR $T122314[esp+36]
  00052	8b 74 24 10	 mov	 esi, DWORD PTR $T122313[esp+36]
  00056	8b 7c 24 28	 mov	 edi, DWORD PTR $T122312[esp+32]
  0005a	8b d9		 mov	 ebx, ecx
  0005c	c1 e9 02	 shr	 ecx, 2
  0005f	83 e3 03	 and	 ebx, 3
  00062	f3 a5		 rep	  movsd
  00064	8b cb		 mov	 ecx, ebx
  00066	f3 a4		 rep	  movsb

; 365  : 		}
; 366  : 	}

  00068	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	8b c5		 mov	 eax, ebp
  00070	5d		 pop	 ebp
  00071	5b		 pop	 ebx
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	83 c4 14	 add	 esp, 20			; 00000014H
  0007c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L122268:
  00000	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L122321:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T122316
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0?$TArray@E@@QAE@ABV0@@Z ENDP				; TArray<unsigned char>::TArray<unsigned char>
PUBLIC	??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z		; operator new
PUBLIC	??4UFractalTexture@@QAEAAV0@ABV0@@Z		; UFractalTexture::operator=
PUBLIC	??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z		; TArray<FMipmap>::operator=
EXTRN	__imp_??4UObject@@QAEAAV0@ABV0@@Z:NEAR
EXTRN	__imp_??0FMipmap@@QAE@ABU0@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ??4UFractalTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T122355 = -4
_i$122421 = -8
_i$122434 = -8
___that$ = 8
??4UFractalTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UFractalTexture::operator=, COMDAT
; _this$ = ecx
  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0000b	57		 push	 edi
  0000c	8b f1		 mov	 esi, ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UObject@@QAEAAV0@ABV0@@Z
  00014	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  00017	88 46 28	 mov	 BYTE PTR [esi+40], al
  0001a	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001d	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00020	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00023	88 56 30	 mov	 BYTE PTR [esi+48], dl
  00026	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  00029	88 46 31	 mov	 BYTE PTR [esi+49], al
  0002c	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0002f	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00032	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00035	89 56 38	 mov	 DWORD PTR [esi+56], edx
  00038	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  0003b	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0003e	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00041	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00044	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00047	89 56 44	 mov	 DWORD PTR [esi+68], edx
  0004a	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0004d	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00050	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00053	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00056	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  00059	89 56 50	 mov	 DWORD PTR [esi+80], edx
  0005c	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0005f	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00062	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00065	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00068	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  0006b	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0006e	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00071	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00074	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  00077	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  0007a	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  0007d	89 56 68	 mov	 DWORD PTR [esi+104], edx
  00080	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00083	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00086	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00089	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  0008c	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  0008f	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00092	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  00095	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00098	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  0009b	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  0009e	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000a4	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000aa	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  000b0	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  000b6	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000bc	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c2	33 c1		 xor	 eax, ecx
  000c4	83 e0 01	 and	 eax, 1
  000c7	33 c1		 xor	 eax, ecx
  000c9	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000cf	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d5	33 c8		 xor	 ecx, eax
  000d7	83 e1 02	 and	 ecx, 2
  000da	33 c8		 xor	 ecx, eax
  000dc	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e2	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000e8	33 c1		 xor	 eax, ecx
  000ea	83 e0 04	 and	 eax, 4
  000ed	33 c1		 xor	 eax, ecx
  000ef	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000f5	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000fb	33 c8		 xor	 ecx, eax
  000fd	83 e1 08	 and	 ecx, 8
  00100	33 c8		 xor	 ecx, eax
  00102	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00108	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0010e	33 c1		 xor	 eax, ecx
  00110	83 e0 10	 and	 eax, 16			; 00000010H
  00113	33 c1		 xor	 eax, ecx
  00115	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0011b	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00121	33 c8		 xor	 ecx, eax
  00123	83 e1 20	 and	 ecx, 32			; 00000020H
  00126	33 c8		 xor	 ecx, eax
  00128	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012e	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00134	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  0013a	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  00140	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00146	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  0014c	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00152	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  00158	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  0015e	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00164	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  0016a	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00170	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  00176	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  0017c	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00182	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  00188	8d af a8 00 00
	00		 lea	 ebp, DWORD PTR [edi+168]
  0018e	8d 9e a8 00 00
	00		 lea	 ebx, DWORD PTR [esi+168]
  00194	3b dd		 cmp	 ebx, ebp
  00196	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  0019c	0f 84 a8 00 00
	00		 je	 $L122437
  001a2	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001a5	89 4c 24 14	 mov	 DWORD PTR $T122355[esp+24], ecx
  001a9	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001ac	33 c0		 xor	 eax, eax
  001ae	3b c8		 cmp	 ecx, eax
  001b0	89 44 24 10	 mov	 DWORD PTR _i$122421[esp+24], eax
  001b4	7e 34		 jle	 SHORT $L122424
  001b6	89 44 24 1c	 mov	 DWORD PTR 8+[esp+20], eax
  001ba	8d 9b 00 00 00
	00		 npad	 6
$L122422:
  001c0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001c2	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  001c6	6a 00		 push	 0
  001c8	03 ca		 add	 ecx, edx
  001ca	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  001cf	8b 44 24 10	 mov	 eax, DWORD PTR _i$122421[esp+24]
  001d3	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  001d7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001da	40		 inc	 eax
  001db	83 c2 28	 add	 edx, 40			; 00000028H
  001de	3b c1		 cmp	 eax, ecx
  001e0	89 44 24 10	 mov	 DWORD PTR _i$122421[esp+24], eax
  001e4	89 54 24 1c	 mov	 DWORD PTR 8+[esp+20], edx
  001e8	7c d6		 jl	 SHORT $L122422
$L122424:
  001ea	8b 54 24 14	 mov	 edx, DWORD PTR $T122355[esp+24]
  001ee	52		 push	 edx
  001ef	6a 28		 push	 40			; 00000028H
  001f1	8b cb		 mov	 ecx, ebx
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Empty@FArray@@QAEXHH@Z
  001f9	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001fc	33 c0		 xor	 eax, eax
  001fe	3b c8		 cmp	 ecx, eax
  00200	89 44 24 10	 mov	 DWORD PTR _i$122434[esp+24], eax
  00204	7e 44		 jle	 SHORT $L122437
  00206	89 44 24 1c	 mov	 DWORD PTR 8+[esp+20], eax
  0020a	8d 9b 00 00 00
	00		 npad	 6
$L122435:
  00210	53		 push	 ebx
  00211	6a 28		 push	 40			; 00000028H
  00213	e8 00 00 00 00	 call	 ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ; operator new
  00218	83 c4 08	 add	 esp, 8
  0021b	85 c0		 test	 eax, eax
  0021d	74 10		 je	 SHORT $L122436
  0021f	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00222	03 4c 24 1c	 add	 ecx, DWORD PTR 8+[esp+20]
  00226	51		 push	 ecx
  00227	8b c8		 mov	 ecx, eax
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L122436:
  0022f	8b 44 24 10	 mov	 eax, DWORD PTR _i$122434[esp+24]
  00233	8b 54 24 1c	 mov	 edx, DWORD PTR 8+[esp+20]
  00237	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  0023a	40		 inc	 eax
  0023b	83 c2 28	 add	 edx, 40			; 00000028H
  0023e	3b c1		 cmp	 eax, ecx
  00240	89 44 24 10	 mov	 DWORD PTR _i$122434[esp+24], eax
  00244	89 54 24 1c	 mov	 DWORD PTR 8+[esp+20], edx
  00248	7c c6		 jl	 SHORT $L122435
$L122437:
  0024a	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  00250	52		 push	 edx
  00251	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00257	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  0025c	8a 87 c0 00 00
	00		 mov	 al, BYTE PTR [edi+192]
  00262	88 86 c0 00 00
	00		 mov	 BYTE PTR [esi+192], al
  00268	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  0026e	89 8e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ecx
  00274	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  0027a	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  00280	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00286	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0028c	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  00292	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  00298	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  0029e	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  002a4	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  002aa	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  002b0	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  002b6	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  002bc	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  002c2	5f		 pop	 edi
  002c3	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  002c9	8b c6		 mov	 eax, esi
  002cb	5e		 pop	 esi
  002cc	5d		 pop	 ebp
  002cd	5b		 pop	 ebx
  002ce	83 c4 08	 add	 esp, 8
  002d1	c2 04 00	 ret	 4
??4UFractalTexture@@QAEAAV0@ABV0@@Z ENDP		; UFractalTexture::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
$T122489 = 8
_Other$ = 8
??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z PROC NEAR	; TArray<FMipmap>::operator=, COMDAT
; _this$ = ecx

; 526  : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 527  : 		if( this != &Other )

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _Other$[esp+4]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	3b f5		 cmp	 esi, ebp
  0000b	57		 push	 edi
  0000c	0f 84 a8 00 00
	00		 je	 $L122516

; 528  : 		{
; 529  : 			Empty( Other.ArrayNum );

  00012	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00015	89 44 24 14	 mov	 DWORD PTR $T122489[esp+12], eax
  00019	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001c	33 ff		 xor	 edi, edi
  0001e	85 c0		 test	 eax, eax
  00020	7e 17		 jle	 SHORT $L122476
  00022	33 db		 xor	 ebx, ebx
$L122474:
  00024	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00026	03 cb		 add	 ecx, ebx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	47		 inc	 edi
  00032	83 c3 28	 add	 ebx, 40			; 00000028H
  00035	3b f8		 cmp	 edi, eax
  00037	7c eb		 jl	 SHORT $L122474
$L122476:
  00039	8b 4c 24 14	 mov	 ecx, DWORD PTR $T122489[esp+12]
  0003d	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00040	6a 28		 push	 40			; 00000028H
  00042	8b ce		 mov	 ecx, esi
  00044	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z

; 530  : 			for( INT i=0; i<Other.ArrayNum; i++ )

  00051	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00054	33 db		 xor	 ebx, ebx
  00056	3b c3		 cmp	 eax, ebx
  00058	7e 60		 jle	 SHORT $L122516

; 528  : 		{
; 529  : 			Empty( Other.ArrayNum );

  0005a	89 5c 24 14	 mov	 DWORD PTR 8+[esp+12], ebx

; 534  : 	}

  0005e	8b ff		 npad	 2
$L110699:

; 531  : 				new( *this )T( Other(i) );

  00060	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00063	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00066	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00069	3b c8		 cmp	 ecx, eax
  0006b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0006e	7e 1d		 jle	 SHORT $L122505
  00070	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00073	99		 cdq
  00074	83 e2 07	 and	 edx, 7
  00077	03 c2		 add	 eax, edx
  00079	c1 f8 03	 sar	 eax, 3
  0007c	8d 54 08 20	 lea	 edx, DWORD PTR [eax+ecx+32]
  00080	6a 28		 push	 40			; 00000028H
  00082	8b ce		 mov	 ecx, esi
  00084	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L122505:
  0008d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008f	8d 04 bf	 lea	 eax, DWORD PTR [edi+edi*4]
  00092	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  00095	85 c9		 test	 ecx, ecx
  00097	74 0e		 je	 SHORT $L110700
  00099	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  0009c	03 54 24 14	 add	 edx, DWORD PTR 8+[esp+12]
  000a0	52		 push	 edx
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L110700:
  000a7	8b 4c 24 14	 mov	 ecx, DWORD PTR 8+[esp+12]
  000ab	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  000ae	43		 inc	 ebx
  000af	83 c1 28	 add	 ecx, 40			; 00000028H
  000b2	3b d8		 cmp	 ebx, eax
  000b4	89 4c 24 14	 mov	 DWORD PTR 8+[esp+12], ecx
  000b8	7c a6		 jl	 SHORT $L110699
$L122516:
  000ba	5f		 pop	 edi

; 532  : 		}
; 533  : 		return *this;

  000bb	8b c6		 mov	 eax, esi
  000bd	5e		 pop	 esi
  000be	5d		 pop	 ebp
  000bf	5b		 pop	 ebx

; 534  : 	}

  000c0	c2 04 00	 ret	 4
??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ENDP		; TArray<FMipmap>::operator=
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z
_TEXT	SEGMENT
_Array$ = 12
??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z PROC NEAR		; operator new, COMDAT

; 587  : {

  00000	56		 push	 esi

; 588  : 	INT Index = Array.FArray::Add(1,sizeof(T));

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _Array$[esp]
  00005	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00008	57		 push	 edi
  00009	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0000c	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000f	3b c8		 cmp	 ecx, eax
  00011	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00014	7e 1d		 jle	 SHORT $L122524
  00016	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00019	99		 cdq
  0001a	83 e2 07	 and	 edx, 7
  0001d	03 c2		 add	 eax, edx
  0001f	c1 f8 03	 sar	 eax, 3
  00022	8d 44 08 20	 lea	 eax, DWORD PTR [eax+ecx+32]
  00026	6a 28		 push	 40			; 00000028H
  00028	8b ce		 mov	 ecx, esi
  0002a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
$L122524:

; 589  : 	return &Array(Index);

  00033	8b 16		 mov	 edx, DWORD PTR [esi]
  00035	8d 0c bf	 lea	 ecx, DWORD PTR [edi+edi*4]
  00038	5f		 pop	 edi
  00039	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0003c	5e		 pop	 esi

; 590  : }

  0003d	c3		 ret	 0
??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ENDP		; operator new
_TEXT	ENDS
PUBLIC	??_GUFractalTexture@@UAEPAXI@Z			; UFractalTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUFractalTexture@@UAEPAXI@Z PROC NEAR		; UFractalTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L122534
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L122534:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUFractalTexture@@UAEPAXI@Z ENDP			; UFractalTexture::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Ogty
;	COMDAT ??_EUFractalTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUFractalTexture@@UAEPAXI@Z PROC NEAR		; UFractalTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L107676
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 e0 00 00 00	 push	 224			; 000000e0H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L122540
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L122540:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L107676:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L122542
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L122542:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUFractalTexture@@UAEPAXI@Z ENDP			; UFractalTexture::`vector deleting destructor'
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
_TEXT	ENDS
;	COMDAT ??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z
_TEXT	SEGMENT
_Ar$ = 8
_S$ = 12
??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z PROC NEAR		; operator<<, COMDAT

; 175  : 	{

  00000	56		 push	 esi

; 176  : 		return  Ar << S.Type << S.Heat << S.X << S.Y << S.ByteA << S.ByteB << S.ByteC << S.ByteD;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Ar$[esp]
  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	57		 push	 edi
  00008	8b 7c 24 10	 mov	 edi, DWORD PTR _S$[esp+4]
  0000c	6a 01		 push	 1
  0000e	57		 push	 edi
  0000f	8b ce		 mov	 ecx, esi
  00011	ff 50 04	 call	 DWORD PTR [eax+4]
  00014	8b 16		 mov	 edx, DWORD PTR [esi]
  00016	6a 01		 push	 1
  00018	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0001b	50		 push	 eax
  0001c	8b ce		 mov	 ecx, esi
  0001e	ff 52 04	 call	 DWORD PTR [edx+4]
  00021	8b 16		 mov	 edx, DWORD PTR [esi]
  00023	6a 01		 push	 1
  00025	8d 47 02	 lea	 eax, DWORD PTR [edi+2]
  00028	50		 push	 eax
  00029	8b ce		 mov	 ecx, esi
  0002b	ff 52 04	 call	 DWORD PTR [edx+4]
  0002e	8b 16		 mov	 edx, DWORD PTR [esi]
  00030	6a 01		 push	 1
  00032	8d 47 03	 lea	 eax, DWORD PTR [edi+3]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	ff 52 04	 call	 DWORD PTR [edx+4]
  0003b	8b 16		 mov	 edx, DWORD PTR [esi]
  0003d	6a 01		 push	 1
  0003f	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00042	50		 push	 eax
  00043	8b ce		 mov	 ecx, esi
  00045	ff 52 04	 call	 DWORD PTR [edx+4]
  00048	8b 16		 mov	 edx, DWORD PTR [esi]
  0004a	6a 01		 push	 1
  0004c	8d 47 05	 lea	 eax, DWORD PTR [edi+5]
  0004f	50		 push	 eax
  00050	8b ce		 mov	 ecx, esi
  00052	ff 52 04	 call	 DWORD PTR [edx+4]
  00055	8b 16		 mov	 edx, DWORD PTR [esi]
  00057	6a 01		 push	 1
  00059	8d 47 06	 lea	 eax, DWORD PTR [edi+6]
  0005c	50		 push	 eax
  0005d	8b ce		 mov	 ecx, esi
  0005f	ff 52 04	 call	 DWORD PTR [edx+4]
  00062	8b 16		 mov	 edx, DWORD PTR [esi]
  00064	6a 01		 push	 1
  00066	83 c7 07	 add	 edi, 7
  00069	57		 push	 edi
  0006a	8b ce		 mov	 ecx, esi
  0006c	ff 52 04	 call	 DWORD PTR [edx+4]
  0006f	5f		 pop	 edi
  00070	8b c6		 mov	 eax, esi
  00072	5e		 pop	 esi

; 177  : 	}

  00073	c3		 ret	 0
??6@YAAAVFArchive@@AAV0@AAVFSpark@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??4FSpark@@QAEAAV0@ABV0@@Z			; FSpark::operator=
; Function compile flags: /Ogty
;	COMDAT ??4FSpark@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4FSpark@@QAEAAV0@ABV0@@Z PROC NEAR			; FSpark::operator=, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	c2 04 00	 ret	 4
??4FSpark@@QAEAAV0@ABV0@@Z ENDP				; FSpark::operator=
_TEXT	ENDS
PUBLIC	?StaticClass@UFireTexture@@SAPAVUClass@@XZ	; UFireTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UFireTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UFireTexture@@SAPAVUClass@@XZ PROC NEAR	; UFireTexture::StaticClass, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UFireTexture@@SAPAVUClass@@XZ ENDP		; UFireTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UFireTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UFireTexture::operator new, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UFireTexture@@0VUClass@@A ; UFireTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UFireTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UFireTexture::operator new
_TEXT	ENDS
PUBLIC	??2UFireTexture@@SAPAXIPAW4EInternal@@@Z	; UFireTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UFireTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UFireTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UFireTexture::operator new, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UFireTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UFireTexture::operator new
_TEXT	ENDS
PUBLIC	??1UFireTexture@@UAE@XZ				; UFireTexture::~UFireTexture
PUBLIC	??1?$TArray@VFSpark@@@@QAE@XZ			; TArray<FSpark>::~TArray<FSpark>
PUBLIC	?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z		; TArray<FMipmap>::Remove
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T122721 DD	0ffffffffH
	DD	FLAT:$L122589
	DD	00H
	DD	FLAT:$L122590
	DD	00H
	DD	FLAT:$L122592
	DD	0ffffffffH
	DD	FLAT:$L122633
	DD	0ffffffffH
	DD	FLAT:$L122635
	DD	0ffffffffH
	DD	FLAT:$L122637
	DD	05H
	DD	FLAT:$L122638
	DD	06H
	DD	FLAT:$L122639
	DD	06H
	DD	FLAT:$L122641
	DD	05H
	DD	FLAT:$L122653
	DD	0ffffffffH
	DD	FLAT:$L122665
$T122717 DD	019930520H
	DD	0bH
	DD	FLAT:$T122721
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UFireTexture@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20
$T122631 = -16
$T122651 = -16
$T122663 = -16
__$EHRec$ = -12
??1UFireTexture@@UAE@XZ PROC NEAR			; UFireTexture::~UFireTexture, COMDAT
; _this$ = ecx

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L122720
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 10	 mov	 DWORD PTR _this$[esp+36], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFireTexture@@6B@ ; UFireTexture::`vftable'
  00028	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 1
  00036	ff d5		 call	 ebp
  00038	8d be fc 00 00
	00		 lea	 edi, DWORD PTR [esi+252]
  0003e	89 7c 24 14	 mov	 DWORD PTR $T122631[esp+36], edi
  00042	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00045	85 db		 test	 ebx, ebx
  00047	c6 44 24 20 02	 mov	 BYTE PTR __$EHRec$[esp+44], 2
  0004c	7d 18		 jge	 SHORT $L122618
  0004e	68 fd 01 00 00	 push	 509			; 000001fdH
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
$L122618:
  00066	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  00069	7e 18		 jle	 SHORT $L122619
  0006b	68 fe 01 00 00	 push	 510			; 000001feH
  00070	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
$L122619:
  00083	6a 08		 push	 8
  00085	53		 push	 ebx
  00086	6a 00		 push	 0
  00088	8b cf		 mov	 ecx, edi
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00090	8b 07		 mov	 eax, DWORD PTR [edi]
  00092	33 db		 xor	 ebx, ebx
  00094	3b c3		 cmp	 eax, ebx
  00096	c6 44 24 20 00	 mov	 BYTE PTR __$EHRec$[esp+44], 0
  0009b	74 0e		 je	 SHORT $L122629
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000a3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	50		 push	 eax
  000a8	ff 52 08	 call	 DWORD PTR [edx+8]
$L122629:
  000ab	89 1f		 mov	 DWORD PTR [edi], ebx
  000ad	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  000b0	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000b3	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  000b9	8b ce		 mov	 ecx, esi
  000bb	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 3
  000c3	ff d5		 call	 ebp
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  000ca	89 06		 mov	 DWORD PTR [esi], eax
  000cc	8b ce		 mov	 ecx, esi
  000ce	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 4
  000d6	ff d5		 call	 ebp
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  000de	89 0e		 mov	 DWORD PTR [esi], ecx
  000e0	8b ce		 mov	 ecx, esi
  000e2	c7 44 24 20 07
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 7
  000ea	ff d5		 call	 ebp
  000ec	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  000f2	89 7c 24 14	 mov	 DWORD PTR $T122651[esp+36], edi
  000f6	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000f9	52		 push	 edx
  000fa	53		 push	 ebx
  000fb	8b cf		 mov	 ecx, edi
  000fd	c6 44 24 28 08	 mov	 BYTE PTR __$EHRec$[esp+52], 8
  00102	e8 00 00 00 00	 call	 ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z ; TArray<FMipmap>::Remove
  00107	8b 07		 mov	 eax, DWORD PTR [edi]
  00109	3b c3		 cmp	 eax, ebx
  0010b	c6 44 24 20 06	 mov	 BYTE PTR __$EHRec$[esp+44], 6
  00110	74 0e		 je	 SHORT $L122705
  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00118	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0011a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011c	50		 push	 eax
  0011d	ff 52 08	 call	 DWORD PTR [edx+8]
$L122705:
  00120	89 1f		 mov	 DWORD PTR [edi], ebx
  00122	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00125	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00128	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  0012e	89 7c 24 14	 mov	 DWORD PTR $T122663[esp+36], edi
  00132	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00135	50		 push	 eax
  00136	53		 push	 ebx
  00137	8b cf		 mov	 ecx, edi
  00139	c6 44 24 28 09	 mov	 BYTE PTR __$EHRec$[esp+52], 9
  0013e	e8 00 00 00 00	 call	 ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z ; TArray<FMipmap>::Remove
  00143	8b 07		 mov	 eax, DWORD PTR [edi]
  00145	3b c3		 cmp	 eax, ebx
  00147	c6 44 24 20 05	 mov	 BYTE PTR __$EHRec$[esp+44], 5
  0014c	74 0e		 je	 SHORT $L122710
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00154	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00156	8b 11		 mov	 edx, DWORD PTR [ecx]
  00158	50		 push	 eax
  00159	ff 52 08	 call	 DWORD PTR [edx+8]
$L122710:
  0015c	89 1f		 mov	 DWORD PTR [edi], ebx
  0015e	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00161	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00164	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00169	89 06		 mov	 DWORD PTR [esi], eax
  0016b	8b ce		 mov	 ecx, esi
  0016d	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 10 ; 0000000aH
  00175	ff d5		 call	 ebp
  00177	8b ce		 mov	 ecx, esi
  00179	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+44], -1
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  00187	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5d		 pop	 ebp
  0018e	5b		 pop	 ebx
  0018f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00196	83 c4 14	 add	 esp, 20			; 00000014H
  00199	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L122589:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L122590:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 fc 00 00
	00		 add	 ecx, 252		; 000000fcH
  00011	e9 00 00 00 00	 jmp	 ??1?$TArray@VFSpark@@@@QAE@XZ ; TArray<FSpark>::~TArray<FSpark>
$L122592:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR $T122631[ebp]
  00019	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L122633:
  0001f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L122635:
  00028	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L122637:
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L122638:
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00043	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L122639:
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00051	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L122641:
  00056	8b 4d f0	 mov	 ecx, DWORD PTR $T122651[ebp]
  00059	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L122653:
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T122663[ebp]
  00062	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L122665:
  00068	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L122720:
  00071	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T122717
  00076	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UFireTexture@@UAE@XZ ENDP				; UFireTexture::~UFireTexture
;	COMDAT xdata$x
; File ..\..\Core\Inc\UnTemplate.h
xdata$x	SEGMENT
$T122754 DD	0ffffffffH
	DD	FLAT:$L122727
$T122750 DD	019930520H
	DD	01H
	DD	FLAT:$T122754
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1?$TArray@VFSpark@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$TArray@VFSpark@@@@QAE@XZ PROC NEAR			; TArray<FSpark>::~TArray<FSpark>, COMDAT
; _this$ = ecx

; 371  : 	{

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L122753
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	57		 push	 edi
  0001b	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi

; 372  : 		checkSlow(ArrayNum>=0);
; 373  : 		checkSlow(ArrayMax>=ArrayNum);
; 374  : 		Remove( 0, ArrayNum );

  0001f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00022	85 ff		 test	 edi, edi
  00024	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0002a	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+36], 0
  00032	7d 14		 jge	 SHORT $L122734
  00034	68 fd 01 00 00	 push	 509			; 000001fdH
  00039	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0003e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00043	ff d3		 call	 ebx
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$L122734:
  00048	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  0004b	7e 14		 jle	 SHORT $L122735
  0004d	68 fe 01 00 00	 push	 510			; 000001feH
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005c	ff d3		 call	 ebx
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L122735:
  00061	6a 08		 push	 8
  00063	57		 push	 edi
  00064	6a 00		 push	 0
  00066	8b ce		 mov	 ecx, esi
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z

; 375  : 	}

  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	85 c0		 test	 eax, eax
  00072	c7 44 24 18 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+36], -1
  0007a	74 0e		 je	 SHORT $L122747
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00082	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00084	8b 11		 mov	 edx, DWORD PTR [ecx]
  00086	50		 push	 eax
  00087	ff 52 08	 call	 DWORD PTR [edx+8]
$L122747:
  0008a	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0008e	5f		 pop	 edi
  0008f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00095	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0009c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ac	83 c4 10	 add	 esp, 16			; 00000010H
  000af	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L122727:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L122753:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T122750
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1?$TArray@VFSpark@@@@QAE@XZ ENDP			; TArray<FSpark>::~TArray<FSpark>
; Function compile flags: /Ogty
;	COMDAT ?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z
_TEXT	SEGMENT
_Index$ = 8
_Count$ = 12
?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z PROC NEAR		; TArray<FMipmap>::Remove, COMDAT
; _this$ = ecx

; 507  : 	{

  00000	53		 push	 ebx

; 508  : 		check(Index>=0);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _Index$[esp]
  00005	85 db		 test	 ebx, ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0000f	57		 push	 edi
  00010	8b e9		 mov	 ebp, ecx
  00012	7d 14		 jge	 SHORT $L111858
  00014	68 fc 01 00 00	 push	 508			; 000001fcH
  00019	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08GCAE@Index?$DO?$DN0?$AA@ ; `string'
  00023	ff d6		 call	 esi
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$L111858:

; 509  : 		check(Index<=ArrayNum);

  00028	3b 5d 04	 cmp	 ebx, DWORD PTR [ebp+4]
  0002b	7e 14		 jle	 SHORT $L111859
  0002d	68 fd 01 00 00	 push	 509			; 000001fdH
  00032	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00037	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0003c	ff d6		 call	 esi
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L111859:

; 510  : 		check(Index+Count<=ArrayNum);

  00041	8b 44 24 18	 mov	 eax, DWORD PTR _Count$[esp+12]
  00045	8d 3c 03	 lea	 edi, DWORD PTR [ebx+eax]
  00048	3b 7d 04	 cmp	 edi, DWORD PTR [ebp+4]
  0004b	7e 14		 jle	 SHORT $L111860
  0004d	68 fe 01 00 00	 push	 510			; 000001feH
  00052	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0005c	ff d6		 call	 esi
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L111860:

; 511  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 512  : 			for( INT i=Index; i<Index+Count; i++ )

  00061	3b df		 cmp	 ebx, edi
  00063	7d 1c		 jge	 SHORT $L111865
  00065	8d 34 9b	 lea	 esi, DWORD PTR [ebx+ebx*4]
  00068	c1 e6 03	 shl	 esi, 3
  0006b	2b fb		 sub	 edi, ebx

; 515  : 	}

  0006d	8d 49 00	 npad	 3

; 511  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 512  : 			for( INT i=Index; i<Index+Count; i++ )

$L111863:

; 513  : 				(&(*this)(i))->~T();

  00070	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00073	03 ce		 add	 ecx, esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  0007b	83 c6 28	 add	 esi, 40			; 00000028H
  0007e	4f		 dec	 edi
  0007f	75 ef		 jne	 SHORT $L111863
$L111865:

; 514  : 		FArray::Remove( Index, Count, sizeof(T) );

  00081	8b 4c 24 18	 mov	 ecx, DWORD PTR _Count$[esp+12]
  00085	6a 28		 push	 40			; 00000028H
  00087	51		 push	 ecx
  00088	53		 push	 ebx
  00089	8b cd		 mov	 ecx, ebp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5d		 pop	 ebp
  00094	5b		 pop	 ebx

; 515  : 	}

  00095	c2 08 00	 ret	 8
?Remove@?$TArray@UFMipmap@@@@QAEXHH@Z ENDP		; TArray<FMipmap>::Remove
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
_TEXT	ENDS
;	COMDAT ?InternalConstructor@UFireTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UFireTexture@@SAXPAX@Z PROC NEAR	; UFireTexture::InternalConstructor, COMDAT

; 187  : 	DECLARE_CLASS(UFireTexture,UFractalTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L122783
  00008	e9 00 00 00 00	 jmp	 ??0UFireTexture@@QAE@XZ	; UFireTexture::UFireTexture
$L122783:
  0000d	c3		 ret	 0
?InternalConstructor@UFireTexture@@SAXPAX@Z ENDP	; UFireTexture::InternalConstructor
_TEXT	ENDS
PUBLIC	??0UFireTexture@@QAE@ABV0@@Z			; UFireTexture::UFireTexture
EXTRN	__imp_??0UTexture@@QAE@ABV0@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T122893 DD	0ffffffffH
	DD	FLAT:$L122791
	DD	00H
	DD	FLAT:$L122807
$T122887 DD	019930520H
	DD	02H
	DD	FLAT:$T122893
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UFireTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -16
$T122883 = 8
__$EHRec$ = -12
??0UFireTexture@@QAE@ABV0@@Z PROC NEAR			; UFireTexture::UFireTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L122892
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	55		 push	 ebp
  00018	8b 6c 24 1c	 mov	 ebp, DWORD PTR ___that$[esp+20]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b d9		 mov	 ebx, ecx
  00020	55		 push	 ebp
  00021	89 5c 24 14	 mov	 DWORD PTR _this$[esp+36], ebx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@ABV0@@Z
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00030	89 03		 mov	 DWORD PTR [ebx], eax
  00032	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR [ebp+200]
  00038	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx
  0003e	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR [ebp+204]
  00044	89 93 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], edx
  0004a	8b 85 d0 00 00
	00		 mov	 eax, DWORD PTR [ebp+208]
  00050	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  00056	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+212]
  0005c	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx
  00062	8b 95 d8 00 00
	00		 mov	 edx, DWORD PTR [ebp+216]
  00068	89 93 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], edx
  0006e	8a 85 dc 00 00
	00		 mov	 al, BYTE PTR [ebp+220]
  00074	88 83 dc 00 00
	00		 mov	 BYTE PTR [ebx+220], al
  0007a	8a 8d dd 00 00
	00		 mov	 cl, BYTE PTR [ebp+221]
  00080	88 8b dd 00 00
	00		 mov	 BYTE PTR [ebx+221], cl
  00086	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0008c	8a 95 e0 00 00
	00		 mov	 dl, BYTE PTR [ebp+224]
  00092	88 93 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], dl
  00098	8a 85 e1 00 00
	00		 mov	 al, BYTE PTR [ebp+225]
  0009e	88 83 e1 00 00
	00		 mov	 BYTE PTR [ebx+225], al
  000a4	8b 8d e4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+228]
  000aa	8b 83 e4 00 00
	00		 mov	 eax, DWORD PTR [ebx+228]
  000b0	33 c8		 xor	 ecx, eax
  000b2	83 e1 01	 and	 ecx, 1
  000b5	33 c8		 xor	 ecx, eax
  000b7	89 8b e4 00 00
	00		 mov	 DWORD PTR [ebx+228], ecx
  000bd	8a 95 e8 00 00
	00		 mov	 dl, BYTE PTR [ebp+232]
  000c3	88 93 e8 00 00
	00		 mov	 BYTE PTR [ebx+232], dl
  000c9	8a 85 e9 00 00
	00		 mov	 al, BYTE PTR [ebp+233]
  000cf	88 83 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], al
  000d5	8a 8d ea 00 00
	00		 mov	 cl, BYTE PTR [ebp+234]
  000db	88 8b ea 00 00
	00		 mov	 BYTE PTR [ebx+234], cl
  000e1	8a 95 eb 00 00
	00		 mov	 dl, BYTE PTR [ebp+235]
  000e7	88 93 eb 00 00
	00		 mov	 BYTE PTR [ebx+235], dl
  000ed	8a 85 ec 00 00
	00		 mov	 al, BYTE PTR [ebp+236]
  000f3	88 83 ec 00 00
	00		 mov	 BYTE PTR [ebx+236], al
  000f9	8a 8d ed 00 00
	00		 mov	 cl, BYTE PTR [ebp+237]
  000ff	88 8b ed 00 00
	00		 mov	 BYTE PTR [ebx+237], cl
  00105	8a 95 ee 00 00
	00		 mov	 dl, BYTE PTR [ebp+238]
  0010b	88 93 ee 00 00
	00		 mov	 BYTE PTR [ebx+238], dl
  00111	8a 85 ef 00 00
	00		 mov	 al, BYTE PTR [ebp+239]
  00117	88 83 ef 00 00
	00		 mov	 BYTE PTR [ebx+239], al
  0011d	8a 8d f0 00 00
	00		 mov	 cl, BYTE PTR [ebp+240]
  00123	88 8b f0 00 00
	00		 mov	 BYTE PTR [ebx+240], cl
  00129	8b 95 f4 00 00
	00		 mov	 edx, DWORD PTR [ebp+244]
  0012f	89 93 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], edx
  00135	8b 85 f8 00 00
	00		 mov	 eax, DWORD PTR [ebp+248]
  0013b	89 83 f8 00 00
	00		 mov	 DWORD PTR [ebx+248], eax
  00141	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR [ebp+256]
  00147	8d b3 fc 00 00
	00		 lea	 esi, DWORD PTR [ebx+252]
  0014d	33 ff		 xor	 edi, edi
  0014f	6a 08		 push	 8
  00151	8b ce		 mov	 ecx, esi
  00153	89 7c 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], edi
  00157	89 74 24 28	 mov	 DWORD PTR $T122883[esp+32], esi
  0015b	89 3e		 mov	 DWORD PTR [esi], edi
  0015d	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00160	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  00169	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0016c	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR [ebp+256]
  00172	85 c0		 test	 eax, eax
  00174	c6 44 24 1c 01	 mov	 BYTE PTR __$EHRec$[esp+40], 1
  00179	7e 37		 jle	 SHORT $L122850
  0017b	90 8d 64 24 00	 npad	 5
$L122848:
  00180	6a 08		 push	 8
  00182	6a 01		 push	 1
  00184	8b ce		 mov	 ecx, esi
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Add@FArray@@QAEHHH@Z
  0018c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0018e	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00191	85 c0		 test	 eax, eax
  00193	74 12		 je	 SHORT $L122849
  00195	8b 95 fc 00 00
	00		 mov	 edx, DWORD PTR [ebp+252]
  0019b	8b 0c fa	 mov	 ecx, DWORD PTR [edx+edi*8]
  0019e	89 08		 mov	 DWORD PTR [eax], ecx
  001a0	8b 54 fa 04	 mov	 edx, DWORD PTR [edx+edi*8+4]
  001a4	89 50 04	 mov	 DWORD PTR [eax+4], edx
$L122849:
  001a7	8b 85 00 01 00
	00		 mov	 eax, DWORD PTR [ebp+256]
  001ad	47		 inc	 edi
  001ae	3b f8		 cmp	 edi, eax
  001b0	7c ce		 jl	 SHORT $L122848
$L122850:
  001b2	8b 85 08 01 00
	00		 mov	 eax, DWORD PTR [ebp+264]
  001b8	89 83 08 01 00
	00		 mov	 DWORD PTR [ebx+264], eax
  001be	8d b5 0c 01 00
	00		 lea	 esi, DWORD PTR [ebp+268]
  001c4	8d bb 0c 01 00
	00		 lea	 edi, DWORD PTR [ebx+268]
  001ca	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  001cf	f3 a5		 rep movsd
  001d1	8a 8d 10 05 00
	00		 mov	 cl, BYTE PTR [ebp+1296]
  001d7	88 8b 10 05 00
	00		 mov	 BYTE PTR [ebx+1296], cl
  001dd	8a 95 11 05 00
	00		 mov	 dl, BYTE PTR [ebp+1297]
  001e3	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  001e7	5f		 pop	 edi
  001e8	88 93 11 05 00
	00		 mov	 BYTE PTR [ebx+1297], dl
  001ee	8a 85 12 05 00
	00		 mov	 al, BYTE PTR [ebp+1298]
  001f4	5e		 pop	 esi
  001f5	88 83 12 05 00
	00		 mov	 BYTE PTR [ebx+1298], al
  001fb	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFireTexture@@6B@ ; UFireTexture::`vftable'
  00201	5d		 pop	 ebp
  00202	8b c3		 mov	 eax, ebx
  00204	5b		 pop	 ebx
  00205	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0020c	83 c4 10	 add	 esp, 16			; 00000010H
  0020f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L122791:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L122807:
  00008	8b 4d 04	 mov	 ecx, DWORD PTR $T122883[ebp-4]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L122892:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T122887
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UFireTexture@@QAE@ABV0@@Z ENDP			; UFireTexture::UFireTexture
PUBLIC	??4UFireTexture@@QAEAAV0@ABV0@@Z		; UFireTexture::operator=
EXTRN	__imp_??4UTexture@@QAEAAV0@ABV0@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ??4UFireTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_i$122964 = 8
___that$ = 8
??4UFireTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UFireTexture::operator=, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7c 24 18	 mov	 edi, DWORD PTR ___that$[esp+16]
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UTexture@@QAEAAV0@ABV0@@Z
  00012	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  00018	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  0001e	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  00024	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  0002a	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00030	89 96 d0 00 00
	00		 mov	 DWORD PTR [esi+208], edx
  00036	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  0003c	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  00042	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00048	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  0004e	8a 97 dc 00 00
	00		 mov	 dl, BYTE PTR [edi+220]
  00054	88 96 dc 00 00
	00		 mov	 BYTE PTR [esi+220], dl
  0005a	8a 87 dd 00 00
	00		 mov	 al, BYTE PTR [edi+221]
  00060	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  00066	8a 8f e0 00 00
	00		 mov	 cl, BYTE PTR [edi+224]
  0006c	8b 86 e4 00 00
	00		 mov	 eax, DWORD PTR [esi+228]
  00072	88 8e e0 00 00
	00		 mov	 BYTE PTR [esi+224], cl
  00078	8a 97 e1 00 00
	00		 mov	 dl, BYTE PTR [edi+225]
  0007e	88 96 e1 00 00
	00		 mov	 BYTE PTR [esi+225], dl
  00084	8b 8f e4 00 00
	00		 mov	 ecx, DWORD PTR [edi+228]
  0008a	33 c8		 xor	 ecx, eax
  0008c	83 e1 01	 and	 ecx, 1
  0008f	33 c8		 xor	 ecx, eax
  00091	89 8e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ecx
  00097	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  0009d	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  000a3	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  000a9	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  000af	8a 8f ea 00 00
	00		 mov	 cl, BYTE PTR [edi+234]
  000b5	88 8e ea 00 00
	00		 mov	 BYTE PTR [esi+234], cl
  000bb	8a 97 eb 00 00
	00		 mov	 dl, BYTE PTR [edi+235]
  000c1	88 96 eb 00 00
	00		 mov	 BYTE PTR [esi+235], dl
  000c7	8a 87 ec 00 00
	00		 mov	 al, BYTE PTR [edi+236]
  000cd	88 86 ec 00 00
	00		 mov	 BYTE PTR [esi+236], al
  000d3	8a 8f ed 00 00
	00		 mov	 cl, BYTE PTR [edi+237]
  000d9	88 8e ed 00 00
	00		 mov	 BYTE PTR [esi+237], cl
  000df	8a 97 ee 00 00
	00		 mov	 dl, BYTE PTR [edi+238]
  000e5	88 96 ee 00 00
	00		 mov	 BYTE PTR [esi+238], dl
  000eb	8a 87 ef 00 00
	00		 mov	 al, BYTE PTR [edi+239]
  000f1	88 86 ef 00 00
	00		 mov	 BYTE PTR [esi+239], al
  000f7	8a 8f f0 00 00
	00		 mov	 cl, BYTE PTR [edi+240]
  000fd	88 8e f0 00 00
	00		 mov	 BYTE PTR [esi+240], cl
  00103	8b 97 f4 00 00
	00		 mov	 edx, DWORD PTR [edi+244]
  00109	89 96 f4 00 00
	00		 mov	 DWORD PTR [esi+244], edx
  0010f	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  00115	8d af fc 00 00
	00		 lea	 ebp, DWORD PTR [edi+252]
  0011b	8d 9e fc 00 00
	00		 lea	 ebx, DWORD PTR [esi+252]
  00121	3b dd		 cmp	 ebx, ebp
  00123	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  00129	0f 84 8b 00 00
	00		 je	 $L122967
  0012f	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00132	6a 08		 push	 8
  00134	8b cb		 mov	 ecx, ebx
  00136	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
  0013d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  00146	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  00149	85 c0		 test	 eax, eax
  0014b	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _i$122964[esp+16], 0
  00153	7e 65		 jle	 SHORT $L122967
$L122965:
  00155	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00158	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0015b	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0015e	3b ca		 cmp	 ecx, edx
  00160	89 44 24 10	 mov	 DWORD PTR -4+[esp+20], eax
  00164	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00167	7e 21		 jle	 SHORT $L122958
  00169	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0016c	99		 cdq
  0016d	83 e2 07	 and	 edx, 7
  00170	03 c2		 add	 eax, edx
  00172	c1 f8 03	 sar	 eax, 3
  00175	8d 4c 08 20	 lea	 ecx, DWORD PTR [eax+ecx+32]
  00179	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  0017c	6a 08		 push	 8
  0017e	8b cb		 mov	 ecx, ebx
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  00186	8b 44 24 10	 mov	 eax, DWORD PTR -4+[esp+20]
$L122958:
  0018a	8b 13		 mov	 edx, DWORD PTR [ebx]
  0018c	8d 04 c2	 lea	 eax, DWORD PTR [edx+eax*8]
  0018f	85 c0		 test	 eax, eax
  00191	74 17		 je	 SHORT $L122966
  00193	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  00196	8b 54 24 18	 mov	 edx, DWORD PTR _i$122964[esp+16]
  0019a	8b 14 d1	 mov	 edx, DWORD PTR [ecx+edx*8]
  0019d	89 10		 mov	 DWORD PTR [eax], edx
  0019f	8b 54 24 18	 mov	 edx, DWORD PTR _i$122964[esp+16]
  001a3	8b 4c d1 04	 mov	 ecx, DWORD PTR [ecx+edx*8+4]
  001a7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$L122966:
  001aa	8b 44 24 18	 mov	 eax, DWORD PTR _i$122964[esp+16]
  001ae	8b 4d 04	 mov	 ecx, DWORD PTR [ebp+4]
  001b1	40		 inc	 eax
  001b2	3b c1		 cmp	 eax, ecx
  001b4	89 44 24 18	 mov	 DWORD PTR _i$122964[esp+16], eax
  001b8	7c 9b		 jl	 SHORT $L122965
$L122967:
  001ba	8b 97 08 01 00
	00		 mov	 edx, DWORD PTR [edi+264]
  001c0	8b cf		 mov	 ecx, edi
  001c2	bd f4 fe ff ff	 mov	 ebp, -268		; fffffef4H
  001c7	2b ce		 sub	 ecx, esi
  001c9	89 96 08 01 00
	00		 mov	 DWORD PTR [esi+264], edx
  001cf	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  001d5	2b ee		 sub	 ebp, esi
$L107993:
  001d7	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  001da	88 10		 mov	 BYTE PTR [eax], dl
  001dc	40		 inc	 eax
  001dd	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  001e0	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  001e6	72 ef		 jb	 SHORT $L107993
  001e8	8a 87 10 05 00
	00		 mov	 al, BYTE PTR [edi+1296]
  001ee	88 86 10 05 00
	00		 mov	 BYTE PTR [esi+1296], al
  001f4	8a 8f 11 05 00
	00		 mov	 cl, BYTE PTR [edi+1297]
  001fa	88 8e 11 05 00
	00		 mov	 BYTE PTR [esi+1297], cl
  00200	8a 97 12 05 00
	00		 mov	 dl, BYTE PTR [edi+1298]
  00206	5f		 pop	 edi
  00207	88 96 12 05 00
	00		 mov	 BYTE PTR [esi+1298], dl
  0020d	8b c6		 mov	 eax, esi
  0020f	5e		 pop	 esi
  00210	5d		 pop	 ebp
  00211	5b		 pop	 ebx
  00212	59		 pop	 ecx
  00213	c2 04 00	 ret	 4
??4UFireTexture@@QAEAAV0@ABV0@@Z ENDP			; UFireTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUFireTexture@@UAEPAXI@Z			; UFireTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUFireTexture@@UAEPAXI@Z PROC NEAR			; UFireTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UFireTexture@@UAE@XZ	; UFireTexture::~UFireTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L122997
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L122997:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUFireTexture@@UAEPAXI@Z ENDP			; UFireTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUFireTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUFireTexture@@UAEPAXI@Z PROC NEAR			; UFireTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L108001
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UFireTexture@@UAE@XZ ; UFireTexture::~UFireTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 14 05 00 00	 push	 1300			; 00000514H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L123003
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L123003:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L108001:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UFireTexture@@UAE@XZ	; UFireTexture::~UFireTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L123006
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L123006:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUFireTexture@@UAEPAXI@Z ENDP			; UFireTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4FDrop@@QAEAAU0@ABU0@@Z			; FDrop::operator=
; Function compile flags: /Ogty
;	COMDAT ??4FDrop@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
??4FDrop@@QAEAAU0@ABU0@@Z PROC NEAR			; FDrop::operator=, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	c2 04 00	 ret	 4
??4FDrop@@QAEAAU0@ABU0@@Z ENDP				; FDrop::operator=
_TEXT	ENDS
PUBLIC	?StaticClass@UWaterTexture@@SAPAVUClass@@XZ	; UWaterTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UWaterTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UWaterTexture@@SAPAVUClass@@XZ PROC NEAR	; UWaterTexture::StaticClass, COMDAT

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UWaterTexture@@SAPAVUClass@@XZ ENDP	; UWaterTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UWaterTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UWaterTexture::operator new, COMDAT

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaterTexture@@0VUClass@@A ; UWaterTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UWaterTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UWaterTexture::operator new
_TEXT	ENDS
PUBLIC	??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z	; UWaterTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UWaterTexture::operator new, COMDAT

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UWaterTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UWaterTexture::operator new
_TEXT	ENDS
PUBLIC	??1UWaterTexture@@UAE@XZ			; UWaterTexture::~UWaterTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T123260 DD	0ffffffffH
	DD	FLAT:$L123025
	DD	0ffffffffH
	DD	FLAT:$L123027
	DD	0ffffffffH
	DD	FLAT:$L123029
	DD	0ffffffffH
	DD	FLAT:$L123031
	DD	03H
	DD	FLAT:$L123032
	DD	04H
	DD	FLAT:$L123033
	DD	04H
	DD	FLAT:$L123035
	DD	03H
	DD	FLAT:$L123083
	DD	0ffffffffH
	DD	FLAT:$L123124
$T123251 DD	019930520H
	DD	09H
	DD	FLAT:$T123260
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UWaterTexture@@UAE@XZ
_TEXT	SEGMENT
$T123081 = -16
$T123122 = -16
__$EHRec$ = -12
_this$ = -20
??1UWaterTexture@@UAE@XZ PROC NEAR			; UWaterTexture::~UWaterTexture, COMDAT
; _this$ = ecx

; 305  : 	DECLARE_ABSTRACT_CLASS(UWaterTexture,UFractalTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L123259
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0004d	89 06		 mov	 DWORD PTR [esi], eax
  0004f	8b ce		 mov	 ecx, esi
  00051	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00059	ff d7		 call	 edi
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00061	89 0e		 mov	 DWORD PTR [esi], ecx
  00063	8b ce		 mov	 ecx, esi
  00065	c7 44 24 24 05
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 5
  0006d	ff d7		 call	 edi
  0006f	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00075	89 7c 24 18	 mov	 DWORD PTR $T123081[esp+40], edi
  00079	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0007c	3b dd		 cmp	 ebx, ebp
  0007e	c6 44 24 24 06	 mov	 BYTE PTR __$EHRec$[esp+48], 6
  00083	7d 18		 jge	 SHORT $L123214
  00085	68 fd 01 00 00	 push	 509			; 000001fdH
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123214:
  0009d	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000a0	7e 18		 jle	 SHORT $L123216
  000a2	68 fe 01 00 00	 push	 510			; 000001feH
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123216:
  000ba	3b dd		 cmp	 ebx, ebp
  000bc	7e 1f		 jle	 SHORT $L123224
  000be	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L123221:
  000c2	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c4	6a 00		 push	 0
  000c6	03 cd		 add	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000cd	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000d1	83 c5 28	 add	 ebp, 40			; 00000028H
  000d4	48		 dec	 eax
  000d5	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000d9	75 e7		 jne	 SHORT $L123221
  000db	33 ed		 xor	 ebp, ebp
$L123224:
  000dd	6a 28		 push	 40			; 00000028H
  000df	53		 push	 ebx
  000e0	55		 push	 ebp
  000e1	8b cf		 mov	 ecx, edi
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	3b c5		 cmp	 eax, ebp
  000ed	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  000f2	74 0e		 je	 SHORT $L123228
  000f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000fa	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fe	50		 push	 eax
  000ff	ff 52 08	 call	 DWORD PTR [edx+8]
$L123228:
  00102	89 2f		 mov	 DWORD PTR [edi], ebp
  00104	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  00107	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  0010a	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  00110	89 7c 24 18	 mov	 DWORD PTR $T123122[esp+40], edi
  00114	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00117	85 ed		 test	 ebp, ebp
  00119	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  0011e	7d 18		 jge	 SHORT $L123233
  00120	68 fd 01 00 00	 push	 509			; 000001fdH
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0012a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123233:
  00138	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  0013b	7e 18		 jle	 SHORT $L123234
  0013d	68 fe 01 00 00	 push	 510			; 000001feH
  00142	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00147	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123234:
  00155	85 ed		 test	 ebp, ebp
  00157	7e 20		 jle	 SHORT $L123239
  00159	33 db		 xor	 ebx, ebx
  0015b	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015f	90		 npad	 1
$L123237:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L123237
$L123239:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00198	89 06		 mov	 DWORD PTR [esi], eax
  0019a	8b ce		 mov	 ecx, esi
  0019c	c7 44 24 24 08
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 8
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001aa	8b ce		 mov	 ecx, esi
  001ac	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001ba	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5d		 pop	 ebp
  001c1	5b		 pop	 ebx
  001c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c9	83 c4 18	 add	 esp, 24			; 00000018H
  001cc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L123025:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L123027:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L123029:
  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L123031:
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L123032:
  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0002c	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L123033:
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0003a	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L123035:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR $T123081[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L123083:
  00048	8b 4d f0	 mov	 ecx, DWORD PTR $T123122[ebp]
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L123124:
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L123259:
  0005a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T123251
  0005f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UWaterTexture@@UAE@XZ ENDP				; UWaterTexture::~UWaterTexture
PUBLIC	??0UWaterTexture@@QAE@ABV0@@Z			; UWaterTexture::UWaterTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
$T123300 DD	0ffffffffH
	DD	FLAT:$L123272
	DD	00H
	DD	FLAT:$L123273
$T123298 DD	019930520H
	DD	02H
	DD	FLAT:$T123300
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UWaterTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0UWaterTexture@@QAE@ABV0@@Z PROC NEAR			; UWaterTexture::UWaterTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L123299
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	55		 push	 ebp
  00018	8b 6c 24 1c	 mov	 ebp, DWORD PTR ___that$[esp+20]
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b d9		 mov	 ebx, ecx
  00020	55		 push	 ebp
  00021	89 5c 24 14	 mov	 DWORD PTR _this$[esp+36], ebx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UObject@@QAE@ABV0@@Z
  0002b	8a 45 28	 mov	 al, BYTE PTR [ebp+40]
  0002e	88 43 28	 mov	 BYTE PTR [ebx+40], al
  00031	8b 4d 2c	 mov	 ecx, DWORD PTR [ebp+44]
  00034	89 4b 2c	 mov	 DWORD PTR [ebx+44], ecx
  00037	8a 55 30	 mov	 dl, BYTE PTR [ebp+48]
  0003a	88 53 30	 mov	 BYTE PTR [ebx+48], dl
  0003d	8a 45 31	 mov	 al, BYTE PTR [ebp+49]
  00040	88 43 31	 mov	 BYTE PTR [ebx+49], al
  00043	8b 4d 34	 mov	 ecx, DWORD PTR [ebp+52]
  00046	89 4b 34	 mov	 DWORD PTR [ebx+52], ecx
  00049	8b 55 38	 mov	 edx, DWORD PTR [ebp+56]
  0004c	89 53 38	 mov	 DWORD PTR [ebx+56], edx
  0004f	8b 45 3c	 mov	 eax, DWORD PTR [ebp+60]
  00052	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  00055	8b 4d 40	 mov	 ecx, DWORD PTR [ebp+64]
  00058	89 4b 40	 mov	 DWORD PTR [ebx+64], ecx
  0005b	8b 55 44	 mov	 edx, DWORD PTR [ebp+68]
  0005e	89 53 44	 mov	 DWORD PTR [ebx+68], edx
  00061	8b 45 48	 mov	 eax, DWORD PTR [ebp+72]
  00064	89 43 48	 mov	 DWORD PTR [ebx+72], eax
  00067	8b 4d 4c	 mov	 ecx, DWORD PTR [ebp+76]
  0006a	89 4b 4c	 mov	 DWORD PTR [ebx+76], ecx
  0006d	8b 55 50	 mov	 edx, DWORD PTR [ebp+80]
  00070	89 53 50	 mov	 DWORD PTR [ebx+80], edx
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00078	89 03		 mov	 DWORD PTR [ebx], eax
  0007a	8b 4d 54	 mov	 ecx, DWORD PTR [ebp+84]
  0007d	89 4b 54	 mov	 DWORD PTR [ebx+84], ecx
  00080	8b 55 58	 mov	 edx, DWORD PTR [ebp+88]
  00083	89 53 58	 mov	 DWORD PTR [ebx+88], edx
  00086	8b 45 5c	 mov	 eax, DWORD PTR [ebp+92]
  00089	89 43 5c	 mov	 DWORD PTR [ebx+92], eax
  0008c	8b 4d 60	 mov	 ecx, DWORD PTR [ebp+96]
  0008f	89 4b 60	 mov	 DWORD PTR [ebx+96], ecx
  00092	8b 55 64	 mov	 edx, DWORD PTR [ebp+100]
  00095	89 53 64	 mov	 DWORD PTR [ebx+100], edx
  00098	8b 45 68	 mov	 eax, DWORD PTR [ebp+104]
  0009b	89 43 68	 mov	 DWORD PTR [ebx+104], eax
  0009e	8b 4d 6c	 mov	 ecx, DWORD PTR [ebp+108]
  000a1	89 4b 6c	 mov	 DWORD PTR [ebx+108], ecx
  000a4	8b 55 70	 mov	 edx, DWORD PTR [ebp+112]
  000a7	89 53 70	 mov	 DWORD PTR [ebx+112], edx
  000aa	8b 45 74	 mov	 eax, DWORD PTR [ebp+116]
  000ad	89 43 74	 mov	 DWORD PTR [ebx+116], eax
  000b0	8b 4d 78	 mov	 ecx, DWORD PTR [ebp+120]
  000b3	89 4b 78	 mov	 DWORD PTR [ebx+120], ecx
  000b6	8b 55 7c	 mov	 edx, DWORD PTR [ebp+124]
  000b9	89 53 7c	 mov	 DWORD PTR [ebx+124], edx
  000bc	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR [ebp+128]
  000c2	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax
  000c8	8b 8d 84 00 00
	00		 mov	 ecx, DWORD PTR [ebp+132]
  000ce	89 8b 84 00 00
	00		 mov	 DWORD PTR [ebx+132], ecx
  000d4	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [ebx+136]
  000da	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR [ebp+136]
  000e0	33 c1		 xor	 eax, ecx
  000e2	83 e0 01	 and	 eax, 1
  000e5	33 c1		 xor	 eax, ecx
  000e7	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  000ed	8b 8d 88 00 00
	00		 mov	 ecx, DWORD PTR [ebp+136]
  000f3	33 c8		 xor	 ecx, eax
  000f5	83 e1 02	 and	 ecx, 2
  000f8	33 c8		 xor	 ecx, eax
  000fa	89 8b 88 00 00
	00		 mov	 DWORD PTR [ebx+136], ecx
  00100	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR [ebp+136]
  00106	33 c1		 xor	 eax, ecx
  00108	83 e0 04	 and	 eax, 4
  0010b	33 c1		 xor	 eax, ecx
  0010d	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  00113	8b 8d 88 00 00
	00		 mov	 ecx, DWORD PTR [ebp+136]
  00119	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+40], 0
  00121	33 c8		 xor	 ecx, eax
  00123	83 e1 08	 and	 ecx, 8
  00126	33 c8		 xor	 ecx, eax
  00128	89 8b 88 00 00
	00		 mov	 DWORD PTR [ebx+136], ecx
  0012e	8b 85 88 00 00
	00		 mov	 eax, DWORD PTR [ebp+136]
  00134	33 c1		 xor	 eax, ecx
  00136	83 e0 10	 and	 eax, 16			; 00000010H
  00139	33 c1		 xor	 eax, ecx
  0013b	89 83 88 00 00
	00		 mov	 DWORD PTR [ebx+136], eax
  00141	8b 95 88 00 00
	00		 mov	 edx, DWORD PTR [ebp+136]
  00147	33 d0		 xor	 edx, eax
  00149	83 e2 20	 and	 edx, 32			; 00000020H
  0014c	33 d0		 xor	 edx, eax
  0014e	89 93 88 00 00
	00		 mov	 DWORD PTR [ebx+136], edx
  00154	8a 85 8c 00 00
	00		 mov	 al, BYTE PTR [ebp+140]
  0015a	88 83 8c 00 00
	00		 mov	 BYTE PTR [ebx+140], al
  00160	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR [ebp+144]
  00166	89 8b 90 00 00
	00		 mov	 DWORD PTR [ebx+144], ecx
  0016c	8b 95 94 00 00
	00		 mov	 edx, DWORD PTR [ebp+148]
  00172	89 93 94 00 00
	00		 mov	 DWORD PTR [ebx+148], edx
  00178	8a 85 98 00 00
	00		 mov	 al, BYTE PTR [ebp+152]
  0017e	88 83 98 00 00
	00		 mov	 BYTE PTR [ebx+152], al
  00184	8a 8d 99 00 00
	00		 mov	 cl, BYTE PTR [ebp+153]
  0018a	88 8b 99 00 00
	00		 mov	 BYTE PTR [ebx+153], cl
  00190	8b 95 9c 00 00
	00		 mov	 edx, DWORD PTR [ebp+156]
  00196	89 93 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], edx
  0019c	8b 85 a0 00 00
	00		 mov	 eax, DWORD PTR [ebp+160]
  001a2	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax
  001a8	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+164]
  001ae	8d 95 a8 00 00
	00		 lea	 edx, DWORD PTR [ebp+168]
  001b4	89 8b a4 00 00
	00		 mov	 DWORD PTR [ebx+164], ecx
  001ba	52		 push	 edx
  001bb	8d 8b a8 00 00
	00		 lea	 ecx, DWORD PTR [ebx+168]
  001c1	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001c6	8d 85 b4 00 00
	00		 lea	 eax, DWORD PTR [ebp+180]
  001cc	50		 push	 eax
  001cd	8d 8b b4 00 00
	00		 lea	 ecx, DWORD PTR [ebx+180]
  001d3	c6 44 24 20 01	 mov	 BYTE PTR __$EHRec$[esp+44], 1
  001d8	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001dd	8a 8d c0 00 00
	00		 mov	 cl, BYTE PTR [ebp+192]
  001e3	88 8b c0 00 00
	00		 mov	 BYTE PTR [ebx+192], cl
  001e9	8b 95 c4 00 00
	00		 mov	 edx, DWORD PTR [ebp+196]
  001ef	89 93 c4 00 00
	00		 mov	 DWORD PTR [ebx+196], edx
  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UTexture@@6B@
  001fa	89 03		 mov	 DWORD PTR [ebx], eax
  001fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00202	89 0b		 mov	 DWORD PTR [ebx], ecx
  00204	8b 95 c8 00 00
	00		 mov	 edx, DWORD PTR [ebp+200]
  0020a	89 93 c8 00 00
	00		 mov	 DWORD PTR [ebx+200], edx
  00210	8b 85 cc 00 00
	00		 mov	 eax, DWORD PTR [ebp+204]
  00216	89 83 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], eax
  0021c	8b 8d d0 00 00
	00		 mov	 ecx, DWORD PTR [ebp+208]
  00222	89 8b d0 00 00
	00		 mov	 DWORD PTR [ebx+208], ecx
  00228	8b 95 d4 00 00
	00		 mov	 edx, DWORD PTR [ebp+212]
  0022e	89 93 d4 00 00
	00		 mov	 DWORD PTR [ebx+212], edx
  00234	8b 85 d8 00 00
	00		 mov	 eax, DWORD PTR [ebp+216]
  0023a	89 83 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], eax
  00240	8a 8d dc 00 00
	00		 mov	 cl, BYTE PTR [ebp+220]
  00246	88 8b dc 00 00
	00		 mov	 BYTE PTR [ebx+220], cl
  0024c	8a 95 dd 00 00
	00		 mov	 dl, BYTE PTR [ebp+221]
  00252	88 93 dd 00 00
	00		 mov	 BYTE PTR [ebx+221], dl
  00258	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0025e	8a 85 e0 00 00
	00		 mov	 al, BYTE PTR [ebp+224]
  00264	88 83 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], al
  0026a	8a 8d e1 00 00
	00		 mov	 cl, BYTE PTR [ebp+225]
  00270	88 8b e1 00 00
	00		 mov	 BYTE PTR [ebx+225], cl
  00276	8a 95 e2 00 00
	00		 mov	 dl, BYTE PTR [ebp+226]
  0027c	88 93 e2 00 00
	00		 mov	 BYTE PTR [ebx+226], dl
  00282	8a 85 e3 00 00
	00		 mov	 al, BYTE PTR [ebp+227]
  00288	88 83 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], al
  0028e	8a 8d e4 00 00
	00		 mov	 cl, BYTE PTR [ebp+228]
  00294	88 8b e4 00 00
	00		 mov	 BYTE PTR [ebx+228], cl
  0029a	8a 95 e5 00 00
	00		 mov	 dl, BYTE PTR [ebp+229]
  002a0	88 93 e5 00 00
	00		 mov	 BYTE PTR [ebx+229], dl
  002a6	8a 85 e6 00 00
	00		 mov	 al, BYTE PTR [ebp+230]
  002ac	88 83 e6 00 00
	00		 mov	 BYTE PTR [ebx+230], al
  002b2	8a 8d e7 00 00
	00		 mov	 cl, BYTE PTR [ebp+231]
  002b8	88 8b e7 00 00
	00		 mov	 BYTE PTR [ebx+231], cl
  002be	8a 95 e8 00 00
	00		 mov	 dl, BYTE PTR [ebp+232]
  002c4	88 93 e8 00 00
	00		 mov	 BYTE PTR [ebx+232], dl
  002ca	8a 85 e9 00 00
	00		 mov	 al, BYTE PTR [ebp+233]
  002d0	88 83 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], al
  002d6	8b 8d ec 00 00
	00		 mov	 ecx, DWORD PTR [ebp+236]
  002dc	89 8b ec 00 00
	00		 mov	 DWORD PTR [ebx+236], ecx
  002e2	8d b5 f0 00 00
	00		 lea	 esi, DWORD PTR [ebp+240]
  002e8	8d bb f0 00 00
	00		 lea	 edi, DWORD PTR [ebx+240]
  002ee	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002f3	f3 a5		 rep movsd
  002f5	8b 95 f0 08 00
	00		 mov	 edx, DWORD PTR [ebp+2288]
  002fb	89 93 f0 08 00
	00		 mov	 DWORD PTR [ebx+2288], edx
  00301	8d b5 f4 08 00
	00		 lea	 esi, DWORD PTR [ebp+2292]
  00307	8d bb f4 08 00
	00		 lea	 edi, DWORD PTR [ebx+2292]
  0030d	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00312	f3 a5		 rep movsd
  00314	8d b5 f8 0c 00
	00		 lea	 esi, DWORD PTR [ebp+3320]
  0031a	8d bb f8 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3320]
  00320	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00325	f3 a5		 rep movsd
  00327	8a 85 f8 12 00
	00		 mov	 al, BYTE PTR [ebp+4856]
  0032d	88 83 f8 12 00
	00		 mov	 BYTE PTR [ebx+4856], al
  00333	8b 8d fc 12 00
	00		 mov	 ecx, DWORD PTR [ebp+4860]
  00339	5f		 pop	 edi
  0033a	89 8b fc 12 00
	00		 mov	 DWORD PTR [ebx+4860], ecx
  00340	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  00344	5e		 pop	 esi
  00345	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  0034b	5d		 pop	 ebp
  0034c	8b c3		 mov	 eax, ebx
  0034e	5b		 pop	 ebx
  0034f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00356	83 c4 10	 add	 esp, 16			; 00000010H
  00359	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L123272:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L123273:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00012	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L123299:
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T123298
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UWaterTexture@@QAE@ABV0@@Z ENDP			; UWaterTexture::UWaterTexture
PUBLIC	??4UWaterTexture@@QAEAAV0@ABV0@@Z		; UWaterTexture::operator=
PUBLIC	?Empty@?$TArray@UFMipmap@@@@QAEXH@Z		; TArray<FMipmap>::Empty
; Function compile flags: /Ogty
;	COMDAT ??4UWaterTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_i$123380 = -4
___that$ = 8
??4UWaterTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UWaterTexture::operator=, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7c 24 18	 mov	 edi, DWORD PTR ___that$[esp+16]
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UObject@@QAEAAV0@ABV0@@Z
  00012	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  00015	88 46 28	 mov	 BYTE PTR [esi+40], al
  00018	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001b	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0001e	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00021	88 56 30	 mov	 BYTE PTR [esi+48], dl
  00024	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  00027	88 46 31	 mov	 BYTE PTR [esi+49], al
  0002a	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0002d	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00030	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00033	89 56 38	 mov	 DWORD PTR [esi+56], edx
  00036	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00039	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0003c	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  0003f	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00042	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00045	89 56 44	 mov	 DWORD PTR [esi+68], edx
  00048	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0004b	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0004e	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00051	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00054	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  00057	89 56 50	 mov	 DWORD PTR [esi+80], edx
  0005a	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0005d	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00060	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00063	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00066	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00069	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0006c	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0006f	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00072	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  00075	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  00078	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  0007b	89 56 68	 mov	 DWORD PTR [esi+104], edx
  0007e	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00081	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00084	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00087	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  0008a	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  0008d	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00090	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  00093	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00096	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00099	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  0009c	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000a2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000a8	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  000ae	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  000b4	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000ba	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c0	33 c1		 xor	 eax, ecx
  000c2	83 e0 01	 and	 eax, 1
  000c5	33 c1		 xor	 eax, ecx
  000c7	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000cd	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d3	33 c8		 xor	 ecx, eax
  000d5	83 e1 02	 and	 ecx, 2
  000d8	33 c8		 xor	 ecx, eax
  000da	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e0	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000e6	33 c1		 xor	 eax, ecx
  000e8	83 e0 04	 and	 eax, 4
  000eb	33 c1		 xor	 eax, ecx
  000ed	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000f3	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f9	33 c8		 xor	 ecx, eax
  000fb	83 e1 08	 and	 ecx, 8
  000fe	33 c8		 xor	 ecx, eax
  00100	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00106	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0010c	33 c1		 xor	 eax, ecx
  0010e	83 e0 10	 and	 eax, 16			; 00000010H
  00111	33 c1		 xor	 eax, ecx
  00113	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00119	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0011f	33 c8		 xor	 ecx, eax
  00121	83 e1 20	 and	 ecx, 32			; 00000020H
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00132	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  00138	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0013e	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00144	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  0014a	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00150	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  00156	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  0015c	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00162	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  00168	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  0016e	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  00174	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  0017a	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00180	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  00186	8d 9f a8 00 00
	00		 lea	 ebx, DWORD PTR [edi+168]
  0018c	8d ae a8 00 00
	00		 lea	 ebp, DWORD PTR [esi+168]
  00192	3b eb		 cmp	 ebp, ebx
  00194	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  0019a	74 55		 je	 SHORT $L123383
  0019c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0019f	51		 push	 ecx
  001a0	8b cd		 mov	 ecx, ebp
  001a2	e8 00 00 00 00	 call	 ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z ; TArray<FMipmap>::Empty
  001a7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001aa	33 c0		 xor	 eax, eax
  001ac	3b c8		 cmp	 ecx, eax
  001ae	89 44 24 10	 mov	 DWORD PTR _i$123380[esp+20], eax
  001b2	7e 3d		 jle	 SHORT $L123383
  001b4	89 44 24 18	 mov	 DWORD PTR 8+[esp+16], eax
$L123381:
  001b8	55		 push	 ebp
  001b9	6a 28		 push	 40			; 00000028H
  001bb	e8 00 00 00 00	 call	 ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ; operator new
  001c0	83 c4 08	 add	 esp, 8
  001c3	85 c0		 test	 eax, eax
  001c5	74 0f		 je	 SHORT $L123382
  001c7	8b 13		 mov	 edx, DWORD PTR [ebx]
  001c9	03 54 24 18	 add	 edx, DWORD PTR 8+[esp+16]
  001cd	52		 push	 edx
  001ce	8b c8		 mov	 ecx, eax
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L123382:
  001d6	8b 44 24 10	 mov	 eax, DWORD PTR _i$123380[esp+20]
  001da	8b 54 24 18	 mov	 edx, DWORD PTR 8+[esp+16]
  001de	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001e1	40		 inc	 eax
  001e2	83 c2 28	 add	 edx, 40			; 00000028H
  001e5	3b c1		 cmp	 eax, ecx
  001e7	89 44 24 10	 mov	 DWORD PTR _i$123380[esp+20], eax
  001eb	89 54 24 18	 mov	 DWORD PTR 8+[esp+16], edx
  001ef	7c c7		 jl	 SHORT $L123381
$L123383:
  001f1	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001f7	50		 push	 eax
  001f8	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001fe	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00203	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  00209	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  0020f	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  00215	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  0021b	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  00221	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00227	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  0022d	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  00233	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00239	89 96 d0 00 00
	00		 mov	 DWORD PTR [esi+208], edx
  0023f	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00245	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  0024b	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00251	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  00257	8a 97 dc 00 00
	00		 mov	 dl, BYTE PTR [edi+220]
  0025d	88 96 dc 00 00
	00		 mov	 BYTE PTR [esi+220], dl
  00263	8a 87 dd 00 00
	00		 mov	 al, BYTE PTR [edi+221]
  00269	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0026f	8a 8f e0 00 00
	00		 mov	 cl, BYTE PTR [edi+224]
  00275	88 8e e0 00 00
	00		 mov	 BYTE PTR [esi+224], cl
  0027b	8a 97 e1 00 00
	00		 mov	 dl, BYTE PTR [edi+225]
  00281	88 96 e1 00 00
	00		 mov	 BYTE PTR [esi+225], dl
  00287	8a 87 e2 00 00
	00		 mov	 al, BYTE PTR [edi+226]
  0028d	88 86 e2 00 00
	00		 mov	 BYTE PTR [esi+226], al
  00293	8a 8f e3 00 00
	00		 mov	 cl, BYTE PTR [edi+227]
  00299	88 8e e3 00 00
	00		 mov	 BYTE PTR [esi+227], cl
  0029f	8a 97 e4 00 00
	00		 mov	 dl, BYTE PTR [edi+228]
  002a5	88 96 e4 00 00
	00		 mov	 BYTE PTR [esi+228], dl
  002ab	8a 87 e5 00 00
	00		 mov	 al, BYTE PTR [edi+229]
  002b1	88 86 e5 00 00
	00		 mov	 BYTE PTR [esi+229], al
  002b7	8a 8f e6 00 00
	00		 mov	 cl, BYTE PTR [edi+230]
  002bd	88 8e e6 00 00
	00		 mov	 BYTE PTR [esi+230], cl
  002c3	8a 97 e7 00 00
	00		 mov	 dl, BYTE PTR [edi+231]
  002c9	88 96 e7 00 00
	00		 mov	 BYTE PTR [esi+231], dl
  002cf	8a 87 e8 00 00
	00		 mov	 al, BYTE PTR [edi+232]
  002d5	88 86 e8 00 00
	00		 mov	 BYTE PTR [esi+232], al
  002db	8a 8f e9 00 00
	00		 mov	 cl, BYTE PTR [edi+233]
  002e1	88 8e e9 00 00
	00		 mov	 BYTE PTR [esi+233], cl
  002e7	8b 97 ec 00 00
	00		 mov	 edx, DWORD PTR [edi+236]
  002ed	8b cf		 mov	 ecx, edi
  002ef	89 96 ec 00 00
	00		 mov	 DWORD PTR [esi+236], edx
  002f5	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  002fb	2b ce		 sub	 ecx, esi
  002fd	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$L108149:
  00302	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  00305	89 18		 mov	 DWORD PTR [eax], ebx
  00307	8b 5c 01 04	 mov	 ebx, DWORD PTR [ecx+eax+4]
  0030b	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0030e	83 c0 08	 add	 eax, 8
  00311	4a		 dec	 edx
  00312	75 ee		 jne	 SHORT $L108149
  00314	8b 87 f0 08 00
	00		 mov	 eax, DWORD PTR [edi+2288]
  0031a	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  0031f	89 86 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], eax
  00325	8d 86 f4 08 00
	00		 lea	 eax, DWORD PTR [esi+2292]
  0032b	2b ee		 sub	 ebp, esi
  0032d	8d 49 00	 npad	 3
$L108153:
  00330	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00333	88 10		 mov	 BYTE PTR [eax], dl
  00335	40		 inc	 eax
  00336	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  00339	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  0033f	72 ef		 jb	 SHORT $L108153
  00341	bd 08 f3 ff ff	 mov	 ebp, -3320		; fffff308H
  00346	8d 86 f8 0c 00
	00		 lea	 eax, DWORD PTR [esi+3320]
  0034c	2b ee		 sub	 ebp, esi
  0034e	8b ff		 npad	 2
$L108157:
  00350	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00353	88 10		 mov	 BYTE PTR [eax], dl
  00355	40		 inc	 eax
  00356	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  00359	81 fa 00 06 00
	00		 cmp	 edx, 1536		; 00000600H
  0035f	72 ef		 jb	 SHORT $L108157
  00361	8a 87 f8 12 00
	00		 mov	 al, BYTE PTR [edi+4856]
  00367	88 86 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], al
  0036d	8b 8f fc 12 00
	00		 mov	 ecx, DWORD PTR [edi+4860]
  00373	5f		 pop	 edi
  00374	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
  0037a	8b c6		 mov	 eax, esi
  0037c	5e		 pop	 esi
  0037d	5d		 pop	 ebp
  0037e	5b		 pop	 ebx
  0037f	59		 pop	 ecx
  00380	c2 04 00	 ret	 4
??4UWaterTexture@@QAEAAV0@ABV0@@Z ENDP			; UWaterTexture::operator=
; Function compile flags: /Ogty
; File ..\..\Core\Inc\UnTemplate.h
_TEXT	ENDS
;	COMDAT ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z
_TEXT	SEGMENT
_Slack$ = 8
?Empty@?$TArray@UFMipmap@@@@QAEXH@Z PROC NEAR		; TArray<FMipmap>::Empty, COMDAT
; _this$ = ecx

; 517  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 518  : 		if( TTypeInfo<T>::NeedsDestructor() )
; 519  : 			for( INT i=0; i<ArrayNum; i++ )

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	57		 push	 edi
  00007	33 ff		 xor	 edi, edi
  00009	85 c0		 test	 eax, eax
  0000b	7e 19		 jle	 SHORT $L111873
  0000d	53		 push	 ebx
  0000e	33 db		 xor	 ebx, ebx
$L111871:

; 520  : 				(&(*this)(i))->~T();

  00010	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00012	03 cb		 add	 ecx, ebx
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FMipmap@@QAE@XZ
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	47		 inc	 edi
  0001e	83 c3 28	 add	 ebx, 40			; 00000028H
  00021	3b f8		 cmp	 edi, eax
  00023	7c eb		 jl	 SHORT $L111871
  00025	5b		 pop	 ebx
$L111873:

; 521  : 		FArray::Empty( sizeof(T), Slack );

  00026	8b 44 24 0c	 mov	 eax, DWORD PTR _Slack$[esp+4]
  0002a	6a 28		 push	 40			; 00000028H
  0002c	8b ce		 mov	 ecx, esi
  0002e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00035	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Realloc@FArray@@IAEXH@Z
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 522  : 	}

  00040	c2 04 00	 ret	 4
?Empty@?$TArray@UFMipmap@@@@QAEXH@Z ENDP		; TArray<FMipmap>::Empty
_TEXT	ENDS
PUBLIC	??_GUWaterTexture@@UAEPAXI@Z			; UWaterTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUWaterTexture@@UAEPAXI@Z PROC NEAR			; UWaterTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L123425
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L123425:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUWaterTexture@@UAEPAXI@Z ENDP			; UWaterTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUWaterTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUWaterTexture@@UAEPAXI@Z PROC NEAR			; UWaterTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L108165
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 00 13 00 00	 push	 4864			; 00001300H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L123431
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L123431:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L108165:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L123433
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L123433:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUWaterTexture@@UAEPAXI@Z ENDP			; UWaterTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?StaticClass@UWaveTexture@@SAPAVUClass@@XZ	; UWaveTexture::StaticClass
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
;	COMDAT ?StaticClass@UWaveTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UWaveTexture@@SAPAVUClass@@XZ PROC NEAR	; UWaveTexture::StaticClass, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UWaveTexture@@SAPAVUClass@@XZ ENDP		; UWaveTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UWaveTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR ; UWaveTexture::operator new, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWaveTexture@@0VUClass@@A ; UWaveTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UWaveTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UWaveTexture::operator new
_TEXT	ENDS
PUBLIC	??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z	; UWaveTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UWaveTexture::operator new, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UWaveTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UWaveTexture::operator new
_TEXT	ENDS
PUBLIC	??1UWaveTexture@@UAE@XZ				; UWaveTexture::~UWaveTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T123713 DD	0ffffffffH
	DD	FLAT:$L123450
	DD	0ffffffffH
	DD	FLAT:$L123452
	DD	0ffffffffH
	DD	FLAT:$L123454
	DD	0ffffffffH
	DD	FLAT:$L123456
	DD	0ffffffffH
	DD	FLAT:$L123458
	DD	04H
	DD	FLAT:$L123459
	DD	05H
	DD	FLAT:$L123460
	DD	05H
	DD	FLAT:$L123462
	DD	04H
	DD	FLAT:$L123503
	DD	0ffffffffH
	DD	FLAT:$L123544
$T123704 DD	019930520H
	DD	0aH
	DD	FLAT:$T123713
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UWaveTexture@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20
$T123501 = -16
$T123542 = -16
__$EHRec$ = -12
??1UWaveTexture@@UAE@XZ PROC NEAR			; UWaveTexture::~UWaveTexture, COMDAT
; _this$ = ecx

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L123712
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaveTexture@@6B@ ; UWaveTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0004e	8b ce		 mov	 ecx, esi
  00050	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00058	ff d7		 call	 edi
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	8b ce		 mov	 ecx, esi
  00063	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 3
  0006b	ff d7		 call	 edi
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00073	89 0e		 mov	 DWORD PTR [esi], ecx
  00075	8b ce		 mov	 ecx, esi
  00077	c7 44 24 24 06
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 6
  0007f	ff d7		 call	 edi
  00081	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00087	89 7c 24 18	 mov	 DWORD PTR $T123501[esp+40], edi
  0008b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0008e	3b dd		 cmp	 ebx, ebp
  00090	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  00095	7d 18		 jge	 SHORT $L123670
  00097	68 fd 01 00 00	 push	 509			; 000001fdH
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123670:
  000af	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000b2	7e 18		 jle	 SHORT $L123671
  000b4	68 fe 01 00 00	 push	 510			; 000001feH
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123671:
  000cc	3b dd		 cmp	 ebx, ebp
  000ce	7e 1d		 jle	 SHORT $L123676
  000d0	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L123674:
  000d4	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d6	6a 00		 push	 0
  000d8	03 cd		 add	 ecx, ebp
  000da	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000df	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000e3	83 c5 28	 add	 ebp, 40			; 00000028H
  000e6	48		 dec	 eax
  000e7	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000eb	75 e7		 jne	 SHORT $L123674
$L123676:
  000ed	6a 28		 push	 40			; 00000028H
  000ef	53		 push	 ebx
  000f0	6a 00		 push	 0
  000f2	8b cf		 mov	 ecx, edi
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000fa	8b cf		 mov	 ecx, edi
  000fc	c6 44 24 24 05	 mov	 BYTE PTR __$EHRec$[esp+48], 5
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00107	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  0010d	89 7c 24 18	 mov	 DWORD PTR $T123542[esp+40], edi
  00111	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00114	85 ed		 test	 ebp, ebp
  00116	c6 44 24 24 08	 mov	 BYTE PTR __$EHRec$[esp+48], 8
  0011b	7d 18		 jge	 SHORT $L123686
  0011d	68 fd 01 00 00	 push	 509			; 000001fdH
  00122	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123686:
  00135	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  00138	7e 18		 jle	 SHORT $L123687
  0013a	68 fe 01 00 00	 push	 510			; 000001feH
  0013f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00144	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L123687:
  00152	85 ed		 test	 ebp, ebp
  00154	7e 23		 jle	 SHORT $L123692
  00156	33 db		 xor	 ebx, ebx
  00158	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015c	8d 64 24 00	 npad	 4
$L123690:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L123690
$L123692:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_??_7UBitmap@@6B@
  00199	89 16		 mov	 DWORD PTR [esi], edx
  0019b	8b ce		 mov	 ecx, esi
  0019d	c7 44 24 24 09
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 9
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001ab	8b ce		 mov	 ecx, esi
  001ad	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001bb	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5d		 pop	 ebp
  001c2	5b		 pop	 ebx
  001c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ca	83 c4 18	 add	 esp, 24			; 00000018H
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L123450:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
$L123452:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L123454:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L123456:
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L123458:
  00022	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L123459:
  0002b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00034	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L123460:
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00042	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L123462:
  00047	8b 4d f0	 mov	 ecx, DWORD PTR $T123501[ebp]
  0004a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L123503:
  00050	8b 4d f0	 mov	 ecx, DWORD PTR $T123542[ebp]
  00053	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L123544:
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L123712:
  00062	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T123704
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UWaveTexture@@UAE@XZ ENDP				; UWaveTexture::~UWaveTexture
; Function compile flags: /Ogty
;	COMDAT ?InternalConstructor@UWaveTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UWaveTexture@@SAXPAX@Z PROC NEAR	; UWaveTexture::InternalConstructor, COMDAT

; 361  : 	DECLARE_CLASS(UWaveTexture,UWaterTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L123720
  00008	e9 00 00 00 00	 jmp	 ??0UWaveTexture@@QAE@XZ	; UWaveTexture::UWaveTexture
$L123720:
  0000d	c3		 ret	 0
?InternalConstructor@UWaveTexture@@SAXPAX@Z ENDP	; UWaveTexture::InternalConstructor
_TEXT	ENDS
PUBLIC	??0UWaveTexture@@QAE@ABV0@@Z			; UWaveTexture::UWaveTexture
; Function compile flags: /Ogty
;	COMDAT ??0UWaveTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0UWaveTexture@@QAE@ABV0@@Z PROC NEAR			; UWaveTexture::UWaveTexture, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR ___that$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	55		 push	 ebp
  00009	8b d9		 mov	 ebx, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@ABV0@@Z
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00016	89 03		 mov	 DWORD PTR [ebx], eax
  00018	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR [ebp+200]
  0001e	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx
  00024	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR [ebp+204]
  0002a	89 93 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], edx
  00030	8b 85 d0 00 00
	00		 mov	 eax, DWORD PTR [ebp+208]
  00036	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  0003c	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+212]
  00042	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx
  00048	8b 95 d8 00 00
	00		 mov	 edx, DWORD PTR [ebp+216]
  0004e	89 93 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], edx
  00054	8a 85 dc 00 00
	00		 mov	 al, BYTE PTR [ebp+220]
  0005a	88 83 dc 00 00
	00		 mov	 BYTE PTR [ebx+220], al
  00060	8a 8d dd 00 00
	00		 mov	 cl, BYTE PTR [ebp+221]
  00066	88 8b dd 00 00
	00		 mov	 BYTE PTR [ebx+221], cl
  0006c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00072	8a 95 e0 00 00
	00		 mov	 dl, BYTE PTR [ebp+224]
  00078	88 93 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], dl
  0007e	8a 85 e1 00 00
	00		 mov	 al, BYTE PTR [ebp+225]
  00084	88 83 e1 00 00
	00		 mov	 BYTE PTR [ebx+225], al
  0008a	8a 8d e2 00 00
	00		 mov	 cl, BYTE PTR [ebp+226]
  00090	88 8b e2 00 00
	00		 mov	 BYTE PTR [ebx+226], cl
  00096	8a 95 e3 00 00
	00		 mov	 dl, BYTE PTR [ebp+227]
  0009c	88 93 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], dl
  000a2	8a 85 e4 00 00
	00		 mov	 al, BYTE PTR [ebp+228]
  000a8	88 83 e4 00 00
	00		 mov	 BYTE PTR [ebx+228], al
  000ae	8a 8d e5 00 00
	00		 mov	 cl, BYTE PTR [ebp+229]
  000b4	88 8b e5 00 00
	00		 mov	 BYTE PTR [ebx+229], cl
  000ba	8a 95 e6 00 00
	00		 mov	 dl, BYTE PTR [ebp+230]
  000c0	88 93 e6 00 00
	00		 mov	 BYTE PTR [ebx+230], dl
  000c6	8a 85 e7 00 00
	00		 mov	 al, BYTE PTR [ebp+231]
  000cc	88 83 e7 00 00
	00		 mov	 BYTE PTR [ebx+231], al
  000d2	8a 8d e8 00 00
	00		 mov	 cl, BYTE PTR [ebp+232]
  000d8	88 8b e8 00 00
	00		 mov	 BYTE PTR [ebx+232], cl
  000de	8a 95 e9 00 00
	00		 mov	 dl, BYTE PTR [ebp+233]
  000e4	88 93 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], dl
  000ea	8b 85 ec 00 00
	00		 mov	 eax, DWORD PTR [ebp+236]
  000f0	89 83 ec 00 00
	00		 mov	 DWORD PTR [ebx+236], eax
  000f6	8d b5 f0 00 00
	00		 lea	 esi, DWORD PTR [ebp+240]
  000fc	8d bb f0 00 00
	00		 lea	 edi, DWORD PTR [ebx+240]
  00102	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00107	f3 a5		 rep movsd
  00109	8b 8d f0 08 00
	00		 mov	 ecx, DWORD PTR [ebp+2288]
  0010f	89 8b f0 08 00
	00		 mov	 DWORD PTR [ebx+2288], ecx
  00115	8d b5 f4 08 00
	00		 lea	 esi, DWORD PTR [ebp+2292]
  0011b	8d bb f4 08 00
	00		 lea	 edi, DWORD PTR [ebx+2292]
  00121	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00126	f3 a5		 rep movsd
  00128	8d b5 f8 0c 00
	00		 lea	 esi, DWORD PTR [ebp+3320]
  0012e	8d bb f8 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3320]
  00134	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00139	f3 a5		 rep movsd
  0013b	8a 95 f8 12 00
	00		 mov	 dl, BYTE PTR [ebp+4856]
  00141	88 93 f8 12 00
	00		 mov	 BYTE PTR [ebx+4856], dl
  00147	8b 85 fc 12 00
	00		 mov	 eax, DWORD PTR [ebp+4860]
  0014d	89 83 fc 12 00
	00		 mov	 DWORD PTR [ebx+4860], eax
  00153	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00159	8a 8d 00 13 00
	00		 mov	 cl, BYTE PTR [ebp+4864]
  0015f	88 8b 00 13 00
	00		 mov	 BYTE PTR [ebx+4864], cl
  00165	8a 95 01 13 00
	00		 mov	 dl, BYTE PTR [ebp+4865]
  0016b	88 93 01 13 00
	00		 mov	 BYTE PTR [ebx+4865], dl
  00171	8a 85 02 13 00
	00		 mov	 al, BYTE PTR [ebp+4866]
  00177	5f		 pop	 edi
  00178	88 83 02 13 00
	00		 mov	 BYTE PTR [ebx+4866], al
  0017e	8a 8d 03 13 00
	00		 mov	 cl, BYTE PTR [ebp+4867]
  00184	5e		 pop	 esi
  00185	5d		 pop	 ebp
  00186	88 8b 03 13 00
	00		 mov	 BYTE PTR [ebx+4867], cl
  0018c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaveTexture@@6B@ ; UWaveTexture::`vftable'
  00192	8b c3		 mov	 eax, ebx
  00194	5b		 pop	 ebx
  00195	c2 04 00	 ret	 4
??0UWaveTexture@@QAE@ABV0@@Z ENDP			; UWaveTexture::UWaveTexture
_TEXT	ENDS
PUBLIC	??4UWaveTexture@@QAEAAV0@ABV0@@Z		; UWaveTexture::operator=
EXTRN	__imp_??4UBitmap@@QAEAAV0@ABV0@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ??4UWaveTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4UWaveTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UWaveTexture::operator=, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b 7c 24 14	 mov	 edi, DWORD PTR ___that$[esp+12]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UBitmap@@QAEAAV0@ABV0@@Z
  00011	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00014	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00017	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  0001a	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  0001d	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00020	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  00023	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00026	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00029	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  0002c	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  0002f	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  00032	89 56 68	 mov	 DWORD PTR [esi+104], edx
  00035	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00038	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  0003b	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  0003e	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  00041	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00044	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00047	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  0004a	89 46 78	 mov	 DWORD PTR [esi+120], eax
  0004d	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00050	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  00053	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  00059	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0005f	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  00065	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  0006b	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00071	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00077	33 c1		 xor	 eax, ecx
  00079	83 e0 01	 and	 eax, 1
  0007c	33 c1		 xor	 eax, ecx
  0007e	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00084	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0008a	33 c8		 xor	 ecx, eax
  0008c	83 e1 02	 and	 ecx, 2
  0008f	33 c8		 xor	 ecx, eax
  00091	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00097	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0009d	33 c1		 xor	 eax, ecx
  0009f	83 e0 04	 and	 eax, 4
  000a2	33 c1		 xor	 eax, ecx
  000a4	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000aa	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000b0	33 c8		 xor	 ecx, eax
  000b2	83 e1 08	 and	 ecx, 8
  000b5	33 c8		 xor	 ecx, eax
  000b7	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000bd	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c3	33 c1		 xor	 eax, ecx
  000c5	83 e0 10	 and	 eax, 16			; 00000010H
  000c8	33 c1		 xor	 eax, ecx
  000ca	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000d0	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d6	33 c8		 xor	 ecx, eax
  000d8	83 e1 20	 and	 ecx, 32			; 00000020H
  000db	33 c8		 xor	 ecx, eax
  000dd	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e3	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  000e9	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  000ef	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  000f5	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  000fb	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  00101	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00107	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  0010d	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  00113	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00119	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  0011f	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00125	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  0012b	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  00131	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00137	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  0013d	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  00143	8d 8f a8 00 00
	00		 lea	 ecx, DWORD PTR [edi+168]
  00149	51		 push	 ecx
  0014a	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00150	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00155	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  0015b	52		 push	 edx
  0015c	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00162	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00167	8a 87 c0 00 00
	00		 mov	 al, BYTE PTR [edi+192]
  0016d	88 86 c0 00 00
	00		 mov	 BYTE PTR [esi+192], al
  00173	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  00179	89 8e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ecx
  0017f	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00185	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0018b	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00191	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00197	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  0019d	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  001a3	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  001a9	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  001af	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  001b5	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  001bb	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  001c1	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  001c7	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  001cd	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  001d3	8a 87 e0 00 00
	00		 mov	 al, BYTE PTR [edi+224]
  001d9	88 86 e0 00 00
	00		 mov	 BYTE PTR [esi+224], al
  001df	8a 8f e1 00 00
	00		 mov	 cl, BYTE PTR [edi+225]
  001e5	88 8e e1 00 00
	00		 mov	 BYTE PTR [esi+225], cl
  001eb	8a 97 e2 00 00
	00		 mov	 dl, BYTE PTR [edi+226]
  001f1	88 96 e2 00 00
	00		 mov	 BYTE PTR [esi+226], dl
  001f7	8a 87 e3 00 00
	00		 mov	 al, BYTE PTR [edi+227]
  001fd	88 86 e3 00 00
	00		 mov	 BYTE PTR [esi+227], al
  00203	8a 8f e4 00 00
	00		 mov	 cl, BYTE PTR [edi+228]
  00209	88 8e e4 00 00
	00		 mov	 BYTE PTR [esi+228], cl
  0020f	8a 97 e5 00 00
	00		 mov	 dl, BYTE PTR [edi+229]
  00215	88 96 e5 00 00
	00		 mov	 BYTE PTR [esi+229], dl
  0021b	8a 87 e6 00 00
	00		 mov	 al, BYTE PTR [edi+230]
  00221	88 86 e6 00 00
	00		 mov	 BYTE PTR [esi+230], al
  00227	8a 8f e7 00 00
	00		 mov	 cl, BYTE PTR [edi+231]
  0022d	88 8e e7 00 00
	00		 mov	 BYTE PTR [esi+231], cl
  00233	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  00239	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  0023f	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  00245	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  0024b	8b 8f ec 00 00
	00		 mov	 ecx, DWORD PTR [edi+236]
  00251	89 8e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ecx
  00257	8b cf		 mov	 ecx, edi
  00259	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0025f	2b ce		 sub	 ecx, esi
  00261	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$L123768:
  00266	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  00269	89 18		 mov	 DWORD PTR [eax], ebx
  0026b	8b 5c 01 04	 mov	 ebx, DWORD PTR [ecx+eax+4]
  0026f	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00272	83 c0 08	 add	 eax, 8
  00275	4a		 dec	 edx
  00276	75 ee		 jne	 SHORT $L123768
  00278	8b 97 f0 08 00
	00		 mov	 edx, DWORD PTR [edi+2288]
  0027e	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  00283	89 96 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], edx
  00289	8d 86 f4 08 00
	00		 lea	 eax, DWORD PTR [esi+2292]
  0028f	2b ee		 sub	 ebp, esi
$L123772:
  00291	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00294	88 10		 mov	 BYTE PTR [eax], dl
  00296	40		 inc	 eax
  00297	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  0029a	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  002a0	72 ef		 jb	 SHORT $L123772
  002a2	bd 08 f3 ff ff	 mov	 ebp, -3320		; fffff308H
  002a7	8d 86 f8 0c 00
	00		 lea	 eax, DWORD PTR [esi+3320]
  002ad	2b ee		 sub	 ebp, esi
  002af	90		 npad	 1
$L123776:
  002b0	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  002b3	88 10		 mov	 BYTE PTR [eax], dl
  002b5	40		 inc	 eax
  002b6	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  002b9	81 fa 00 06 00
	00		 cmp	 edx, 1536		; 00000600H
  002bf	72 ef		 jb	 SHORT $L123776
  002c1	8a 87 f8 12 00
	00		 mov	 al, BYTE PTR [edi+4856]
  002c7	88 86 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], al
  002cd	8b 8f fc 12 00
	00		 mov	 ecx, DWORD PTR [edi+4860]
  002d3	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
  002d9	8a 97 00 13 00
	00		 mov	 dl, BYTE PTR [edi+4864]
  002df	88 96 00 13 00
	00		 mov	 BYTE PTR [esi+4864], dl
  002e5	8a 87 01 13 00
	00		 mov	 al, BYTE PTR [edi+4865]
  002eb	88 86 01 13 00
	00		 mov	 BYTE PTR [esi+4865], al
  002f1	8a 8f 02 13 00
	00		 mov	 cl, BYTE PTR [edi+4866]
  002f7	88 8e 02 13 00
	00		 mov	 BYTE PTR [esi+4866], cl
  002fd	8a 97 03 13 00
	00		 mov	 dl, BYTE PTR [edi+4867]
  00303	5f		 pop	 edi
  00304	88 96 03 13 00
	00		 mov	 BYTE PTR [esi+4867], dl
  0030a	8b c6		 mov	 eax, esi
  0030c	5e		 pop	 esi
  0030d	5d		 pop	 ebp
  0030e	5b		 pop	 ebx
  0030f	c2 04 00	 ret	 4
??4UWaveTexture@@QAEAAV0@ABV0@@Z ENDP			; UWaveTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUWaveTexture@@UAEPAXI@Z			; UWaveTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUWaveTexture@@UAEPAXI@Z PROC NEAR			; UWaveTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UWaveTexture@@UAE@XZ	; UWaveTexture::~UWaveTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L123798
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L123798:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUWaveTexture@@UAEPAXI@Z ENDP			; UWaveTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUWaveTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUWaveTexture@@UAEPAXI@Z PROC NEAR			; UWaveTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L108247
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UWaveTexture@@UAE@XZ ; UWaveTexture::~UWaveTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 04 13 00 00	 push	 4868			; 00001304H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L123804
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L123804:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L108247:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UWaveTexture@@UAE@XZ	; UWaveTexture::~UWaveTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L123806
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L123806:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUWaveTexture@@UAEPAXI@Z ENDP			; UWaveTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?StaticClass@UWetTexture@@SAPAVUClass@@XZ	; UWetTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UWetTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UWetTexture@@SAPAVUClass@@XZ PROC NEAR	; UWetTexture::StaticClass, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UWetTexture@@SAPAVUClass@@XZ ENDP		; UWetTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UWetTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR	; UWetTexture::operator new, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UWetTexture@@0VUClass@@A ; UWetTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UWetTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UWetTexture::operator new
_TEXT	ENDS
PUBLIC	??2UWetTexture@@SAPAXIPAW4EInternal@@@Z		; UWetTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UWetTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UWetTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UWetTexture::operator new, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UWetTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UWetTexture::operator new
_TEXT	ENDS
PUBLIC	??1UWetTexture@@UAE@XZ				; UWetTexture::~UWetTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T124086 DD	0ffffffffH
	DD	FLAT:$L123823
	DD	0ffffffffH
	DD	FLAT:$L123825
	DD	0ffffffffH
	DD	FLAT:$L123827
	DD	0ffffffffH
	DD	FLAT:$L123829
	DD	0ffffffffH
	DD	FLAT:$L123831
	DD	04H
	DD	FLAT:$L123832
	DD	05H
	DD	FLAT:$L123833
	DD	05H
	DD	FLAT:$L123835
	DD	04H
	DD	FLAT:$L123876
	DD	0ffffffffH
	DD	FLAT:$L123917
$T124077 DD	019930520H
	DD	0aH
	DD	FLAT:$T124086
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UWetTexture@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -20
$T123874 = -16
$T123915 = -16
??1UWetTexture@@UAE@XZ PROC NEAR			; UWetTexture::~UWetTexture, COMDAT
; _this$ = ecx

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L124085
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWetTexture@@6B@ ; UWetTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0004e	8b ce		 mov	 ecx, esi
  00050	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00058	ff d7		 call	 edi
  0005a	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0005f	89 06		 mov	 DWORD PTR [esi], eax
  00061	8b ce		 mov	 ecx, esi
  00063	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 3
  0006b	ff d7		 call	 edi
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00073	89 0e		 mov	 DWORD PTR [esi], ecx
  00075	8b ce		 mov	 ecx, esi
  00077	c7 44 24 24 06
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 6
  0007f	ff d7		 call	 edi
  00081	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00087	89 7c 24 18	 mov	 DWORD PTR $T123874[esp+40], edi
  0008b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0008e	3b dd		 cmp	 ebx, ebp
  00090	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  00095	7d 18		 jge	 SHORT $L124045
  00097	68 fd 01 00 00	 push	 509			; 000001fdH
  0009c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000a1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124045:
  000af	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000b2	7e 18		 jle	 SHORT $L124046
  000b4	68 fe 01 00 00	 push	 510			; 000001feH
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000be	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124046:
  000cc	3b dd		 cmp	 ebx, ebp
  000ce	7e 1d		 jle	 SHORT $L124051
  000d0	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L124049:
  000d4	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d6	6a 00		 push	 0
  000d8	03 cd		 add	 ecx, ebp
  000da	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000df	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000e3	83 c5 28	 add	 ebp, 40			; 00000028H
  000e6	48		 dec	 eax
  000e7	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000eb	75 e7		 jne	 SHORT $L124049
$L124051:
  000ed	6a 28		 push	 40			; 00000028H
  000ef	53		 push	 ebx
  000f0	6a 00		 push	 0
  000f2	8b cf		 mov	 ecx, edi
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000fa	8b cf		 mov	 ecx, edi
  000fc	c6 44 24 24 05	 mov	 BYTE PTR __$EHRec$[esp+48], 5
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00107	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  0010d	89 7c 24 18	 mov	 DWORD PTR $T123915[esp+40], edi
  00111	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00114	85 ed		 test	 ebp, ebp
  00116	c6 44 24 24 08	 mov	 BYTE PTR __$EHRec$[esp+48], 8
  0011b	7d 18		 jge	 SHORT $L124061
  0011d	68 fd 01 00 00	 push	 509			; 000001fdH
  00122	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00127	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124061:
  00135	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  00138	7e 18		 jle	 SHORT $L124062
  0013a	68 fe 01 00 00	 push	 510			; 000001feH
  0013f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00144	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  00149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0014f	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124062:
  00152	85 ed		 test	 ebp, ebp
  00154	7e 23		 jle	 SHORT $L124067
  00156	33 db		 xor	 ebx, ebx
  00158	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015c	8d 64 24 00	 npad	 4
$L124065:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L124065
$L124067:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_??_7UBitmap@@6B@
  00199	89 16		 mov	 DWORD PTR [esi], edx
  0019b	8b ce		 mov	 ecx, esi
  0019d	c7 44 24 24 09
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 9
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001ab	8b ce		 mov	 ecx, esi
  001ad	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001bb	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001bf	5f		 pop	 edi
  001c0	5e		 pop	 esi
  001c1	5d		 pop	 ebp
  001c2	5b		 pop	 ebx
  001c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ca	83 c4 18	 add	 esp, 24			; 00000018H
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L123823:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UWaterTexture@@UAE@XZ ; UWaterTexture::~UWaterTexture
$L123825:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L123827:
  00010	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L123829:
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L123831:
  00022	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L123832:
  0002b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00034	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L123833:
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00042	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L123835:
  00047	8b 4d f0	 mov	 ecx, DWORD PTR $T123874[ebp]
  0004a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L123876:
  00050	8b 4d f0	 mov	 ecx, DWORD PTR $T123915[ebp]
  00053	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L123917:
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L124085:
  00062	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T124077
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UWetTexture@@UAE@XZ ENDP				; UWetTexture::~UWetTexture
; Function compile flags: /Ogty
;	COMDAT ?InternalConstructor@UWetTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UWetTexture@@SAXPAX@Z PROC NEAR	; UWetTexture::InternalConstructor, COMDAT

; 390  : 	DECLARE_CLASS(UWetTexture,UWaterTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L124093
  00008	e9 00 00 00 00	 jmp	 ??0UWetTexture@@QAE@XZ	; UWetTexture::UWetTexture
$L124093:
  0000d	c3		 ret	 0
?InternalConstructor@UWetTexture@@SAXPAX@Z ENDP		; UWetTexture::InternalConstructor
_TEXT	ENDS
EXTRN	__imp_?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT
_Time$ = 8
_RenDev$ = 20
_TempInfo$108325 = -128
?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z PROC NEAR ; UWetTexture::Lock, COMDAT
; _this$ = ecx
; _TextureInfo$ = edx

; 411  : 	{

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	53		 push	 ebx

; 412  : 		if( SourceTexture )

  00007	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR _Time$[esp+128]
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  00018	85 c9		 test	 ecx, ecx
  0001a	57		 push	 edi
  0001b	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _Time$[esp+144]
  00022	8b ea		 mov	 ebp, edx
  00024	74 22		 je	 SHORT $L108326

; 413  : 		{
; 414  : 			FTextureInfo TempInfo;
; 415  : 			if( SourceTexture != this )

  00026	3b ce		 cmp	 ecx, esi
  00028	74 1e		 je	 SHORT $L108326

; 416  : 			{
; 417  : 				SourceTexture->Lock( TempInfo, Time, 0, NULL );

  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	57		 push	 edi
  00031	53		 push	 ebx
  00032	8d 54 24 20	 lea	 edx, DWORD PTR _TempInfo$108325[esp+160]
  00036	ff 50 48	 call	 DWORD PTR [eax+72]

; 418  : 				SourceTexture->Unlock( TempInfo );

  00039	8b 8e 00 13 00
	00		 mov	 ecx, DWORD PTR [esi+4864]
  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	8d 54 24 10	 lea	 edx, DWORD PTR _TempInfo$108325[esp+144]
  00045	ff 50 4c	 call	 DWORD PTR [eax+76]
$L108326:

; 419  : 			}
; 420  : 		}
; 421  : 		Super::Lock( TextureInfo, Time, 0, RenDev );

  00048	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _RenDev$[esp+140]
  0004f	51		 push	 ecx
  00050	6a 00		 push	 0
  00052	57		 push	 edi
  00053	53		 push	 ebx
  00054	8b d5		 mov	 edx, ebp
  00056	8b ce		 mov	 ecx, esi
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5d		 pop	 ebp
  00061	5b		 pop	 ebx

; 422  : 	}

  00062	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00068	c2 10 00	 ret	 16			; 00000010H
?Lock@UWetTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ENDP ; UWetTexture::Lock
_TEXT	ENDS
PUBLIC	??0UWetTexture@@QAE@ABV0@@Z			; UWetTexture::UWetTexture
; Function compile flags: /Ogty
;	COMDAT ??0UWetTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??0UWetTexture@@QAE@ABV0@@Z PROC NEAR			; UWetTexture::UWetTexture, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR ___that$[esp+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	55		 push	 ebp
  00009	8b d9		 mov	 ebx, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UTexture@@QAE@ABV0@@Z
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00016	89 03		 mov	 DWORD PTR [ebx], eax
  00018	8b 8d c8 00 00
	00		 mov	 ecx, DWORD PTR [ebp+200]
  0001e	89 8b c8 00 00
	00		 mov	 DWORD PTR [ebx+200], ecx
  00024	8b 95 cc 00 00
	00		 mov	 edx, DWORD PTR [ebp+204]
  0002a	89 93 cc 00 00
	00		 mov	 DWORD PTR [ebx+204], edx
  00030	8b 85 d0 00 00
	00		 mov	 eax, DWORD PTR [ebp+208]
  00036	89 83 d0 00 00
	00		 mov	 DWORD PTR [ebx+208], eax
  0003c	8b 8d d4 00 00
	00		 mov	 ecx, DWORD PTR [ebp+212]
  00042	89 8b d4 00 00
	00		 mov	 DWORD PTR [ebx+212], ecx
  00048	8b 95 d8 00 00
	00		 mov	 edx, DWORD PTR [ebp+216]
  0004e	89 93 d8 00 00
	00		 mov	 DWORD PTR [ebx+216], edx
  00054	8a 85 dc 00 00
	00		 mov	 al, BYTE PTR [ebp+220]
  0005a	88 83 dc 00 00
	00		 mov	 BYTE PTR [ebx+220], al
  00060	8a 8d dd 00 00
	00		 mov	 cl, BYTE PTR [ebp+221]
  00066	88 8b dd 00 00
	00		 mov	 BYTE PTR [ebx+221], cl
  0006c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  00072	8a 95 e0 00 00
	00		 mov	 dl, BYTE PTR [ebp+224]
  00078	88 93 e0 00 00
	00		 mov	 BYTE PTR [ebx+224], dl
  0007e	8a 85 e1 00 00
	00		 mov	 al, BYTE PTR [ebp+225]
  00084	88 83 e1 00 00
	00		 mov	 BYTE PTR [ebx+225], al
  0008a	8a 8d e2 00 00
	00		 mov	 cl, BYTE PTR [ebp+226]
  00090	88 8b e2 00 00
	00		 mov	 BYTE PTR [ebx+226], cl
  00096	8a 95 e3 00 00
	00		 mov	 dl, BYTE PTR [ebp+227]
  0009c	88 93 e3 00 00
	00		 mov	 BYTE PTR [ebx+227], dl
  000a2	8a 85 e4 00 00
	00		 mov	 al, BYTE PTR [ebp+228]
  000a8	88 83 e4 00 00
	00		 mov	 BYTE PTR [ebx+228], al
  000ae	8a 8d e5 00 00
	00		 mov	 cl, BYTE PTR [ebp+229]
  000b4	88 8b e5 00 00
	00		 mov	 BYTE PTR [ebx+229], cl
  000ba	8a 95 e6 00 00
	00		 mov	 dl, BYTE PTR [ebp+230]
  000c0	88 93 e6 00 00
	00		 mov	 BYTE PTR [ebx+230], dl
  000c6	8a 85 e7 00 00
	00		 mov	 al, BYTE PTR [ebp+231]
  000cc	88 83 e7 00 00
	00		 mov	 BYTE PTR [ebx+231], al
  000d2	8a 8d e8 00 00
	00		 mov	 cl, BYTE PTR [ebp+232]
  000d8	88 8b e8 00 00
	00		 mov	 BYTE PTR [ebx+232], cl
  000de	8a 95 e9 00 00
	00		 mov	 dl, BYTE PTR [ebp+233]
  000e4	88 93 e9 00 00
	00		 mov	 BYTE PTR [ebx+233], dl
  000ea	8b 85 ec 00 00
	00		 mov	 eax, DWORD PTR [ebp+236]
  000f0	89 83 ec 00 00
	00		 mov	 DWORD PTR [ebx+236], eax
  000f6	8d b5 f0 00 00
	00		 lea	 esi, DWORD PTR [ebp+240]
  000fc	8d bb f0 00 00
	00		 lea	 edi, DWORD PTR [ebx+240]
  00102	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00107	f3 a5		 rep movsd
  00109	8b 8d f0 08 00
	00		 mov	 ecx, DWORD PTR [ebp+2288]
  0010f	89 8b f0 08 00
	00		 mov	 DWORD PTR [ebx+2288], ecx
  00115	8d b5 f4 08 00
	00		 lea	 esi, DWORD PTR [ebp+2292]
  0011b	8d bb f4 08 00
	00		 lea	 edi, DWORD PTR [ebx+2292]
  00121	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00126	f3 a5		 rep movsd
  00128	8d b5 f8 0c 00
	00		 lea	 esi, DWORD PTR [ebp+3320]
  0012e	8d bb f8 0c 00
	00		 lea	 edi, DWORD PTR [ebx+3320]
  00134	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00139	f3 a5		 rep movsd
  0013b	8a 95 f8 12 00
	00		 mov	 dl, BYTE PTR [ebp+4856]
  00141	88 93 f8 12 00
	00		 mov	 BYTE PTR [ebx+4856], dl
  00147	8b 85 fc 12 00
	00		 mov	 eax, DWORD PTR [ebp+4860]
  0014d	89 83 fc 12 00
	00		 mov	 DWORD PTR [ebx+4860], eax
  00153	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWaterTexture@@6B@ ; UWaterTexture::`vftable'
  00159	8b 8d 00 13 00
	00		 mov	 ecx, DWORD PTR [ebp+4864]
  0015f	89 8b 00 13 00
	00		 mov	 DWORD PTR [ebx+4864], ecx
  00165	8b 95 04 13 00
	00		 mov	 edx, DWORD PTR [ebp+4868]
  0016b	5f		 pop	 edi
  0016c	89 93 04 13 00
	00		 mov	 DWORD PTR [ebx+4868], edx
  00172	8b 85 08 13 00
	00		 mov	 eax, DWORD PTR [ebp+4872]
  00178	5e		 pop	 esi
  00179	89 83 08 13 00
	00		 mov	 DWORD PTR [ebx+4872], eax
  0017f	5d		 pop	 ebp
  00180	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET FLAT:??_7UWetTexture@@6B@ ; UWetTexture::`vftable'
  00186	8b c3		 mov	 eax, ebx
  00188	5b		 pop	 ebx
  00189	c2 04 00	 ret	 4
??0UWetTexture@@QAE@ABV0@@Z ENDP			; UWetTexture::UWetTexture
_TEXT	ENDS
PUBLIC	??4UWetTexture@@QAEAAV0@ABV0@@Z			; UWetTexture::operator=
; Function compile flags: /Ogty
;	COMDAT ??4UWetTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4UWetTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UWetTexture::operator=, COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi
  00004	8b 7c 24 14	 mov	 edi, DWORD PTR ___that$[esp+12]
  00008	57		 push	 edi
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UBitmap@@QAEAAV0@ABV0@@Z
  00011	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  00014	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00017	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  0001a	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  0001d	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00020	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  00023	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00026	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00029	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  0002c	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  0002f	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  00032	89 56 68	 mov	 DWORD PTR [esi+104], edx
  00035	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00038	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  0003b	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  0003e	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  00041	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  00044	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00047	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  0004a	89 46 78	 mov	 DWORD PTR [esi+120], eax
  0004d	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00050	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  00053	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  00059	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  0005f	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  00065	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  0006b	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  00071	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00077	33 c1		 xor	 eax, ecx
  00079	83 e0 01	 and	 eax, 1
  0007c	33 c1		 xor	 eax, ecx
  0007e	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00084	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0008a	33 c8		 xor	 ecx, eax
  0008c	83 e1 02	 and	 ecx, 2
  0008f	33 c8		 xor	 ecx, eax
  00091	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00097	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0009d	33 c1		 xor	 eax, ecx
  0009f	83 e0 04	 and	 eax, 4
  000a2	33 c1		 xor	 eax, ecx
  000a4	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000aa	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000b0	33 c8		 xor	 ecx, eax
  000b2	83 e1 08	 and	 ecx, 8
  000b5	33 c8		 xor	 ecx, eax
  000b7	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000bd	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c3	33 c1		 xor	 eax, ecx
  000c5	83 e0 10	 and	 eax, 16			; 00000010H
  000c8	33 c1		 xor	 eax, ecx
  000ca	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000d0	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d6	33 c8		 xor	 ecx, eax
  000d8	83 e1 20	 and	 ecx, 32			; 00000020H
  000db	33 c8		 xor	 ecx, eax
  000dd	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e3	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  000e9	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  000ef	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  000f5	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  000fb	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  00101	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00107	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  0010d	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  00113	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00119	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  0011f	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  00125	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  0012b	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  00131	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00137	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  0013d	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  00143	8d 8f a8 00 00
	00		 lea	 ecx, DWORD PTR [edi+168]
  00149	51		 push	 ecx
  0014a	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00150	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00155	8d 97 b4 00 00
	00		 lea	 edx, DWORD PTR [edi+180]
  0015b	52		 push	 edx
  0015c	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  00162	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00167	8a 87 c0 00 00
	00		 mov	 al, BYTE PTR [edi+192]
  0016d	88 86 c0 00 00
	00		 mov	 BYTE PTR [esi+192], al
  00173	8b 8f c4 00 00
	00		 mov	 ecx, DWORD PTR [edi+196]
  00179	89 8e c4 00 00
	00		 mov	 DWORD PTR [esi+196], ecx
  0017f	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00185	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0018b	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00191	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00197	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  0019d	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  001a3	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  001a9	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  001af	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  001b5	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  001bb	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  001c1	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  001c7	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  001cd	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  001d3	8a 87 e0 00 00
	00		 mov	 al, BYTE PTR [edi+224]
  001d9	88 86 e0 00 00
	00		 mov	 BYTE PTR [esi+224], al
  001df	8a 8f e1 00 00
	00		 mov	 cl, BYTE PTR [edi+225]
  001e5	88 8e e1 00 00
	00		 mov	 BYTE PTR [esi+225], cl
  001eb	8a 97 e2 00 00
	00		 mov	 dl, BYTE PTR [edi+226]
  001f1	88 96 e2 00 00
	00		 mov	 BYTE PTR [esi+226], dl
  001f7	8a 87 e3 00 00
	00		 mov	 al, BYTE PTR [edi+227]
  001fd	88 86 e3 00 00
	00		 mov	 BYTE PTR [esi+227], al
  00203	8a 8f e4 00 00
	00		 mov	 cl, BYTE PTR [edi+228]
  00209	88 8e e4 00 00
	00		 mov	 BYTE PTR [esi+228], cl
  0020f	8a 97 e5 00 00
	00		 mov	 dl, BYTE PTR [edi+229]
  00215	88 96 e5 00 00
	00		 mov	 BYTE PTR [esi+229], dl
  0021b	8a 87 e6 00 00
	00		 mov	 al, BYTE PTR [edi+230]
  00221	88 86 e6 00 00
	00		 mov	 BYTE PTR [esi+230], al
  00227	8a 8f e7 00 00
	00		 mov	 cl, BYTE PTR [edi+231]
  0022d	88 8e e7 00 00
	00		 mov	 BYTE PTR [esi+231], cl
  00233	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  00239	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  0023f	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  00245	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  0024b	8b 8f ec 00 00
	00		 mov	 ecx, DWORD PTR [edi+236]
  00251	89 8e ec 00 00
	00		 mov	 DWORD PTR [esi+236], ecx
  00257	8b cf		 mov	 ecx, edi
  00259	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0025f	2b ce		 sub	 ecx, esi
  00261	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
$L124159:
  00266	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  00269	89 18		 mov	 DWORD PTR [eax], ebx
  0026b	8b 5c 01 04	 mov	 ebx, DWORD PTR [ecx+eax+4]
  0026f	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00272	83 c0 08	 add	 eax, 8
  00275	4a		 dec	 edx
  00276	75 ee		 jne	 SHORT $L124159
  00278	8b 97 f0 08 00
	00		 mov	 edx, DWORD PTR [edi+2288]
  0027e	bd 0c f7 ff ff	 mov	 ebp, -2292		; fffff70cH
  00283	89 96 f0 08 00
	00		 mov	 DWORD PTR [esi+2288], edx
  00289	8d 86 f4 08 00
	00		 lea	 eax, DWORD PTR [esi+2292]
  0028f	2b ee		 sub	 ebp, esi
$L124163:
  00291	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  00294	88 10		 mov	 BYTE PTR [eax], dl
  00296	40		 inc	 eax
  00297	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  0029a	81 fa 04 04 00
	00		 cmp	 edx, 1028		; 00000404H
  002a0	72 ef		 jb	 SHORT $L124163
  002a2	bd 08 f3 ff ff	 mov	 ebp, -3320		; fffff308H
  002a7	8d 86 f8 0c 00
	00		 lea	 eax, DWORD PTR [esi+3320]
  002ad	2b ee		 sub	 ebp, esi
  002af	90		 npad	 1
$L124167:
  002b0	8a 14 08	 mov	 dl, BYTE PTR [eax+ecx]
  002b3	88 10		 mov	 BYTE PTR [eax], dl
  002b5	40		 inc	 eax
  002b6	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
  002b9	81 fa 00 06 00
	00		 cmp	 edx, 1536		; 00000600H
  002bf	72 ef		 jb	 SHORT $L124167
  002c1	8a 87 f8 12 00
	00		 mov	 al, BYTE PTR [edi+4856]
  002c7	88 86 f8 12 00
	00		 mov	 BYTE PTR [esi+4856], al
  002cd	8b 8f fc 12 00
	00		 mov	 ecx, DWORD PTR [edi+4860]
  002d3	89 8e fc 12 00
	00		 mov	 DWORD PTR [esi+4860], ecx
  002d9	8b 97 00 13 00
	00		 mov	 edx, DWORD PTR [edi+4864]
  002df	89 96 00 13 00
	00		 mov	 DWORD PTR [esi+4864], edx
  002e5	8b 87 04 13 00
	00		 mov	 eax, DWORD PTR [edi+4868]
  002eb	89 86 04 13 00
	00		 mov	 DWORD PTR [esi+4868], eax
  002f1	8b 8f 08 13 00
	00		 mov	 ecx, DWORD PTR [edi+4872]
  002f7	5f		 pop	 edi
  002f8	89 8e 08 13 00
	00		 mov	 DWORD PTR [esi+4872], ecx
  002fe	8b c6		 mov	 eax, esi
  00300	5e		 pop	 esi
  00301	5d		 pop	 ebp
  00302	5b		 pop	 ebx
  00303	c2 04 00	 ret	 4
??4UWetTexture@@QAEAAV0@ABV0@@Z ENDP			; UWetTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUWetTexture@@UAEPAXI@Z			; UWetTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUWetTexture@@UAEPAXI@Z PROC NEAR			; UWetTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UWetTexture@@UAE@XZ	; UWetTexture::~UWetTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L124182
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L124182:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUWetTexture@@UAEPAXI@Z ENDP				; UWetTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUWetTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUWetTexture@@UAEPAXI@Z PROC NEAR			; UWetTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L108340
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UWetTexture@@UAE@XZ ; UWetTexture::~UWetTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 0c 13 00 00	 push	 4876			; 0000130cH
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L124188
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L124188:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L108340:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UWetTexture@@UAE@XZ	; UWetTexture::~UWetTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L124190
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L124190:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUWetTexture@@UAEPAXI@Z ENDP				; UWetTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4KeyPoint@@QAEAAU0@ABU0@@Z			; KeyPoint::operator=
; Function compile flags: /Ogty
;	COMDAT ??4KeyPoint@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
??4KeyPoint@@QAEAAU0@ABU0@@Z PROC NEAR			; KeyPoint::operator=, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	8b 4c 24 04	 mov	 ecx, DWORD PTR ___that$[esp-4]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	c2 04 00	 ret	 4
??4KeyPoint@@QAEAAU0@ABU0@@Z ENDP			; KeyPoint::operator=
_TEXT	ENDS
PUBLIC	?StaticClass@UIceTexture@@SAPAVUClass@@XZ	; UIceTexture::StaticClass
; Function compile flags: /Ogty
;	COMDAT ?StaticClass@UIceTexture@@SAPAVUClass@@XZ
_TEXT	SEGMENT
?StaticClass@UIceTexture@@SAPAVUClass@@XZ PROC NEAR	; UIceTexture::StaticClass, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A ; UIceTexture::PrivateStaticClass
  00005	c3		 ret	 0
?StaticClass@UIceTexture@@SAPAVUClass@@XZ ENDP		; UIceTexture::StaticClass
_TEXT	ENDS
PUBLIC	??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z	; UIceTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z
_TEXT	SEGMENT
_Outer$ = 12
_Name$ = 16
_SetFlags$ = 20
??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z PROC NEAR	; UIceTexture::operator new, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GError@@3PAVFOutputDeviceError@@A
  00005	8b 08		 mov	 ecx, DWORD PTR [eax]
  00007	8b 54 24 10	 mov	 edx, DWORD PTR _SetFlags$[esp-4]
  0000b	8b 44 24 0c	 mov	 eax, DWORD PTR _Name$[esp-4]
  0000f	6a 00		 push	 0
  00011	51		 push	 ecx
  00012	8b 4c 24 10	 mov	 ecx, DWORD PTR _Outer$[esp+4]
  00016	6a 00		 push	 0
  00018	52		 push	 edx
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	68 00 00 00 00	 push	 OFFSET FLAT:?PrivateStaticClass@UIceTexture@@0VUClass@@A ; UIceTexture::PrivateStaticClass
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?StaticAllocateObject@UObject@@SAPAV1@PAVUClass@@PAV1@VFName@@K1PAVFOutputDevice@@1@Z
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	c3		 ret	 0
??2UIceTexture@@SAPAXIPAVUObject@@VFName@@K@Z ENDP	; UIceTexture::operator new
_TEXT	ENDS
PUBLIC	??2UIceTexture@@SAPAXIPAW4EInternal@@@Z		; UIceTexture::operator new
; Function compile flags: /Ogty
;	COMDAT ??2UIceTexture@@SAPAXIPAW4EInternal@@@Z
_TEXT	SEGMENT
_Mem$ = 12
??2UIceTexture@@SAPAXIPAW4EInternal@@@Z PROC NEAR	; UIceTexture::operator new, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Mem$[esp-4]
  00004	c3		 ret	 0
??2UIceTexture@@SAPAXIPAW4EInternal@@@Z ENDP		; UIceTexture::operator new
_TEXT	ENDS
PUBLIC	??1UIceTexture@@UAE@XZ				; UIceTexture::~UIceTexture
;	COMDAT xdata$x
; File ..\..\Engine\Inc\UnTex.h
xdata$x	SEGMENT
$T124445 DD	0ffffffffH
	DD	FLAT:$L124210
	DD	0ffffffffH
	DD	FLAT:$L124212
	DD	0ffffffffH
	DD	FLAT:$L124214
	DD	0ffffffffH
	DD	FLAT:$L124216
	DD	03H
	DD	FLAT:$L124217
	DD	04H
	DD	FLAT:$L124218
	DD	04H
	DD	FLAT:$L124220
	DD	03H
	DD	FLAT:$L124268
	DD	0ffffffffH
	DD	FLAT:$L124309
$T124436 DD	019930520H
	DD	09H
	DD	FLAT:$T124445
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File D:\DEV\DNF2001\Stable\Fire\Src\FractalPrivate.h
xdata$x	ENDS
;	COMDAT ??1UIceTexture@@UAE@XZ
_TEXT	SEGMENT
$T124266 = -16
$T124307 = -16
__$EHRec$ = -12
_this$ = -20
??1UIceTexture@@UAE@XZ PROC NEAR			; UIceTexture::~UIceTexture, COMDAT
; _this$ = ecx

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L124444
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	57		 push	 edi
  0001e	89 74 24 14	 mov	 DWORD PTR _this$[esp+40], esi
  00022	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UIceTexture@@6B@ ; UIceTexture::`vftable'
  00028	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  0002e	33 ed		 xor	 ebp, ebp
  00030	89 6c 24 24	 mov	 DWORD PTR __$EHRec$[esp+48], ebp
  00034	ff d7		 call	 edi
  00036	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0003c	8b ce		 mov	 ecx, esi
  0003e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00046	ff d7		 call	 edi
  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  0004d	89 06		 mov	 DWORD PTR [esi], eax
  0004f	8b ce		 mov	 ecx, esi
  00051	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 2
  00059	ff d7		 call	 edi
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UTexture@@6B@
  00061	89 0e		 mov	 DWORD PTR [esi], ecx
  00063	8b ce		 mov	 ecx, esi
  00065	c7 44 24 24 05
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 5
  0006d	ff d7		 call	 edi
  0006f	8d be b4 00 00
	00		 lea	 edi, DWORD PTR [esi+180]
  00075	89 7c 24 18	 mov	 DWORD PTR $T124266[esp+40], edi
  00079	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0007c	3b dd		 cmp	 ebx, ebp
  0007e	c6 44 24 24 06	 mov	 BYTE PTR __$EHRec$[esp+48], 6
  00083	7d 18		 jge	 SHORT $L124399
  00085	68 fd 01 00 00	 push	 509			; 000001fdH
  0008a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0008f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124399:
  0009d	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  000a0	7e 18		 jle	 SHORT $L124400
  000a2	68 fe 01 00 00	 push	 510			; 000001feH
  000a7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124400:
  000ba	3b dd		 cmp	 ebx, ebp
  000bc	7e 1f		 jle	 SHORT $L124405
  000be	89 5c 24 10	 mov	 DWORD PTR -24+[esp+40], ebx
$L124403:
  000c2	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c4	6a 00		 push	 0
  000c6	03 cd		 add	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  000cd	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  000d1	83 c5 28	 add	 ebp, 40			; 00000028H
  000d4	48		 dec	 eax
  000d5	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  000d9	75 e7		 jne	 SHORT $L124403
  000db	33 ed		 xor	 ebp, ebp
$L124405:
  000dd	6a 28		 push	 40			; 00000028H
  000df	53		 push	 ebx
  000e0	55		 push	 ebp
  000e1	8b cf		 mov	 ecx, edi
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  000e9	8b 07		 mov	 eax, DWORD PTR [edi]
  000eb	3b c5		 cmp	 eax, ebp
  000ed	c6 44 24 24 04	 mov	 BYTE PTR __$EHRec$[esp+48], 4
  000f2	74 0e		 je	 SHORT $L124413
  000f4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  000fa	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fe	50		 push	 eax
  000ff	ff 52 08	 call	 DWORD PTR [edx+8]
$L124413:
  00102	89 2f		 mov	 DWORD PTR [edi], ebp
  00104	89 6f 08	 mov	 DWORD PTR [edi+8], ebp
  00107	89 6f 04	 mov	 DWORD PTR [edi+4], ebp
  0010a	8d be a8 00 00
	00		 lea	 edi, DWORD PTR [esi+168]
  00110	89 7c 24 18	 mov	 DWORD PTR $T124307[esp+40], edi
  00114	8b 6f 04	 mov	 ebp, DWORD PTR [edi+4]
  00117	85 ed		 test	 ebp, ebp
  00119	c6 44 24 24 07	 mov	 BYTE PTR __$EHRec$[esp+48], 7
  0011e	7d 18		 jge	 SHORT $L124418
  00120	68 fd 01 00 00	 push	 509			; 000001fdH
  00125	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  0012a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@FEMP@Index?$DM?$DNArrayNum?$AA@ ; `string'
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00135	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124418:
  00138	3b 6f 04	 cmp	 ebp, DWORD PTR [edi+4]
  0013b	7e 18		 jle	 SHORT $L124419
  0013d	68 fe 01 00 00	 push	 510			; 000001feH
  00142	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BM@MLGP@?4?4?2?4?4?2Core?2Inc?2UnTemplate?4h?$AA@ ; `string'
  00147	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BEDF@Index?$CLCount?$DM?$DNArrayNum?$AA@ ; `string'
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?appFailAssert@@YAXPBD0H@Z
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
$L124419:
  00155	85 ed		 test	 ebp, ebp
  00157	7e 20		 jle	 SHORT $L124424
  00159	33 db		 xor	 ebx, ebx
  0015b	89 6c 24 10	 mov	 DWORD PTR -24+[esp+40], ebp
  0015f	90		 npad	 1
$L124422:
  00160	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00162	6a 00		 push	 0
  00164	03 cb		 add	 ecx, ebx
  00166	e8 00 00 00 00	 call	 ??_GFMipmap@@QAEPAXI@Z	; FMipmap::`scalar deleting destructor'
  0016b	8b 44 24 10	 mov	 eax, DWORD PTR -24+[esp+40]
  0016f	83 c3 28	 add	 ebx, 40			; 00000028H
  00172	48		 dec	 eax
  00173	89 44 24 10	 mov	 DWORD PTR -24+[esp+40], eax
  00177	75 e7		 jne	 SHORT $L124422
$L124424:
  00179	6a 28		 push	 40			; 00000028H
  0017b	55		 push	 ebp
  0017c	6a 00		 push	 0
  0017e	8b cf		 mov	 ecx, edi
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Remove@FArray@@QAEXHHH@Z
  00186	8b cf		 mov	 ecx, edi
  00188	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1FArray@@QAE@XZ
  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00198	89 06		 mov	 DWORD PTR [esi], eax
  0019a	8b ce		 mov	 ecx, esi
  0019c	c7 44 24 24 08
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 8
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ConditionalDestroy@UObject@@QAEHXZ
  001aa	8b ce		 mov	 ecx, esi
  001ac	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+48], -1
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1UObject@@UAE@XZ
  001ba	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5d		 pop	 ebp
  001c1	5b		 pop	 ebx
  001c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001c9	83 c4 18	 add	 esp, 24			; 00000018H
  001cc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L124210:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1UFractalTexture@@UAE@XZ ; UFractalTexture::~UFractalTexture
$L124212:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UProceduralTexture@@UAE@XZ
$L124214:
  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UTexture@@UAE@XZ
$L124216:
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L124217:
  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0002c	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L124218:
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0003a	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L124220:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR $T124266[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L124268:
  00048	8b 4d f0	 mov	 ecx, DWORD PTR $T124307[ebp]
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1FArray@@QAE@XZ
$L124309:
  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UObject@@UAE@XZ
$L124444:
  0005a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T124436
  0005f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1UIceTexture@@UAE@XZ ENDP				; UIceTexture::~UIceTexture
; Function compile flags: /Ogty
;	COMDAT ?InternalConstructor@UIceTexture@@SAXPAX@Z
_TEXT	SEGMENT
_X$ = 8
?InternalConstructor@UIceTexture@@SAXPAX@Z PROC NEAR	; UIceTexture::InternalConstructor, COMDAT

; 469  : 	DECLARE_CLASS(UIceTexture,UFractalTexture,0)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _X$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	74 05		 je	 SHORT $L124452
  00008	e9 00 00 00 00	 jmp	 ??0UIceTexture@@QAE@XZ	; UIceTexture::UIceTexture
$L124452:
  0000d	c3		 ret	 0
?InternalConstructor@UIceTexture@@SAXPAX@Z ENDP		; UIceTexture::InternalConstructor
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
_TEXT	SEGMENT
_Time$ = 8
_RenDev$ = 20
_TempInfo$108478 = -128
_TempInfo$108481 = -128
?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z PROC NEAR ; UIceTexture::Lock, COMDAT
; _this$ = ecx
; _TextureInfo$ = edx

; 511  : 	{

  00000	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00006	53		 push	 ebx

; 512  : 		if( GlassTexture )

  00007	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR _Time$[esp+128]
  0000e	55		 push	 ebp
  0000f	56		 push	 esi
  00010	8b f1		 mov	 esi, ecx
  00012	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  00018	85 c9		 test	 ecx, ecx
  0001a	57		 push	 edi
  0001b	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR _Time$[esp+144]
  00022	8b ea		 mov	 ebp, edx
  00024	74 22		 je	 SHORT $L108479

; 513  : 		{
; 514  : 			FTextureInfo TempInfo;
; 515  : 			if( GlassTexture != this )

  00026	3b ce		 cmp	 ecx, esi
  00028	74 1e		 je	 SHORT $L108479

; 516  : 			{
; 517  : 				GlassTexture->Lock( TempInfo, Time, 0, NULL );

  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	57		 push	 edi
  00031	53		 push	 ebx
  00032	8d 54 24 20	 lea	 edx, DWORD PTR _TempInfo$108478[esp+160]
  00036	ff 50 48	 call	 DWORD PTR [eax+72]

; 518  : 				GlassTexture->Unlock( TempInfo );

  00039	8b 8e e0 00 00
	00		 mov	 ecx, DWORD PTR [esi+224]
  0003f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00041	8d 54 24 10	 lea	 edx, DWORD PTR _TempInfo$108478[esp+144]
  00045	ff 50 4c	 call	 DWORD PTR [eax+76]
$L108479:

; 519  : 			}
; 520  : 		}
; 521  : 		if( SourceTexture )

  00048	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0004e	85 c9		 test	 ecx, ecx
  00050	74 22		 je	 SHORT $L108482

; 522  : 		{
; 523  : 			FTextureInfo TempInfo;
; 524  : 			if( SourceTexture != this )

  00052	3b ce		 cmp	 ecx, esi
  00054	74 1e		 je	 SHORT $L108482

; 525  : 			{
; 526  : 				SourceTexture->Lock( TempInfo, Time, 0, NULL );

  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	6a 00		 push	 0
  0005a	6a 00		 push	 0
  0005c	57		 push	 edi
  0005d	53		 push	 ebx
  0005e	8d 54 24 20	 lea	 edx, DWORD PTR _TempInfo$108481[esp+160]
  00062	ff 50 48	 call	 DWORD PTR [eax+72]

; 527  : 				SourceTexture->Unlock(TempInfo);

  00065	8b 8e e4 00 00
	00		 mov	 ecx, DWORD PTR [esi+228]
  0006b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006d	8d 54 24 10	 lea	 edx, DWORD PTR _TempInfo$108481[esp+144]
  00071	ff 50 4c	 call	 DWORD PTR [eax+76]
$L108482:

; 528  : 			}
; 529  : 		}
; 530  : 		Super::Lock( TextureInfo, Time, 0, RenDev );

  00074	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR _RenDev$[esp+140]
  0007b	51		 push	 ecx
  0007c	6a 00		 push	 0
  0007e	57		 push	 edi
  0007f	53		 push	 ebx
  00080	8b d5		 mov	 edx, ebp
  00082	8b ce		 mov	 ecx, esi
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Lock@UTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	5b		 pop	 ebx

; 531  : 	}

  0008e	81 c4 80 00 00
	00		 add	 esp, 128		; 00000080H
  00094	c2 10 00	 ret	 16			; 00000010H
?Lock@UIceTexture@@UAIXAAUFTextureInfo@@NHPAVURenderDevice@@@Z ENDP ; UIceTexture::Lock
_TEXT	ENDS
PUBLIC	??0UIceTexture@@QAE@ABV0@@Z			; UIceTexture::UIceTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
$T124513 DD	0ffffffffH
	DD	FLAT:$L124485
	DD	00H
	DD	FLAT:$L124486
$T124511 DD	019930520H
	DD	02H
	DD	FLAT:$T124513
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??0UIceTexture@@QAE@ABV0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
___that$ = 8
_this$ = -16
??0UIceTexture@@QAE@ABV0@@Z PROC NEAR			; UIceTexture::UIceTexture, COMDAT
; _this$ = ecx
  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 $L124512
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7c 24 1c	 mov	 edi, DWORD PTR ___that$[esp+20]
  0001c	8b f1		 mov	 esi, ecx
  0001e	57		 push	 edi
  0001f	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0UObject@@QAE@ABV0@@Z
  00029	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  0002c	88 46 28	 mov	 BYTE PTR [esi+40], al
  0002f	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  00032	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  00035	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00038	88 56 30	 mov	 BYTE PTR [esi+48], dl
  0003b	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  0003e	88 46 31	 mov	 BYTE PTR [esi+49], al
  00041	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00044	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00047	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  0004a	89 56 38	 mov	 DWORD PTR [esi+56], edx
  0004d	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00050	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00053	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00056	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00059	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  0005c	89 56 44	 mov	 DWORD PTR [esi+68], edx
  0005f	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  00062	89 46 48	 mov	 DWORD PTR [esi+72], eax
  00065	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00068	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  0006b	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0006e	89 56 50	 mov	 DWORD PTR [esi+80], edx
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UBitmap@@6B@
  00076	89 06		 mov	 DWORD PTR [esi], eax
  00078	8b 4f 54	 mov	 ecx, DWORD PTR [edi+84]
  0007b	89 4e 54	 mov	 DWORD PTR [esi+84], ecx
  0007e	8b 57 58	 mov	 edx, DWORD PTR [edi+88]
  00081	89 56 58	 mov	 DWORD PTR [esi+88], edx
  00084	8b 47 5c	 mov	 eax, DWORD PTR [edi+92]
  00087	89 46 5c	 mov	 DWORD PTR [esi+92], eax
  0008a	8b 4f 60	 mov	 ecx, DWORD PTR [edi+96]
  0008d	89 4e 60	 mov	 DWORD PTR [esi+96], ecx
  00090	8b 57 64	 mov	 edx, DWORD PTR [edi+100]
  00093	89 56 64	 mov	 DWORD PTR [esi+100], edx
  00096	8b 47 68	 mov	 eax, DWORD PTR [edi+104]
  00099	89 46 68	 mov	 DWORD PTR [esi+104], eax
  0009c	8b 4f 6c	 mov	 ecx, DWORD PTR [edi+108]
  0009f	89 4e 6c	 mov	 DWORD PTR [esi+108], ecx
  000a2	8b 57 70	 mov	 edx, DWORD PTR [edi+112]
  000a5	89 56 70	 mov	 DWORD PTR [esi+112], edx
  000a8	8b 47 74	 mov	 eax, DWORD PTR [edi+116]
  000ab	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000ae	8b 4f 78	 mov	 ecx, DWORD PTR [edi+120]
  000b1	89 4e 78	 mov	 DWORD PTR [esi+120], ecx
  000b4	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]
  000b7	89 56 7c	 mov	 DWORD PTR [esi+124], edx
  000ba	8b 87 80 00 00
	00		 mov	 eax, DWORD PTR [edi+128]
  000c0	89 86 80 00 00
	00		 mov	 DWORD PTR [esi+128], eax
  000c6	8b 8f 84 00 00
	00		 mov	 ecx, DWORD PTR [edi+132]
  000cc	89 8e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ecx
  000d2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000d8	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000de	33 c1		 xor	 eax, ecx
  000e0	83 e0 01	 and	 eax, 1
  000e3	33 c1		 xor	 eax, ecx
  000e5	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000eb	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f1	33 c8		 xor	 ecx, eax
  000f3	83 e1 02	 and	 ecx, 2
  000f6	33 c8		 xor	 ecx, eax
  000f8	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000fe	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00104	33 c1		 xor	 eax, ecx
  00106	83 e0 04	 and	 eax, 4
  00109	33 c1		 xor	 eax, ecx
  0010b	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00111	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  00117	33 c8		 xor	 ecx, eax
  00119	83 e1 08	 and	 ecx, 8
  0011c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00132	33 c1		 xor	 eax, ecx
  00134	83 e0 10	 and	 eax, 16			; 00000010H
  00137	33 c1		 xor	 eax, ecx
  00139	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  0013f	8b 97 88 00 00
	00		 mov	 edx, DWORD PTR [edi+136]
  00145	33 d0		 xor	 edx, eax
  00147	83 e2 20	 and	 edx, 32			; 00000020H
  0014a	33 d0		 xor	 edx, eax
  0014c	89 96 88 00 00
	00		 mov	 DWORD PTR [esi+136], edx
  00152	8a 87 8c 00 00
	00		 mov	 al, BYTE PTR [edi+140]
  00158	88 86 8c 00 00
	00		 mov	 BYTE PTR [esi+140], al
  0015e	8b 8f 90 00 00
	00		 mov	 ecx, DWORD PTR [edi+144]
  00164	89 8e 90 00 00
	00		 mov	 DWORD PTR [esi+144], ecx
  0016a	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [edi+148]
  00170	89 96 94 00 00
	00		 mov	 DWORD PTR [esi+148], edx
  00176	8a 87 98 00 00
	00		 mov	 al, BYTE PTR [edi+152]
  0017c	88 86 98 00 00
	00		 mov	 BYTE PTR [esi+152], al
  00182	8a 8f 99 00 00
	00		 mov	 cl, BYTE PTR [edi+153]
  00188	88 8e 99 00 00
	00		 mov	 BYTE PTR [esi+153], cl
  0018e	8b 97 9c 00 00
	00		 mov	 edx, DWORD PTR [edi+156]
  00194	89 96 9c 00 00
	00		 mov	 DWORD PTR [esi+156], edx
  0019a	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  001a0	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  001a6	8b 8f a4 00 00
	00		 mov	 ecx, DWORD PTR [edi+164]
  001ac	8d 97 a8 00 00
	00		 lea	 edx, DWORD PTR [edi+168]
  001b2	89 8e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ecx
  001b8	52		 push	 edx
  001b9	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  001bf	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001c4	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001ca	50		 push	 eax
  001cb	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001d1	c6 44 24 18 01	 mov	 BYTE PTR __$EHRec$[esp+36], 1
  001d6	e8 00 00 00 00	 call	 ??0?$TArray@UFMipmap@@@@QAE@ABV0@@Z ; TArray<FMipmap>::TArray<FMipmap>
  001db	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  001e1	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  001e7	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  001ed	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  001f3	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_??_7UTexture@@6B@
  001f8	89 06		 mov	 DWORD PTR [esi], eax
  001fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_??_7UProceduralTexture@@6B@
  00200	89 0e		 mov	 DWORD PTR [esi], ecx
  00202	8b 97 c8 00 00
	00		 mov	 edx, DWORD PTR [edi+200]
  00208	89 96 c8 00 00
	00		 mov	 DWORD PTR [esi+200], edx
  0020e	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  00214	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  0021a	8b 8f d0 00 00
	00		 mov	 ecx, DWORD PTR [edi+208]
  00220	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  00226	8b 97 d4 00 00
	00		 mov	 edx, DWORD PTR [edi+212]
  0022c	89 96 d4 00 00
	00		 mov	 DWORD PTR [esi+212], edx
  00232	8b 87 d8 00 00
	00		 mov	 eax, DWORD PTR [edi+216]
  00238	89 86 d8 00 00
	00		 mov	 DWORD PTR [esi+216], eax
  0023e	8a 8f dc 00 00
	00		 mov	 cl, BYTE PTR [edi+220]
  00244	88 8e dc 00 00
	00		 mov	 BYTE PTR [esi+220], cl
  0024a	8a 97 dd 00 00
	00		 mov	 dl, BYTE PTR [edi+221]
  00250	88 96 dd 00 00
	00		 mov	 BYTE PTR [esi+221], dl
  00256	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UFractalTexture@@6B@ ; UFractalTexture::`vftable'
  0025c	8b 87 e0 00 00
	00		 mov	 eax, DWORD PTR [edi+224]
  00262	89 86 e0 00 00
	00		 mov	 DWORD PTR [esi+224], eax
  00268	8b 8f e4 00 00
	00		 mov	 ecx, DWORD PTR [edi+228]
  0026e	89 8e e4 00 00
	00		 mov	 DWORD PTR [esi+228], ecx
  00274	8a 97 e8 00 00
	00		 mov	 dl, BYTE PTR [edi+232]
  0027a	88 96 e8 00 00
	00		 mov	 BYTE PTR [esi+232], dl
  00280	8a 87 e9 00 00
	00		 mov	 al, BYTE PTR [edi+233]
  00286	88 86 e9 00 00
	00		 mov	 BYTE PTR [esi+233], al
  0028c	8a 8f ea 00 00
	00		 mov	 cl, BYTE PTR [edi+234]
  00292	88 8e ea 00 00
	00		 mov	 BYTE PTR [esi+234], cl
  00298	8a 97 eb 00 00
	00		 mov	 dl, BYTE PTR [edi+235]
  0029e	88 96 eb 00 00
	00		 mov	 BYTE PTR [esi+235], dl
  002a4	8a 87 ec 00 00
	00		 mov	 al, BYTE PTR [edi+236]
  002aa	88 86 ec 00 00
	00		 mov	 BYTE PTR [esi+236], al
  002b0	8a 8f ed 00 00
	00		 mov	 cl, BYTE PTR [edi+237]
  002b6	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  002bc	88 8e ed 00 00
	00		 mov	 BYTE PTR [esi+237], cl
  002c2	8b 97 f0 00 00
	00		 mov	 edx, DWORD PTR [edi+240]
  002c8	33 d0		 xor	 edx, eax
  002ca	83 e2 01	 and	 edx, 1
  002cd	33 d0		 xor	 edx, eax
  002cf	89 96 f0 00 00
	00		 mov	 DWORD PTR [esi+240], edx
  002d5	8b 87 f4 00 00
	00		 mov	 eax, DWORD PTR [edi+244]
  002db	89 86 f4 00 00
	00		 mov	 DWORD PTR [esi+244], eax
  002e1	8b 8f f8 00 00
	00		 mov	 ecx, DWORD PTR [edi+248]
  002e7	89 8e f8 00 00
	00		 mov	 DWORD PTR [esi+248], ecx
  002ed	8b 97 fc 00 00
	00		 mov	 edx, DWORD PTR [edi+252]
  002f3	89 96 fc 00 00
	00		 mov	 DWORD PTR [esi+252], edx
  002f9	8b 87 00 01 00
	00		 mov	 eax, DWORD PTR [edi+256]
  002ff	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  00305	8b 8f 04 01 00
	00		 mov	 ecx, DWORD PTR [edi+260]
  0030b	89 8e 04 01 00
	00		 mov	 DWORD PTR [esi+260], ecx
  00311	8b 97 08 01 00
	00		 mov	 edx, DWORD PTR [edi+264]
  00317	89 96 08 01 00
	00		 mov	 DWORD PTR [esi+264], edx
  0031d	8b 87 0c 01 00
	00		 mov	 eax, DWORD PTR [edi+268]
  00323	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  00329	8b 8f 10 01 00
	00		 mov	 ecx, DWORD PTR [edi+272]
  0032f	89 8e 10 01 00
	00		 mov	 DWORD PTR [esi+272], ecx
  00335	8b 97 14 01 00
	00		 mov	 edx, DWORD PTR [edi+276]
  0033b	89 96 14 01 00
	00		 mov	 DWORD PTR [esi+276], edx
  00341	8b 87 18 01 00
	00		 mov	 eax, DWORD PTR [edi+280]
  00347	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  0034d	8b 8f 1c 01 00
	00		 mov	 ecx, DWORD PTR [edi+284]
  00353	89 8e 1c 01 00
	00		 mov	 DWORD PTR [esi+284], ecx
  00359	8b 97 20 01 00
	00		 mov	 edx, DWORD PTR [edi+288]
  0035f	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00363	89 96 20 01 00
	00		 mov	 DWORD PTR [esi+288], edx
  00369	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7UIceTexture@@6B@ ; UIceTexture::`vftable'
  0036f	5f		 pop	 edi
  00370	8b c6		 mov	 eax, esi
  00372	5e		 pop	 esi
  00373	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0037a	83 c4 10	 add	 esp, 16			; 00000010H
  0037d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L124485:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1UBitmap@@UAE@XZ
$L124486:
  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00012	e9 00 00 00 00	 jmp	 ??1?$TArray@UFMipmap@@@@QAE@XZ ; TArray<FMipmap>::~TArray<FMipmap>
$L124512:
  00017	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T124511
  0001c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0UIceTexture@@QAE@ABV0@@Z ENDP			; UIceTexture::UIceTexture
PUBLIC	??4UIceTexture@@QAEAAV0@ABV0@@Z			; UIceTexture::operator=
; Function compile flags: /Ogty
;	COMDAT ??4UIceTexture@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_i$124593 = -4
___that$ = 8
??4UIceTexture@@QAEAAV0@ABV0@@Z PROC NEAR		; UIceTexture::operator=, COMDAT
; _this$ = ecx
  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7c 24 18	 mov	 edi, DWORD PTR ___that$[esp+16]
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4UObject@@QAEAAV0@ABV0@@Z
  00012	8a 47 28	 mov	 al, BYTE PTR [edi+40]
  00015	88 46 28	 mov	 BYTE PTR [esi+40], al
  00018	8b 4f 2c	 mov	 ecx, DWORD PTR [edi+44]
  0001b	89 4e 2c	 mov	 DWORD PTR [esi+44], ecx
  0001e	8a 57 30	 mov	 dl, BYTE PTR [edi+48]
  00021	88 56 30	 mov	 BYTE PTR [esi+48], dl
  00024	8a 47 31	 mov	 al, BYTE PTR [edi+49]
  00027	88 46 31	 mov	 BYTE PTR [esi+49], al
  0002a	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  0002d	89 4e 34	 mov	 DWORD PTR [esi+52], ecx
  00030	8b 57 38	 mov	 edx, DWORD PTR [edi+56]
  00033	89 56 38	 mov	 DWORD PTR [esi+56], edx
  00036	8b 47 3c	 mov	 eax, DWORD PTR [edi+60]
  00039	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  0003c	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  0003f	89 4e 40	 mov	 DWORD PTR [esi+64], ecx
  00042	8b 57 44	 mov	 edx, DWORD PTR [edi+68]
  00045	89 56 44	 mov	 DWORD PTR [esi+68], edx
  00048	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0004b	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0004e	8b 4f 4c	 mov	 ecx, DWORD PTR [edi+76]
  00051	89 4e 4c	 mov	 DWORD PTR [esi+76], ecx
  00054	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  00057	89 56 50	 mov	 DWORD PTR [esi+80], edx
  0005a	8b 47 54	 mov	 eax, DWORD PTR [edi+84]
  0005d	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00060	8b 4f 58	 mov	 ecx, DWORD PTR [edi+88]
  00063	89 4e 58	 mov	 DWORD PTR [esi+88], ecx
  00066	8b 57 5c	 mov	 edx, DWORD PTR [edi+92]
  00069	89 56 5c	 mov	 DWORD PTR [esi+92], edx
  0006c	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0006f	89 46 60	 mov	 DWORD PTR [esi+96], eax
  00072	8b 4f 64	 mov	 ecx, DWORD PTR [edi+100]
  00075	89 4e 64	 mov	 DWORD PTR [esi+100], ecx
  00078	8b 57 68	 mov	 edx, DWORD PTR [edi+104]
  0007b	89 56 68	 mov	 DWORD PTR [esi+104], edx
  0007e	8b 47 6c	 mov	 eax, DWORD PTR [edi+108]
  00081	89 46 6c	 mov	 DWORD PTR [esi+108], eax
  00084	8b 4f 70	 mov	 ecx, DWORD PTR [edi+112]
  00087	89 4e 70	 mov	 DWORD PTR [esi+112], ecx
  0008a	8b 57 74	 mov	 edx, DWORD PTR [edi+116]
  0008d	89 56 74	 mov	 DWORD PTR [esi+116], edx
  00090	8b 47 78	 mov	 eax, DWORD PTR [edi+120]
  00093	89 46 78	 mov	 DWORD PTR [esi+120], eax
  00096	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  00099	89 4e 7c	 mov	 DWORD PTR [esi+124], ecx
  0009c	8b 97 80 00 00
	00		 mov	 edx, DWORD PTR [edi+128]
  000a2	8b 8e 88 00 00
	00		 mov	 ecx, DWORD PTR [esi+136]
  000a8	89 96 80 00 00
	00		 mov	 DWORD PTR [esi+128], edx
  000ae	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  000b4	89 86 84 00 00
	00		 mov	 DWORD PTR [esi+132], eax
  000ba	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000c0	33 c1		 xor	 eax, ecx
  000c2	83 e0 01	 and	 eax, 1
  000c5	33 c1		 xor	 eax, ecx
  000c7	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000cd	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000d3	33 c8		 xor	 ecx, eax
  000d5	83 e1 02	 and	 ecx, 2
  000d8	33 c8		 xor	 ecx, eax
  000da	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  000e0	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  000e6	33 c1		 xor	 eax, ecx
  000e8	83 e0 04	 and	 eax, 4
  000eb	33 c1		 xor	 eax, ecx
  000ed	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  000f3	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  000f9	33 c8		 xor	 ecx, eax
  000fb	83 e1 08	 and	 ecx, 8
  000fe	33 c8		 xor	 ecx, eax
  00100	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  00106	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  0010c	33 c1		 xor	 eax, ecx
  0010e	83 e0 10	 and	 eax, 16			; 00000010H
  00111	33 c1		 xor	 eax, ecx
  00113	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
  00119	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0011f	33 c8		 xor	 ecx, eax
  00121	83 e1 20	 and	 ecx, 32			; 00000020H
  00124	33 c8		 xor	 ecx, eax
  00126	89 8e 88 00 00
	00		 mov	 DWORD PTR [esi+136], ecx
  0012c	8a 97 8c 00 00
	00		 mov	 dl, BYTE PTR [edi+140]
  00132	88 96 8c 00 00
	00		 mov	 BYTE PTR [esi+140], dl
  00138	8b 87 90 00 00
	00		 mov	 eax, DWORD PTR [edi+144]
  0013e	89 86 90 00 00
	00		 mov	 DWORD PTR [esi+144], eax
  00144	8b 8f 94 00 00
	00		 mov	 ecx, DWORD PTR [edi+148]
  0014a	89 8e 94 00 00
	00		 mov	 DWORD PTR [esi+148], ecx
  00150	8a 97 98 00 00
	00		 mov	 dl, BYTE PTR [edi+152]
  00156	88 96 98 00 00
	00		 mov	 BYTE PTR [esi+152], dl
  0015c	8a 87 99 00 00
	00		 mov	 al, BYTE PTR [edi+153]
  00162	88 86 99 00 00
	00		 mov	 BYTE PTR [esi+153], al
  00168	8b 8f 9c 00 00
	00		 mov	 ecx, DWORD PTR [edi+156]
  0016e	89 8e 9c 00 00
	00		 mov	 DWORD PTR [esi+156], ecx
  00174	8b 97 a0 00 00
	00		 mov	 edx, DWORD PTR [edi+160]
  0017a	89 96 a0 00 00
	00		 mov	 DWORD PTR [esi+160], edx
  00180	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  00186	8d 9f a8 00 00
	00		 lea	 ebx, DWORD PTR [edi+168]
  0018c	8d ae a8 00 00
	00		 lea	 ebp, DWORD PTR [esi+168]
  00192	3b eb		 cmp	 ebp, ebx
  00194	89 86 a4 00 00
	00		 mov	 DWORD PTR [esi+164], eax
  0019a	74 55		 je	 SHORT $L124596
  0019c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0019f	51		 push	 ecx
  001a0	8b cd		 mov	 ecx, ebp
  001a2	e8 00 00 00 00	 call	 ?Empty@?$TArray@UFMipmap@@@@QAEXH@Z ; TArray<FMipmap>::Empty
  001a7	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001aa	33 c0		 xor	 eax, eax
  001ac	3b c8		 cmp	 ecx, eax
  001ae	89 44 24 10	 mov	 DWORD PTR _i$124593[esp+20], eax
  001b2	7e 3d		 jle	 SHORT $L124596
  001b4	89 44 24 18	 mov	 DWORD PTR 8+[esp+16], eax
$L124594:
  001b8	55		 push	 ebp
  001b9	6a 28		 push	 40			; 00000028H
  001bb	e8 00 00 00 00	 call	 ??2@YAPAXIAAV?$TArray@UFMipmap@@@@@Z ; operator new
  001c0	83 c4 08	 add	 esp, 8
  001c3	85 c0		 test	 eax, eax
  001c5	74 0f		 je	 SHORT $L124595
  001c7	8b 13		 mov	 edx, DWORD PTR [ebx]
  001c9	03 54 24 18	 add	 edx, DWORD PTR 8+[esp+16]
  001cd	52		 push	 edx
  001ce	8b c8		 mov	 ecx, eax
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0FMipmap@@QAE@ABU0@@Z
$L124595:
  001d6	8b 44 24 10	 mov	 eax, DWORD PTR _i$124593[esp+20]
  001da	8b 54 24 18	 mov	 edx, DWORD PTR 8+[esp+16]
  001de	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  001e1	40		 inc	 eax
  001e2	83 c2 28	 add	 edx, 40			; 00000028H
  001e5	3b c1		 cmp	 eax, ecx
  001e7	89 44 24 10	 mov	 DWORD PTR _i$124593[esp+20], eax
  001eb	89 54 24 18	 mov	 DWORD PTR 8+[esp+16], edx
  001ef	7c c7		 jl	 SHORT $L124594
$L124596:
  001f1	8d 87 b4 00 00
	00		 lea	 eax, DWORD PTR [edi+180]
  001f7	50		 push	 eax
  001f8	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  001fe	e8 00 00 00 00	 call	 ??4?$TArray@UFMipmap@@@@QAEAAV0@ABV0@@Z ; TArray<FMipmap>::operator=
  00203	8a 8f c0 00 00
	00		 mov	 cl, BYTE PTR [edi+192]
  00209	88 8e c0 00 00
	00		 mov	 BYTE PTR [esi+192], cl
  0020f	8b 97 c4 00 00
	00		 mov	 edx, DWORD PTR [edi+196]
  00215	89 96 c4 00 00
	00		 mov	 DWORD PTR [esi+196], edx
  0021b	8b 87 c8 00 00
	00		 mov	 eax, DWORD PTR [edi+200]
  00221	89 86 c8 00 00
	00		 mov	 DWORD PTR [esi+200], eax
  00227	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  0022d	89 8e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ecx
  00233	8b 97 d0 00 00
	00		 mov	 edx, DWORD PTR [edi+208]
  00239	89 96 d0 00 00
	00		 mov	 DWORD PTR [esi+208], edx
  0023f	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00245	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  0024b	8b 8f d8 00 00
	00		 mov	 ecx, DWORD PTR [edi+216]
  00251	89 8e d8 00 00
	00		 mov	 DWORD PTR [esi+216], ecx
  00257	8a 97 dc 00 00
	00		 mov	 dl, BYTE PTR [edi+220]
  0025d	88 96 dc 00 00
	00		 mov	 BYTE PTR [esi+220], dl
  00263	8a 87 dd 00 00
	00		 mov	 al, BYTE PTR [edi+221]
  00269	88 86 dd 00 00
	00		 mov	 BYTE PTR [esi+221], al
  0026f	8b 8f e0 00 00
	00		 mov	 ecx, DWORD PTR [edi+224]
  00275	89 8e e0 00 00
	00		 mov	 DWORD PTR [esi+224], ecx
  0027b	8b 97 e4 00 00
	00		 mov	 edx, DWORD PTR [edi+228]
  00281	89 96 e4 00 00
	00		 mov	 DWORD PTR [esi+228], edx
  00287	8a 87 e8 00 00
	00		 mov	 al, BYTE PTR [edi+232]
  0028d	88 86 e8 00 00
	00		 mov	 BYTE PTR [esi+232], al
  00293	8a 8f e9 00 00
	00		 mov	 cl, BYTE PTR [edi+233]
  00299	88 8e e9 00 00
	00		 mov	 BYTE PTR [esi+233], cl
  0029f	8a 97 ea 00 00
	00		 mov	 dl, BYTE PTR [edi+234]
  002a5	88 96 ea 00 00
	00		 mov	 BYTE PTR [esi+234], dl
  002ab	8a 87 eb 00 00
	00		 mov	 al, BYTE PTR [edi+235]
  002b1	88 86 eb 00 00
	00		 mov	 BYTE PTR [esi+235], al
  002b7	8a 8f ec 00 00
	00		 mov	 cl, BYTE PTR [edi+236]
  002bd	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  002c3	88 8e ec 00 00
	00		 mov	 BYTE PTR [esi+236], cl
  002c9	8a 97 ed 00 00
	00		 mov	 dl, BYTE PTR [edi+237]
  002cf	88 96 ed 00 00
	00		 mov	 BYTE PTR [esi+237], dl
  002d5	8b 8f f0 00 00
	00		 mov	 ecx, DWORD PTR [edi+240]
  002db	33 c8		 xor	 ecx, eax
  002dd	83 e1 01	 and	 ecx, 1
  002e0	33 c8		 xor	 ecx, eax
  002e2	89 8e f0 00 00
	00		 mov	 DWORD PTR [esi+240], ecx
  002e8	8b 97 f4 00 00
	00		 mov	 edx, DWORD PTR [edi+244]
  002ee	89 96 f4 00 00
	00		 mov	 DWORD PTR [esi+244], edx
  002f4	8b 87 f8 00 00
	00		 mov	 eax, DWORD PTR [edi+248]
  002fa	89 86 f8 00 00
	00		 mov	 DWORD PTR [esi+248], eax
  00300	8b 8f fc 00 00
	00		 mov	 ecx, DWORD PTR [edi+252]
  00306	89 8e fc 00 00
	00		 mov	 DWORD PTR [esi+252], ecx
  0030c	8b 97 00 01 00
	00		 mov	 edx, DWORD PTR [edi+256]
  00312	89 96 00 01 00
	00		 mov	 DWORD PTR [esi+256], edx
  00318	8b 87 04 01 00
	00		 mov	 eax, DWORD PTR [edi+260]
  0031e	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  00324	8b 8f 08 01 00
	00		 mov	 ecx, DWORD PTR [edi+264]
  0032a	89 8e 08 01 00
	00		 mov	 DWORD PTR [esi+264], ecx
  00330	8b 97 0c 01 00
	00		 mov	 edx, DWORD PTR [edi+268]
  00336	89 96 0c 01 00
	00		 mov	 DWORD PTR [esi+268], edx
  0033c	8b 87 10 01 00
	00		 mov	 eax, DWORD PTR [edi+272]
  00342	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax
  00348	8b 8f 14 01 00
	00		 mov	 ecx, DWORD PTR [edi+276]
  0034e	89 8e 14 01 00
	00		 mov	 DWORD PTR [esi+276], ecx
  00354	8b 97 18 01 00
	00		 mov	 edx, DWORD PTR [edi+280]
  0035a	89 96 18 01 00
	00		 mov	 DWORD PTR [esi+280], edx
  00360	8b 87 1c 01 00
	00		 mov	 eax, DWORD PTR [edi+284]
  00366	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  0036c	8b 8f 20 01 00
	00		 mov	 ecx, DWORD PTR [edi+288]
  00372	5f		 pop	 edi
  00373	89 8e 20 01 00
	00		 mov	 DWORD PTR [esi+288], ecx
  00379	8b c6		 mov	 eax, esi
  0037b	5e		 pop	 esi
  0037c	5d		 pop	 ebp
  0037d	5b		 pop	 ebx
  0037e	59		 pop	 ecx
  0037f	c2 04 00	 ret	 4
??4UIceTexture@@QAEAAV0@ABV0@@Z ENDP			; UIceTexture::operator=
_TEXT	ENDS
PUBLIC	??_GUIceTexture@@UAEPAXI@Z			; UIceTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
;	COMDAT ??_GUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GUIceTexture@@UAEPAXI@Z PROC NEAR			; UIceTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1UIceTexture@@UAE@XZ	; UIceTexture::~UIceTexture
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 0d		 je	 SHORT $L124608
  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	56		 push	 esi
  00019	ff 52 08	 call	 DWORD PTR [edx+8]
$L124608:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	c2 04 00	 ret	 4
??_GUIceTexture@@UAEPAXI@Z ENDP				; UIceTexture::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_EUIceTexture@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_EUIceTexture@@UAEPAXI@Z PROC NEAR			; UIceTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 33		 je	 SHORT $L108496
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1UIceTexture@@UAE@XZ ; UIceTexture::~UIceTexture
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	68 24 01 00 00	 push	 292			; 00000124H
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z	; `eh vector destructor iterator'
  00025	f6 c3 01	 test	 bl, 1
  00028	74 0e		 je	 SHORT $L124614
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00030	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	57		 push	 edi
  00035	ff 52 08	 call	 DWORD PTR [edx+8]
$L124614:
  00038	8b c7		 mov	 eax, edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	c2 04 00	 ret	 4
$L108496:
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ??1UIceTexture@@UAE@XZ	; UIceTexture::~UIceTexture
  00047	f6 c3 01	 test	 bl, 1
  0004a	74 0d		 je	 SHORT $L124616
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?GMalloc@@3PAVFMalloc@@A
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 11		 mov	 edx, DWORD PTR [ecx]
  00055	56		 push	 esi
  00056	ff 52 08	 call	 DWORD PTR [edx+8]
$L124616:
  00059	8b c6		 mov	 eax, esi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	c2 04 00	 ret	 4
??_EUIceTexture@@UAEPAXI@Z ENDP				; UIceTexture::`vector deleting destructor'
_TEXT	ENDS
END
